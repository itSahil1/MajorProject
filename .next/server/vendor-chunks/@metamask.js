"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@metamask";
exports.ids = ["vendor-chunks/@metamask"];
exports.modules = {

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/abi.js":
/*!******************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/abi.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// ESLint gets confused by the nested list and tables in the docs, so we disable\n// the rule for this file.\n/* eslint-disable jsdoc/check-indentation, jsdoc/match-description */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeSingle = exports.decode = exports.encodePacked = exports.encodeSingle = exports.encode = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst packer_1 = __webpack_require__(/*! ./packer */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/packer.js\");\n/**\n * Encode the data with the provided types. The types must be valid Solidity\n * ABI types.\n *\n * This will attempt to parse the values into the correct types. For example,\n * if you pass in a hex string for a `uint256`, it will be parsed into a\n * `bigint`. Regular strings are interpreted as UTF-8 strings. If you want to\n * pass in a hex string, you must pass it in as a `Uint8Array`, or use the\n * \"0x\"-prefix.\n *\n * It will also attempt to infer the types of the values. For example, if you\n * pass in a string for a `uint256`, it will result in a TypeScript compile-time\n * error. This does not work for all types, however. For example, if you use\n * nested arrays or tuples, the type will be inferred as `unknown`.\n *\n * The following types are supported:\n *\n * - `address`: A 20-byte Ethereum address.\n *   - As a 40-character-long hexadecimal string, starting with \"0x\".\n *   - As a 20-byte-long byte array, i.e., `Uint8Array`.\n * - `bool`: A boolean value.\n *   - As a boolean literal, i.e., `true` or `false`.\n *   - As the strings \"true\" or \"false\".\n * - `bytes(n)`: A dynamic byte array.\n *   - As a hexadecimal string, starting with \"0x\".\n *   - As a byte array, i.e., `Uint8Array`.\n *   - As a regular string, which will be interpreted as UTF-8.\n * - `function`: A Solidity function.\n *   - As a 48-character-long hexadecimal string, starting with \"0x\".\n *   - As a 24-byte-long byte array, i.e., `Uint8Array`.\n *   - As a {@link SolidityFunction} object.\n * - `int(n)`: A signed integer.\n *   - As a number.\n *   - As a `bigint`.\n *   - As a hexadecimal string, starting with \"0x\".\n * - `string`: A dynamic UTF-8 string.\n *   - As a regular string.\n *   - As a hexadecimal string, starting with \"0x\".\n *   - As a byte array, i.e., `Uint8Array`.\n * - `tuple`: A tuple of values.\n *   - As an array of values.\n * - `uint(n)`: An unsigned integer.\n *   - As a number.\n *   - As a `bigint`.\n *   - As a hexadecimal string, starting with \"0x\".\n *\n * @example\n * ```typescript\n * import { encode, decode } from '@metamask/abi-utils';\n *\n * const types = ['uint256', 'string'];\n * const encoded = encode(types, [42, 'Hello, world!']);\n * const decoded = decode(types, encoded);\n *\n * console.log(decoded); // [42n, 'Hello, world!']\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html\n * @param types - The types to encode.\n * @param values - The values to encode. This array must have the same length as\n * the types array.\n * @param packed - Whether to use the non-standard packed mode. Defaults to\n * `false`.\n * @param tight - Whether to pack the values tightly. When enabled, the values\n * will be packed without any padding. This matches the behaviour of\n * `ethereumjs-abi`. Defaults to `false`.\n * @returns The ABI encoded bytes.\n */\nconst encode = (types, values, packed, tight) => {\n    try {\n        return (0, packer_1.pack)({ types, values, packed, tight });\n    }\n    catch (error) {\n        if (error instanceof errors_1.ParserError) {\n            throw new errors_1.ParserError(`Unable to encode value: ${error.message}`, error);\n        }\n        throw new errors_1.ParserError(`An unexpected error occurred: ${(0, errors_1.getErrorMessage)(error)}`, error);\n    }\n};\nexports.encode = encode;\n/**\n * Encode the data with the provided type. The type must be a valid Solidity\n * ABI type.\n *\n * See {@link encode} for more information on how values are parsed.\n *\n * @example\n * ```typescript\n * import { encodeSingle, decodeSingle } from '@metamask/abi-utils';\n *\n * const encoded = encodeSingle('uint256', 42);\n * const decoded = decodeSingle('uint256', encoded);\n *\n * console.log(decoded); // 42n\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n * @param type - The type to encode.\n * @param value - The value to encode.\n * @returns The ABI encoded bytes.\n */\nconst encodeSingle = (type, value) => {\n    return (0, exports.encode)([type], [value]);\n};\nexports.encodeSingle = encodeSingle;\n/**\n * Encode the data with the provided types. The types must be valid Solidity\n * ABI types. This is similar to {@link encode}, but the values are encoded in\n * the non-standard packed mode. This differs from the standard encoding in the\n * following ways:\n *\n * - Most values are packed tightly, without alignment padding.\n *   - The exception is array values, which are padded to 32 bytes.\n * - Values are still padded to their full size, i.e., `uint16` values are still\n *  padded to 2 bytes, regardless of the length of the value.\n * - The encoding of dynamic types (`bytes`, `string`) is different. The length\n * of the dynamic type is not included in the encoding, and the dynamic type is\n * not padded to a multiple of 32 bytes.\n * - All values are encoded in-place, without any offsets.\n *\n * The encoding of this is ambiguous as soon as there is more than one dynamic\n * type. That means that these values cannot be decoded with {@link decode} or\n * Solidity's `abi.decode` function.\n *\n * See {@link encode} for more information on how values are parsed.\n *\n * @example\n * ```typescript\n * import { encodePacked } from '@metamask/abi-utils';\n *\n * const encoded = encodePacked(['uint8'], [42]);\n *\n * console.log(encoded); // `Uint8Array [ 42 ]`\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#non-standard-packed-mode\n * @param types - The types to encode.\n * @param values - The values to encode.\n * @param tight - Whether to pack the values tightly. When enabled, `bytesN`\n * values in arrays will be packed without any padding. This matches the\n * behaviour of `ethereumjs-abi`. Defaults to `false`.\n * @returns The ABI encoded bytes.\n */\nconst encodePacked = (types, values, tight) => {\n    return (0, exports.encode)(types, values, true, tight);\n};\nexports.encodePacked = encodePacked;\n/**\n * Decode an ABI encoded buffer with the specified types. The types must be\n * valid Solidity ABI types.\n *\n * This will attempt to infer the output types from the input types. For\n * example, if you use `uint256` as an input type, the output type will be\n * `bigint`. This does not work for all types, however. For example, if you use\n * nested array types or tuple types, the output type will be `unknown`.\n *\n * The resulting types of the values will be as follows:\n *\n * | Contract ABI Type | Resulting JavaScript Type |\n * | ----------------- | ------------------------- |\n * | `address`         | `string`                  |\n * | `bool`            | `boolean`                 |\n * | `bytes(n)`        | `Uint8Array`              |\n * | `function`        | {@link SolidityFunction}  |\n * | `int(n)`          | `bigint`                  |\n * | `string`          | `string`                  |\n * | `tuple`           | `Array`                   |\n * | `array`           | `Array`                   |\n * | `uint(n)`         | `bigint`                  |\n *\n * @example\n * ```typescript\n * import { encode, decode } from '@metamask/abi-utils';\n *\n * const types = ['uint256', 'string'];\n * const encoded = encode(types, [42, 'Hello, world!']);\n * const decoded = decode(types, encoded);\n *\n * console.log(decoded); // [42n, 'Hello, world!']\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n * @param types - The types to decode the bytes with.\n * @param value - The bytes-like value to decode.\n * @returns The decoded values as array.\n */\nconst decode = (types, value) => {\n    const bytes = (0, utils_1.createBytes)(value);\n    try {\n        return (0, packer_1.unpack)(types, bytes);\n    }\n    catch (error) {\n        if (error instanceof errors_1.ParserError) {\n            throw new errors_1.ParserError(`Unable to decode value: ${error.message}`, error);\n        }\n        throw new errors_1.ParserError(`An unexpected error occurred: ${(0, errors_1.getErrorMessage)(error)}`, error);\n    }\n};\nexports.decode = decode;\n/**\n * Decode the data with the provided type. The type must be a valid Solidity\n * ABI type.\n *\n * See {@link decode} for more information on how values are parsed.\n *\n * @example\n * ```typescript\n * import { encodeSingle, decodeSingle } from '@metamask/abi-utils';\n *\n * const encoded = encodeSingle('uint256', 42);\n * const decoded = decodeSingle('uint256', encoded);\n *\n * console.log(decoded); // 42n\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n * @param type - The type to decode.\n * @param value - The bytes-like value to decode.\n * @returns The decoded value.\n */\nconst decodeSingle = (type, value) => {\n    const result = (0, exports.decode)([type], value);\n    (0, utils_1.assert)(result.length === 1, new errors_1.ParserError('Decoded value array has unexpected length.'));\n    return result[0];\n};\nexports.decodeSingle = decodeSingle;\n//# sourceMappingURL=abi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L2FiaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxjQUFjLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsY0FBYztBQUNwRyxnQkFBZ0IsbUJBQU8sQ0FBQyw2R0FBaUI7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMseUVBQVU7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMseUVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4QkFBOEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGNBQWM7QUFDcEY7QUFDQSx3RUFBd0UscUNBQXFDO0FBQzdHO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGNBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxjQUFjO0FBQzVFO0FBQ0E7QUFDQSxRQUFRLGNBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsY0FBYztBQUNwRjtBQUNBLHdFQUF3RSxxQ0FBcUM7QUFDN0c7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsY0FBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9hYmkuanM/NTgzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIEVTTGludCBnZXRzIGNvbmZ1c2VkIGJ5IHRoZSBuZXN0ZWQgbGlzdCBhbmQgdGFibGVzIGluIHRoZSBkb2NzLCBzbyB3ZSBkaXNhYmxlXG4vLyB0aGUgcnVsZSBmb3IgdGhpcyBmaWxlLlxuLyogZXNsaW50LWRpc2FibGUganNkb2MvY2hlY2staW5kZW50YXRpb24sIGpzZG9jL21hdGNoLWRlc2NyaXB0aW9uICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZVNpbmdsZSA9IGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5lbmNvZGVQYWNrZWQgPSBleHBvcnRzLmVuY29kZVNpbmdsZSA9IGV4cG9ydHMuZW5jb2RlID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IHBhY2tlcl8xID0gcmVxdWlyZShcIi4vcGFja2VyXCIpO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGRhdGEgd2l0aCB0aGUgcHJvdmlkZWQgdHlwZXMuIFRoZSB0eXBlcyBtdXN0IGJlIHZhbGlkIFNvbGlkaXR5XG4gKiBBQkkgdHlwZXMuXG4gKlxuICogVGhpcyB3aWxsIGF0dGVtcHQgdG8gcGFyc2UgdGhlIHZhbHVlcyBpbnRvIHRoZSBjb3JyZWN0IHR5cGVzLiBGb3IgZXhhbXBsZSxcbiAqIGlmIHlvdSBwYXNzIGluIGEgaGV4IHN0cmluZyBmb3IgYSBgdWludDI1NmAsIGl0IHdpbGwgYmUgcGFyc2VkIGludG8gYVxuICogYGJpZ2ludGAuIFJlZ3VsYXIgc3RyaW5ncyBhcmUgaW50ZXJwcmV0ZWQgYXMgVVRGLTggc3RyaW5ncy4gSWYgeW91IHdhbnQgdG9cbiAqIHBhc3MgaW4gYSBoZXggc3RyaW5nLCB5b3UgbXVzdCBwYXNzIGl0IGluIGFzIGEgYFVpbnQ4QXJyYXlgLCBvciB1c2UgdGhlXG4gKiBcIjB4XCItcHJlZml4LlxuICpcbiAqIEl0IHdpbGwgYWxzbyBhdHRlbXB0IHRvIGluZmVyIHRoZSB0eXBlcyBvZiB0aGUgdmFsdWVzLiBGb3IgZXhhbXBsZSwgaWYgeW91XG4gKiBwYXNzIGluIGEgc3RyaW5nIGZvciBhIGB1aW50MjU2YCwgaXQgd2lsbCByZXN1bHQgaW4gYSBUeXBlU2NyaXB0IGNvbXBpbGUtdGltZVxuICogZXJyb3IuIFRoaXMgZG9lcyBub3Qgd29yayBmb3IgYWxsIHR5cGVzLCBob3dldmVyLiBGb3IgZXhhbXBsZSwgaWYgeW91IHVzZVxuICogbmVzdGVkIGFycmF5cyBvciB0dXBsZXMsIHRoZSB0eXBlIHdpbGwgYmUgaW5mZXJyZWQgYXMgYHVua25vd25gLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgdHlwZXMgYXJlIHN1cHBvcnRlZDpcbiAqXG4gKiAtIGBhZGRyZXNzYDogQSAyMC1ieXRlIEV0aGVyZXVtIGFkZHJlc3MuXG4gKiAgIC0gQXMgYSA0MC1jaGFyYWN0ZXItbG9uZyBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLlxuICogICAtIEFzIGEgMjAtYnl0ZS1sb25nIGJ5dGUgYXJyYXksIGkuZS4sIGBVaW50OEFycmF5YC5cbiAqIC0gYGJvb2xgOiBBIGJvb2xlYW4gdmFsdWUuXG4gKiAgIC0gQXMgYSBib29sZWFuIGxpdGVyYWwsIGkuZS4sIGB0cnVlYCBvciBgZmFsc2VgLlxuICogICAtIEFzIHRoZSBzdHJpbmdzIFwidHJ1ZVwiIG9yIFwiZmFsc2VcIi5cbiAqIC0gYGJ5dGVzKG4pYDogQSBkeW5hbWljIGJ5dGUgYXJyYXkuXG4gKiAgIC0gQXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLlxuICogICAtIEFzIGEgYnl0ZSBhcnJheSwgaS5lLiwgYFVpbnQ4QXJyYXlgLlxuICogICAtIEFzIGEgcmVndWxhciBzdHJpbmcsIHdoaWNoIHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgVVRGLTguXG4gKiAtIGBmdW5jdGlvbmA6IEEgU29saWRpdHkgZnVuY3Rpb24uXG4gKiAgIC0gQXMgYSA0OC1jaGFyYWN0ZXItbG9uZyBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLlxuICogICAtIEFzIGEgMjQtYnl0ZS1sb25nIGJ5dGUgYXJyYXksIGkuZS4sIGBVaW50OEFycmF5YC5cbiAqICAgLSBBcyBhIHtAbGluayBTb2xpZGl0eUZ1bmN0aW9ufSBvYmplY3QuXG4gKiAtIGBpbnQobilgOiBBIHNpZ25lZCBpbnRlZ2VyLlxuICogICAtIEFzIGEgbnVtYmVyLlxuICogICAtIEFzIGEgYGJpZ2ludGAuXG4gKiAgIC0gQXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLlxuICogLSBgc3RyaW5nYDogQSBkeW5hbWljIFVURi04IHN0cmluZy5cbiAqICAgLSBBcyBhIHJlZ3VsYXIgc3RyaW5nLlxuICogICAtIEFzIGEgaGV4YWRlY2ltYWwgc3RyaW5nLCBzdGFydGluZyB3aXRoIFwiMHhcIi5cbiAqICAgLSBBcyBhIGJ5dGUgYXJyYXksIGkuZS4sIGBVaW50OEFycmF5YC5cbiAqIC0gYHR1cGxlYDogQSB0dXBsZSBvZiB2YWx1ZXMuXG4gKiAgIC0gQXMgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICogLSBgdWludChuKWA6IEFuIHVuc2lnbmVkIGludGVnZXIuXG4gKiAgIC0gQXMgYSBudW1iZXIuXG4gKiAgIC0gQXMgYSBgYmlnaW50YC5cbiAqICAgLSBBcyBhIGhleGFkZWNpbWFsIHN0cmluZywgc3RhcnRpbmcgd2l0aCBcIjB4XCIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGVuY29kZSwgZGVjb2RlIH0gZnJvbSAnQG1ldGFtYXNrL2FiaS11dGlscyc7XG4gKlxuICogY29uc3QgdHlwZXMgPSBbJ3VpbnQyNTYnLCAnc3RyaW5nJ107XG4gKiBjb25zdCBlbmNvZGVkID0gZW5jb2RlKHR5cGVzLCBbNDIsICdIZWxsbywgd29ybGQhJ10pO1xuICogY29uc3QgZGVjb2RlZCA9IGRlY29kZSh0eXBlcywgZW5jb2RlZCk7XG4gKlxuICogY29uc29sZS5sb2coZGVjb2RlZCk7IC8vIFs0Mm4sICdIZWxsbywgd29ybGQhJ11cbiAqIGBgYFxuICogQHNlZSBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjE3L2FiaS1zcGVjLmh0bWxcbiAqIEBwYXJhbSB0eXBlcyAtIFRoZSB0eXBlcyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBlbmNvZGUuIFRoaXMgYXJyYXkgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhc1xuICogdGhlIHR5cGVzIGFycmF5LlxuICogQHBhcmFtIHBhY2tlZCAtIFdoZXRoZXIgdG8gdXNlIHRoZSBub24tc3RhbmRhcmQgcGFja2VkIG1vZGUuIERlZmF1bHRzIHRvXG4gKiBgZmFsc2VgLlxuICogQHBhcmFtIHRpZ2h0IC0gV2hldGhlciB0byBwYWNrIHRoZSB2YWx1ZXMgdGlnaHRseS4gV2hlbiBlbmFibGVkLCB0aGUgdmFsdWVzXG4gKiB3aWxsIGJlIHBhY2tlZCB3aXRob3V0IGFueSBwYWRkaW5nLiBUaGlzIG1hdGNoZXMgdGhlIGJlaGF2aW91ciBvZlxuICogYGV0aGVyZXVtanMtYWJpYC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqIEByZXR1cm5zIFRoZSBBQkkgZW5jb2RlZCBieXRlcy5cbiAqL1xuY29uc3QgZW5jb2RlID0gKHR5cGVzLCB2YWx1ZXMsIHBhY2tlZCwgdGlnaHQpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHBhY2tlcl8xLnBhY2spKHsgdHlwZXMsIHZhbHVlcywgcGFja2VkLCB0aWdodCB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGVycm9yc18xLlBhcnNlckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYFVuYWJsZSB0byBlbmNvZGUgdmFsdWU6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkOiAkeygwLCBlcnJvcnNfMS5nZXRFcnJvck1lc3NhZ2UpKGVycm9yKX1gLCBlcnJvcik7XG4gICAgfVxufTtcbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGRhdGEgd2l0aCB0aGUgcHJvdmlkZWQgdHlwZS4gVGhlIHR5cGUgbXVzdCBiZSBhIHZhbGlkIFNvbGlkaXR5XG4gKiBBQkkgdHlwZS5cbiAqXG4gKiBTZWUge0BsaW5rIGVuY29kZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHZhbHVlcyBhcmUgcGFyc2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBlbmNvZGVTaW5nbGUsIGRlY29kZVNpbmdsZSB9IGZyb20gJ0BtZXRhbWFzay9hYmktdXRpbHMnO1xuICpcbiAqIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVTaW5nbGUoJ3VpbnQyNTYnLCA0Mik7XG4gKiBjb25zdCBkZWNvZGVkID0gZGVjb2RlU2luZ2xlKCd1aW50MjU2JywgZW5jb2RlZCk7XG4gKlxuICogY29uc29sZS5sb2coZGVjb2RlZCk7IC8vIDQyblxuICogYGBgXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL3YwLjguMTcvYWJpLXNwZWMuaHRtbCN0eXBlc1xuICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIEFCSSBlbmNvZGVkIGJ5dGVzLlxuICovXG5jb25zdCBlbmNvZGVTaW5nbGUgPSAodHlwZSwgdmFsdWUpID0+IHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuZW5jb2RlKShbdHlwZV0sIFt2YWx1ZV0pO1xufTtcbmV4cG9ydHMuZW5jb2RlU2luZ2xlID0gZW5jb2RlU2luZ2xlO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGRhdGEgd2l0aCB0aGUgcHJvdmlkZWQgdHlwZXMuIFRoZSB0eXBlcyBtdXN0IGJlIHZhbGlkIFNvbGlkaXR5XG4gKiBBQkkgdHlwZXMuIFRoaXMgaXMgc2ltaWxhciB0byB7QGxpbmsgZW5jb2RlfSwgYnV0IHRoZSB2YWx1ZXMgYXJlIGVuY29kZWQgaW5cbiAqIHRoZSBub24tc3RhbmRhcmQgcGFja2VkIG1vZGUuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSBzdGFuZGFyZCBlbmNvZGluZyBpbiB0aGVcbiAqIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqIC0gTW9zdCB2YWx1ZXMgYXJlIHBhY2tlZCB0aWdodGx5LCB3aXRob3V0IGFsaWdubWVudCBwYWRkaW5nLlxuICogICAtIFRoZSBleGNlcHRpb24gaXMgYXJyYXkgdmFsdWVzLCB3aGljaCBhcmUgcGFkZGVkIHRvIDMyIGJ5dGVzLlxuICogLSBWYWx1ZXMgYXJlIHN0aWxsIHBhZGRlZCB0byB0aGVpciBmdWxsIHNpemUsIGkuZS4sIGB1aW50MTZgIHZhbHVlcyBhcmUgc3RpbGxcbiAqICBwYWRkZWQgdG8gMiBieXRlcywgcmVnYXJkbGVzcyBvZiB0aGUgbGVuZ3RoIG9mIHRoZSB2YWx1ZS5cbiAqIC0gVGhlIGVuY29kaW5nIG9mIGR5bmFtaWMgdHlwZXMgKGBieXRlc2AsIGBzdHJpbmdgKSBpcyBkaWZmZXJlbnQuIFRoZSBsZW5ndGhcbiAqIG9mIHRoZSBkeW5hbWljIHR5cGUgaXMgbm90IGluY2x1ZGVkIGluIHRoZSBlbmNvZGluZywgYW5kIHRoZSBkeW5hbWljIHR5cGUgaXNcbiAqIG5vdCBwYWRkZWQgdG8gYSBtdWx0aXBsZSBvZiAzMiBieXRlcy5cbiAqIC0gQWxsIHZhbHVlcyBhcmUgZW5jb2RlZCBpbi1wbGFjZSwgd2l0aG91dCBhbnkgb2Zmc2V0cy5cbiAqXG4gKiBUaGUgZW5jb2Rpbmcgb2YgdGhpcyBpcyBhbWJpZ3VvdXMgYXMgc29vbiBhcyB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGR5bmFtaWNcbiAqIHR5cGUuIFRoYXQgbWVhbnMgdGhhdCB0aGVzZSB2YWx1ZXMgY2Fubm90IGJlIGRlY29kZWQgd2l0aCB7QGxpbmsgZGVjb2RlfSBvclxuICogU29saWRpdHkncyBgYWJpLmRlY29kZWAgZnVuY3Rpb24uXG4gKlxuICogU2VlIHtAbGluayBlbmNvZGV9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyB2YWx1ZXMgYXJlIHBhcnNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgZW5jb2RlUGFja2VkIH0gZnJvbSAnQG1ldGFtYXNrL2FiaS11dGlscyc7XG4gKlxuICogY29uc3QgZW5jb2RlZCA9IGVuY29kZVBhY2tlZChbJ3VpbnQ4J10sIFs0Ml0pO1xuICpcbiAqIGNvbnNvbGUubG9nKGVuY29kZWQpOyAvLyBgVWludDhBcnJheSBbIDQyIF1gXG4gKiBgYGBcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9hYmktc3BlYy5odG1sI3R5cGVzXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL3YwLjguMTcvYWJpLXNwZWMuaHRtbCNub24tc3RhbmRhcmQtcGFja2VkLW1vZGVcbiAqIEBwYXJhbSB0eXBlcyAtIFRoZSB0eXBlcyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdGlnaHQgLSBXaGV0aGVyIHRvIHBhY2sgdGhlIHZhbHVlcyB0aWdodGx5LiBXaGVuIGVuYWJsZWQsIGBieXRlc05gXG4gKiB2YWx1ZXMgaW4gYXJyYXlzIHdpbGwgYmUgcGFja2VkIHdpdGhvdXQgYW55IHBhZGRpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAqIGJlaGF2aW91ciBvZiBgZXRoZXJldW1qcy1hYmlgLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICogQHJldHVybnMgVGhlIEFCSSBlbmNvZGVkIGJ5dGVzLlxuICovXG5jb25zdCBlbmNvZGVQYWNrZWQgPSAodHlwZXMsIHZhbHVlcywgdGlnaHQpID0+IHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuZW5jb2RlKSh0eXBlcywgdmFsdWVzLCB0cnVlLCB0aWdodCk7XG59O1xuZXhwb3J0cy5lbmNvZGVQYWNrZWQgPSBlbmNvZGVQYWNrZWQ7XG4vKipcbiAqIERlY29kZSBhbiBBQkkgZW5jb2RlZCBidWZmZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGVzLiBUaGUgdHlwZXMgbXVzdCBiZVxuICogdmFsaWQgU29saWRpdHkgQUJJIHR5cGVzLlxuICpcbiAqIFRoaXMgd2lsbCBhdHRlbXB0IHRvIGluZmVyIHRoZSBvdXRwdXQgdHlwZXMgZnJvbSB0aGUgaW5wdXQgdHlwZXMuIEZvclxuICogZXhhbXBsZSwgaWYgeW91IHVzZSBgdWludDI1NmAgYXMgYW4gaW5wdXQgdHlwZSwgdGhlIG91dHB1dCB0eXBlIHdpbGwgYmVcbiAqIGBiaWdpbnRgLiBUaGlzIGRvZXMgbm90IHdvcmsgZm9yIGFsbCB0eXBlcywgaG93ZXZlci4gRm9yIGV4YW1wbGUsIGlmIHlvdSB1c2VcbiAqIG5lc3RlZCBhcnJheSB0eXBlcyBvciB0dXBsZSB0eXBlcywgdGhlIG91dHB1dCB0eXBlIHdpbGwgYmUgYHVua25vd25gLlxuICpcbiAqIFRoZSByZXN1bHRpbmcgdHlwZXMgb2YgdGhlIHZhbHVlcyB3aWxsIGJlIGFzIGZvbGxvd3M6XG4gKlxuICogfCBDb250cmFjdCBBQkkgVHlwZSB8IFJlc3VsdGluZyBKYXZhU2NyaXB0IFR5cGUgfFxuICogfCAtLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICogfCBgYWRkcmVzc2AgICAgICAgICB8IGBzdHJpbmdgICAgICAgICAgICAgICAgICAgfFxuICogfCBgYm9vbGAgICAgICAgICAgICB8IGBib29sZWFuYCAgICAgICAgICAgICAgICAgfFxuICogfCBgYnl0ZXMobilgICAgICAgICB8IGBVaW50OEFycmF5YCAgICAgICAgICAgICAgfFxuICogfCBgZnVuY3Rpb25gICAgICAgICB8IHtAbGluayBTb2xpZGl0eUZ1bmN0aW9ufSAgfFxuICogfCBgaW50KG4pYCAgICAgICAgICB8IGBiaWdpbnRgICAgICAgICAgICAgICAgICAgfFxuICogfCBgc3RyaW5nYCAgICAgICAgICB8IGBzdHJpbmdgICAgICAgICAgICAgICAgICAgfFxuICogfCBgdHVwbGVgICAgICAgICAgICB8IGBBcnJheWAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgYXJyYXlgICAgICAgICAgICB8IGBBcnJheWAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgdWludChuKWAgICAgICAgICB8IGBiaWdpbnRgICAgICAgICAgICAgICAgICAgfFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBlbmNvZGUsIGRlY29kZSB9IGZyb20gJ0BtZXRhbWFzay9hYmktdXRpbHMnO1xuICpcbiAqIGNvbnN0IHR5cGVzID0gWyd1aW50MjU2JywgJ3N0cmluZyddO1xuICogY29uc3QgZW5jb2RlZCA9IGVuY29kZSh0eXBlcywgWzQyLCAnSGVsbG8sIHdvcmxkISddKTtcbiAqIGNvbnN0IGRlY29kZWQgPSBkZWNvZGUodHlwZXMsIGVuY29kZWQpO1xuICpcbiAqIGNvbnNvbGUubG9nKGRlY29kZWQpOyAvLyBbNDJuLCAnSGVsbG8sIHdvcmxkISddXG4gKiBgYGBcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9hYmktc3BlYy5odG1sI3R5cGVzXG4gKiBAcGFyYW0gdHlwZXMgLSBUaGUgdHlwZXMgdG8gZGVjb2RlIHRoZSBieXRlcyB3aXRoLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGJ5dGVzLWxpa2UgdmFsdWUgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgdmFsdWVzIGFzIGFycmF5LlxuICovXG5jb25zdCBkZWNvZGUgPSAodHlwZXMsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgYnl0ZXMgPSAoMCwgdXRpbHNfMS5jcmVhdGVCeXRlcykodmFsdWUpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoMCwgcGFja2VyXzEudW5wYWNrKSh0eXBlcywgYnl0ZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZXJyb3JzXzEuUGFyc2VyRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgVW5hYmxlIHRvIGRlY29kZSB2YWx1ZTogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYEFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQ6ICR7KDAsIGVycm9yc18xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IpfWAsIGVycm9yKTtcbiAgICB9XG59O1xuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKipcbiAqIERlY29kZSB0aGUgZGF0YSB3aXRoIHRoZSBwcm92aWRlZCB0eXBlLiBUaGUgdHlwZSBtdXN0IGJlIGEgdmFsaWQgU29saWRpdHlcbiAqIEFCSSB0eXBlLlxuICpcbiAqIFNlZSB7QGxpbmsgZGVjb2RlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdmFsdWVzIGFyZSBwYXJzZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGVuY29kZVNpbmdsZSwgZGVjb2RlU2luZ2xlIH0gZnJvbSAnQG1ldGFtYXNrL2FiaS11dGlscyc7XG4gKlxuICogY29uc3QgZW5jb2RlZCA9IGVuY29kZVNpbmdsZSgndWludDI1NicsIDQyKTtcbiAqIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVTaW5nbGUoJ3VpbnQyNTYnLCBlbmNvZGVkKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhkZWNvZGVkKTsgLy8gNDJuXG4gKiBgYGBcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9hYmktc3BlYy5odG1sI3R5cGVzXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBieXRlcy1saWtlIHZhbHVlIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHZhbHVlLlxuICovXG5jb25zdCBkZWNvZGVTaW5nbGUgPSAodHlwZSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSAoMCwgZXhwb3J0cy5kZWNvZGUpKFt0eXBlXSwgdmFsdWUpO1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkocmVzdWx0Lmxlbmd0aCA9PT0gMSwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKCdEZWNvZGVkIHZhbHVlIGFycmF5IGhhcyB1bmV4cGVjdGVkIGxlbmd0aC4nKSk7XG4gICAgcmV0dXJuIHJlc3VsdFswXTtcbn07XG5leHBvcnRzLmRlY29kZVNpbmdsZSA9IGRlY29kZVNpbmdsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFiaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/abi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js":
/*!*********************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/errors.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ParserError = exports.getErrorStack = exports.getErrorMessage = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs\");\n/**\n * Attempt to get an error message from a value.\n *\n * - If the value is an error, the error's message is returned.\n * - If the value is an object with a `message` property, the value of that\n * property is returned.\n * - If the value is a string, the value is returned.\n * - Otherwise, \"Unknown error.\" is returned.\n *\n * @param error - The value to get an error message from.\n * @returns The error message.\n * @internal\n */\nconst getErrorMessage = (error) => {\n    if (typeof error === 'string') {\n        return error;\n    }\n    if (error instanceof Error) {\n        return error.message;\n    }\n    if ((0, utils_1.isObject)(error) &&\n        (0, utils_1.hasProperty)(error, 'message') &&\n        typeof error.message === 'string') {\n        return error.message;\n    }\n    return 'Unknown error.';\n};\nexports.getErrorMessage = getErrorMessage;\n/**\n * Get the error stack from a value. If the value is an error, the error's stack\n * is returned. Otherwise, it returns `undefined`.\n *\n * @param error - The value to get an error stack from.\n * @returns The error stack, or `undefined` if the value is not an error.\n * @internal\n */\nconst getErrorStack = (error) => {\n    if (error instanceof Error) {\n        return error.stack;\n    }\n    return undefined;\n};\nexports.getErrorStack = getErrorStack;\n/**\n * An error that is thrown when the ABI encoder or decoder encounters an\n * issue.\n */\nclass ParserError extends Error {\n    constructor(message, originalError) {\n        super(message);\n        this.name = 'ParserError';\n        const originalStack = (0, exports.getErrorStack)(originalError);\n        if (originalStack) {\n            this.stack = originalStack;\n        }\n    }\n}\nexports.ParserError = ParserError;\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxxQkFBcUIsR0FBRyx1QkFBdUI7QUFDckUsZ0JBQWdCLG1CQUFPLENBQUMsNkdBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L2Vycm9ycy5qcz83NDYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJzZXJFcnJvciA9IGV4cG9ydHMuZ2V0RXJyb3JTdGFjayA9IGV4cG9ydHMuZ2V0RXJyb3JNZXNzYWdlID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG4vKipcbiAqIEF0dGVtcHQgdG8gZ2V0IGFuIGVycm9yIG1lc3NhZ2UgZnJvbSBhIHZhbHVlLlxuICpcbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGFuIGVycm9yLCB0aGUgZXJyb3IncyBtZXNzYWdlIGlzIHJldHVybmVkLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYSBgbWVzc2FnZWAgcHJvcGVydHksIHRoZSB2YWx1ZSBvZiB0aGF0XG4gKiBwcm9wZXJ0eSBpcyByZXR1cm5lZC5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCB0aGUgdmFsdWUgaXMgcmV0dXJuZWQuXG4gKiAtIE90aGVyd2lzZSwgXCJVbmtub3duIGVycm9yLlwiIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSB2YWx1ZSB0byBnZXQgYW4gZXJyb3IgbWVzc2FnZSBmcm9tLlxuICogQHJldHVybnMgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgZ2V0RXJyb3JNZXNzYWdlID0gKGVycm9yKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzT2JqZWN0KShlcnJvcikgJiZcbiAgICAgICAgKDAsIHV0aWxzXzEuaGFzUHJvcGVydHkpKGVycm9yLCAnbWVzc2FnZScpICYmXG4gICAgICAgIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuICdVbmtub3duIGVycm9yLic7XG59O1xuZXhwb3J0cy5nZXRFcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2U7XG4vKipcbiAqIEdldCB0aGUgZXJyb3Igc3RhY2sgZnJvbSBhIHZhbHVlLiBJZiB0aGUgdmFsdWUgaXMgYW4gZXJyb3IsIHRoZSBlcnJvcidzIHN0YWNrXG4gKiBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLCBpdCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSB2YWx1ZSB0byBnZXQgYW4gZXJyb3Igc3RhY2sgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBlcnJvciBzdGFjaywgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHZhbHVlIGlzIG5vdCBhbiBlcnJvci5cbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBnZXRFcnJvclN0YWNrID0gKGVycm9yKSA9PiB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLnN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmV4cG9ydHMuZ2V0RXJyb3JTdGFjayA9IGdldEVycm9yU3RhY2s7XG4vKipcbiAqIEFuIGVycm9yIHRoYXQgaXMgdGhyb3duIHdoZW4gdGhlIEFCSSBlbmNvZGVyIG9yIGRlY29kZXIgZW5jb3VudGVycyBhblxuICogaXNzdWUuXG4gKi9cbmNsYXNzIFBhcnNlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdQYXJzZXJFcnJvcic7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU3RhY2sgPSAoMCwgZXhwb3J0cy5nZXRFcnJvclN0YWNrKShvcmlnaW5hbEVycm9yKTtcbiAgICAgICAgaWYgKG9yaWdpbmFsU3RhY2spIHtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBvcmlnaW5hbFN0YWNrO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5QYXJzZXJFcnJvciA9IFBhcnNlckVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./abi */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/abi.js\"), exports);\n__exportStar(__webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/types/index.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxtRUFBTztBQUM1QixhQUFhLG1CQUFPLENBQUMseUVBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLDZFQUFTO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9pbmRleC5qcz81ZjljIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWJpXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lcnJvcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/iterator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.iterate = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs\");\n/**\n * Iterate over a buffer with the specified size. This will yield a part of the\n * buffer starting at an increment of the specified size, until the end of the\n * buffer is reached.\n *\n * Calling the `skip` function will make it skip the specified number of bytes.\n *\n * @param buffer - The buffer to iterate over.\n * @param size - The number of bytes to iterate with.\n * @returns An iterator that yields the parts of the byte array.\n * @yields The parts of the byte array.\n */\nconst iterate = function* (buffer, size = 32) {\n    for (let pointer = 0; pointer < buffer.length; pointer += size) {\n        const skip = (length) => {\n            (0, utils_1.assert)(length >= 0, 'Cannot skip a negative number of bytes.');\n            (0, utils_1.assert)(length % size === 0, 'Length must be a multiple of the size.');\n            pointer += length;\n        };\n        const value = buffer.subarray(pointer);\n        yield { skip, value };\n    }\n    return {\n        skip: () => undefined,\n        value: new Uint8Array(),\n    };\n};\nexports.iterate = iterate;\n//# sourceMappingURL=iterator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L2l0ZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixnQkFBZ0IsbUJBQU8sQ0FBQyw2R0FBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L2l0ZXJhdG9yLmpzPzA5MDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLml0ZXJhdGUgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbi8qKlxuICogSXRlcmF0ZSBvdmVyIGEgYnVmZmVyIHdpdGggdGhlIHNwZWNpZmllZCBzaXplLiBUaGlzIHdpbGwgeWllbGQgYSBwYXJ0IG9mIHRoZVxuICogYnVmZmVyIHN0YXJ0aW5nIGF0IGFuIGluY3JlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHNpemUsIHVudGlsIHRoZSBlbmQgb2YgdGhlXG4gKiBidWZmZXIgaXMgcmVhY2hlZC5cbiAqXG4gKiBDYWxsaW5nIHRoZSBgc2tpcGAgZnVuY3Rpb24gd2lsbCBtYWtlIGl0IHNraXAgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIGJ1ZmZlciAtIFRoZSBidWZmZXIgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHNpemUgLSBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGl0ZXJhdGUgd2l0aC5cbiAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIHRoYXQgeWllbGRzIHRoZSBwYXJ0cyBvZiB0aGUgYnl0ZSBhcnJheS5cbiAqIEB5aWVsZHMgVGhlIHBhcnRzIG9mIHRoZSBieXRlIGFycmF5LlxuICovXG5jb25zdCBpdGVyYXRlID0gZnVuY3Rpb24qIChidWZmZXIsIHNpemUgPSAzMikge1xuICAgIGZvciAobGV0IHBvaW50ZXIgPSAwOyBwb2ludGVyIDwgYnVmZmVyLmxlbmd0aDsgcG9pbnRlciArPSBzaXplKSB7XG4gICAgICAgIGNvbnN0IHNraXAgPSAobGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKGxlbmd0aCA+PSAwLCAnQ2Fubm90IHNraXAgYSBuZWdhdGl2ZSBudW1iZXIgb2YgYnl0ZXMuJyk7XG4gICAgICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKGxlbmd0aCAlIHNpemUgPT09IDAsICdMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIHRoZSBzaXplLicpO1xuICAgICAgICAgICAgcG9pbnRlciArPSBsZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYnVmZmVyLnN1YmFycmF5KHBvaW50ZXIpO1xuICAgICAgICB5aWVsZCB7IHNraXAsIHZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNraXA6ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsdWU6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfTtcbn07XG5leHBvcnRzLml0ZXJhdGUgPSBpdGVyYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlcmF0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/iterator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/packer.js":
/*!*********************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/packer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unpack = exports.pack = exports.isDynamicParser = exports.getParser = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst iterator_1 = __webpack_require__(/*! ./iterator */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/iterator.js\");\nconst parsers_1 = __webpack_require__(/*! ./parsers */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/index.js\");\nconst utils_2 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js\");\n/**\n * Get the parser for the specified type.\n *\n * @param type - The type to get a parser for.\n * @returns The parser.\n * @throws If there is no parser for the specified type.\n */\nconst getParser = (type) => {\n    const parsers = {\n        address: parsers_1.address,\n        array: parsers_1.array,\n        bool: parsers_1.bool,\n        bytes: parsers_1.bytes,\n        fixedBytes: parsers_1.fixedBytes,\n        function: parsers_1.fn,\n        number: parsers_1.number,\n        string: parsers_1.string,\n        tuple: parsers_1.tuple,\n    };\n    const staticParser = parsers[type];\n    if (staticParser) {\n        return staticParser;\n    }\n    const parser = Object.values(parsers).find((value) => value.isType(type));\n    if (parser) {\n        return parser;\n    }\n    throw new errors_1.ParserError(`The type \"${type}\" is not supported.`);\n};\nexports.getParser = getParser;\n/**\n * Check if the specified parser is dynamic, for the provided types. This is\n * primarily used for parsing tuples, where a tuple can be dynamic based on the\n * types. For other parsers, it will simply use the set `isDynamic` value.\n *\n * @param parser - The parser to check.\n * @param type - The type to check the parser with.\n * @returns Whether the parser is dynamic.\n */\nconst isDynamicParser = (parser, type) => {\n    const { isDynamic } = parser;\n    if (typeof isDynamic === 'function') {\n        return isDynamic(type);\n    }\n    return isDynamic;\n};\nexports.isDynamicParser = isDynamicParser;\n/**\n * Pack the provided values in a buffer, encoded with the specified types. If a\n * buffer is specified, the resulting value will be concatenated with the\n * buffer.\n *\n * @param args - The arguments object.\n * @param args.types - The types of the values to pack.\n * @param args.values - The values to pack.\n * @param args.packed - Whether to use the non-standard packed mode. Defaults to\n * `false`.\n * @param args.arrayPacked - Whether to use the non-standard packed mode for\n * arrays. Defaults to `false`.\n * @param args.byteArray - The byte array to encode the values into. Defaults to\n * an empty array.\n * @param args.tight - Whether to use tight packing mode. Only applicable when\n * `packed` is true. When true, the packed mode will not add any padding bytes.\n * This matches the packing behaviour of `ethereumjs-abi`, but is not standard.\n * @returns The resulting encoded buffer.\n */\nconst pack = ({ types, values, packed = false, tight = false, arrayPacked = false, byteArray = new Uint8Array(), }) => {\n    (0, utils_1.assert)(types.length === values.length, new errors_1.ParserError(`The number of types (${types.length}) does not match the number of values (${values.length}).`));\n    const { staticBuffer, dynamicBuffer, pointers } = types.reduce(\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    ({ staticBuffer, dynamicBuffer, pointers }, type, index) => {\n        const parser = (0, exports.getParser)(type);\n        const value = values[index];\n        // If packed mode is enabled, we can skip the dynamic check, as all\n        // values are encoded in the static buffer.\n        if (packed || arrayPacked || !(0, exports.isDynamicParser)(parser, type)) {\n            return {\n                staticBuffer: parser.encode({\n                    buffer: staticBuffer,\n                    value,\n                    type,\n                    packed,\n                    tight,\n                }),\n                dynamicBuffer,\n                pointers,\n            };\n        }\n        const newStaticBuffer = (0, utils_1.concatBytes)([staticBuffer, new Uint8Array(32)]);\n        const newDynamicBuffer = parser.encode({\n            buffer: dynamicBuffer,\n            value,\n            type,\n            packed,\n            tight,\n        });\n        return {\n            staticBuffer: newStaticBuffer,\n            dynamicBuffer: newDynamicBuffer,\n            pointers: [\n                ...pointers,\n                { position: staticBuffer.length, pointer: dynamicBuffer.length },\n            ],\n        };\n    }, {\n        staticBuffer: new Uint8Array(),\n        dynamicBuffer: new Uint8Array(),\n        pointers: [],\n    });\n    // If packed mode is enabled, there shouldn't be any dynamic values.\n    (0, utils_1.assert)((!packed && !arrayPacked) || dynamicBuffer.length === 0, new errors_1.ParserError('Invalid pack state.'));\n    const dynamicStart = staticBuffer.length;\n    const updatedBuffer = pointers.reduce((target, { pointer, position }) => {\n        const offset = (0, utils_2.padStart)((0, utils_1.numberToBytes)(dynamicStart + pointer));\n        return (0, utils_2.set)(target, offset, position);\n    }, staticBuffer);\n    return (0, utils_1.concatBytes)([byteArray, updatedBuffer, dynamicBuffer]);\n};\nexports.pack = pack;\nconst unpack = (types, buffer) => {\n    const iterator = (0, iterator_1.iterate)(buffer);\n    return types.map((type) => {\n        const { value: { value, skip }, done, } = iterator.next();\n        (0, utils_1.assert)(!done, new errors_1.ParserError(`The encoded value is invalid for the provided types. Reached end of buffer while attempting to parse \"${type}\".`));\n        const parser = (0, exports.getParser)(type);\n        const isDynamic = (0, exports.isDynamicParser)(parser, type);\n        if (isDynamic) {\n            const pointer = (0, utils_1.bytesToNumber)(value.subarray(0, 32));\n            const target = buffer.subarray(pointer);\n            return parser.decode({ type, value: target, skip });\n        }\n        return parser.decode({ type, value, skip });\n    });\n};\nexports.unpack = unpack;\n//# sourceMappingURL=packer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhY2tlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsWUFBWSxHQUFHLHVCQUF1QixHQUFHLGlCQUFpQjtBQUMzRSxnQkFBZ0IsbUJBQU8sQ0FBQyw2R0FBaUI7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMseUVBQVU7QUFDbkMsbUJBQW1CLG1CQUFPLENBQUMsNkVBQVk7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMsaUZBQVc7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsNkVBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrR0FBa0c7QUFDbEgseUdBQXlHLGFBQWEseUNBQXlDLGNBQWM7QUFDN0ssWUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQSxPQUFPLHVDQUF1QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhEQUE4RDtBQUNoRjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsbUJBQW1CO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUyxhQUFhLFVBQVU7QUFDaEQscUtBQXFLLEtBQUs7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQkFBMkI7QUFDOUQ7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xELEtBQUs7QUFDTDtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvcGFja2VyLmpzPzg4ODIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVucGFjayA9IGV4cG9ydHMucGFjayA9IGV4cG9ydHMuaXNEeW5hbWljUGFyc2VyID0gZXhwb3J0cy5nZXRQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgaXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL2l0ZXJhdG9yXCIpO1xuY29uc3QgcGFyc2Vyc18xID0gcmVxdWlyZShcIi4vcGFyc2Vyc1wiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogR2V0IHRoZSBwYXJzZXIgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGdldCBhIHBhcnNlciBmb3IuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VyLlxuICogQHRocm93cyBJZiB0aGVyZSBpcyBubyBwYXJzZXIgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAqL1xuY29uc3QgZ2V0UGFyc2VyID0gKHR5cGUpID0+IHtcbiAgICBjb25zdCBwYXJzZXJzID0ge1xuICAgICAgICBhZGRyZXNzOiBwYXJzZXJzXzEuYWRkcmVzcyxcbiAgICAgICAgYXJyYXk6IHBhcnNlcnNfMS5hcnJheSxcbiAgICAgICAgYm9vbDogcGFyc2Vyc18xLmJvb2wsXG4gICAgICAgIGJ5dGVzOiBwYXJzZXJzXzEuYnl0ZXMsXG4gICAgICAgIGZpeGVkQnl0ZXM6IHBhcnNlcnNfMS5maXhlZEJ5dGVzLFxuICAgICAgICBmdW5jdGlvbjogcGFyc2Vyc18xLmZuLFxuICAgICAgICBudW1iZXI6IHBhcnNlcnNfMS5udW1iZXIsXG4gICAgICAgIHN0cmluZzogcGFyc2Vyc18xLnN0cmluZyxcbiAgICAgICAgdHVwbGU6IHBhcnNlcnNfMS50dXBsZSxcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY1BhcnNlciA9IHBhcnNlcnNbdHlwZV07XG4gICAgaWYgKHN0YXRpY1BhcnNlcikge1xuICAgICAgICByZXR1cm4gc3RhdGljUGFyc2VyO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZXIgPSBPYmplY3QudmFsdWVzKHBhcnNlcnMpLmZpbmQoKHZhbHVlKSA9PiB2YWx1ZS5pc1R5cGUodHlwZSkpO1xuICAgIGlmIChwYXJzZXIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBUaGUgdHlwZSBcIiR7dHlwZX1cIiBpcyBub3Qgc3VwcG9ydGVkLmApO1xufTtcbmV4cG9ydHMuZ2V0UGFyc2VyID0gZ2V0UGFyc2VyO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgc3BlY2lmaWVkIHBhcnNlciBpcyBkeW5hbWljLCBmb3IgdGhlIHByb3ZpZGVkIHR5cGVzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZCBmb3IgcGFyc2luZyB0dXBsZXMsIHdoZXJlIGEgdHVwbGUgY2FuIGJlIGR5bmFtaWMgYmFzZWQgb24gdGhlXG4gKiB0eXBlcy4gRm9yIG90aGVyIHBhcnNlcnMsIGl0IHdpbGwgc2ltcGx5IHVzZSB0aGUgc2V0IGBpc0R5bmFtaWNgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBwYXJzZXIgLSBUaGUgcGFyc2VyIHRvIGNoZWNrLlxuICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBjaGVjayB0aGUgcGFyc2VyIHdpdGguXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBwYXJzZXIgaXMgZHluYW1pYy5cbiAqL1xuY29uc3QgaXNEeW5hbWljUGFyc2VyID0gKHBhcnNlciwgdHlwZSkgPT4ge1xuICAgIGNvbnN0IHsgaXNEeW5hbWljIH0gPSBwYXJzZXI7XG4gICAgaWYgKHR5cGVvZiBpc0R5bmFtaWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlzRHluYW1pYyh0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRHluYW1pYztcbn07XG5leHBvcnRzLmlzRHluYW1pY1BhcnNlciA9IGlzRHluYW1pY1BhcnNlcjtcbi8qKlxuICogUGFjayB0aGUgcHJvdmlkZWQgdmFsdWVzIGluIGEgYnVmZmVyLCBlbmNvZGVkIHdpdGggdGhlIHNwZWNpZmllZCB0eXBlcy4gSWYgYVxuICogYnVmZmVyIGlzIHNwZWNpZmllZCwgdGhlIHJlc3VsdGluZyB2YWx1ZSB3aWxsIGJlIGNvbmNhdGVuYXRlZCB3aXRoIHRoZVxuICogYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBvYmplY3QuXG4gKiBAcGFyYW0gYXJncy50eXBlcyAtIFRoZSB0eXBlcyBvZiB0aGUgdmFsdWVzIHRvIHBhY2suXG4gKiBAcGFyYW0gYXJncy52YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIHBhY2suXG4gKiBAcGFyYW0gYXJncy5wYWNrZWQgLSBXaGV0aGVyIHRvIHVzZSB0aGUgbm9uLXN0YW5kYXJkIHBhY2tlZCBtb2RlLiBEZWZhdWx0cyB0b1xuICogYGZhbHNlYC5cbiAqIEBwYXJhbSBhcmdzLmFycmF5UGFja2VkIC0gV2hldGhlciB0byB1c2UgdGhlIG5vbi1zdGFuZGFyZCBwYWNrZWQgbW9kZSBmb3JcbiAqIGFycmF5cy4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqIEBwYXJhbSBhcmdzLmJ5dGVBcnJheSAtIFRoZSBieXRlIGFycmF5IHRvIGVuY29kZSB0aGUgdmFsdWVzIGludG8uIERlZmF1bHRzIHRvXG4gKiBhbiBlbXB0eSBhcnJheS5cbiAqIEBwYXJhbSBhcmdzLnRpZ2h0IC0gV2hldGhlciB0byB1c2UgdGlnaHQgcGFja2luZyBtb2RlLiBPbmx5IGFwcGxpY2FibGUgd2hlblxuICogYHBhY2tlZGAgaXMgdHJ1ZS4gV2hlbiB0cnVlLCB0aGUgcGFja2VkIG1vZGUgd2lsbCBub3QgYWRkIGFueSBwYWRkaW5nIGJ5dGVzLlxuICogVGhpcyBtYXRjaGVzIHRoZSBwYWNraW5nIGJlaGF2aW91ciBvZiBgZXRoZXJldW1qcy1hYmlgLCBidXQgaXMgbm90IHN0YW5kYXJkLlxuICogQHJldHVybnMgVGhlIHJlc3VsdGluZyBlbmNvZGVkIGJ1ZmZlci5cbiAqL1xuY29uc3QgcGFjayA9ICh7IHR5cGVzLCB2YWx1ZXMsIHBhY2tlZCA9IGZhbHNlLCB0aWdodCA9IGZhbHNlLCBhcnJheVBhY2tlZCA9IGZhbHNlLCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheSgpLCB9KSA9PiB7XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KSh0eXBlcy5sZW5ndGggPT09IHZhbHVlcy5sZW5ndGgsIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgVGhlIG51bWJlciBvZiB0eXBlcyAoJHt0eXBlcy5sZW5ndGh9KSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIHZhbHVlcyAoJHt2YWx1ZXMubGVuZ3RofSkuYCkpO1xuICAgIGNvbnN0IHsgc3RhdGljQnVmZmVyLCBkeW5hbWljQnVmZmVyLCBwb2ludGVycyB9ID0gdHlwZXMucmVkdWNlKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gICAgKHsgc3RhdGljQnVmZmVyLCBkeW5hbWljQnVmZmVyLCBwb2ludGVycyB9LCB0eXBlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJzZXIgPSAoMCwgZXhwb3J0cy5nZXRQYXJzZXIpKHR5cGUpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIC8vIElmIHBhY2tlZCBtb2RlIGlzIGVuYWJsZWQsIHdlIGNhbiBza2lwIHRoZSBkeW5hbWljIGNoZWNrLCBhcyBhbGxcbiAgICAgICAgLy8gdmFsdWVzIGFyZSBlbmNvZGVkIGluIHRoZSBzdGF0aWMgYnVmZmVyLlxuICAgICAgICBpZiAocGFja2VkIHx8IGFycmF5UGFja2VkIHx8ICEoMCwgZXhwb3J0cy5pc0R5bmFtaWNQYXJzZXIpKHBhcnNlciwgdHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGljQnVmZmVyOiBwYXJzZXIuZW5jb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBzdGF0aWNCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBwYWNrZWQsXG4gICAgICAgICAgICAgICAgICAgIHRpZ2h0LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNCdWZmZXIsXG4gICAgICAgICAgICAgICAgcG9pbnRlcnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1N0YXRpY0J1ZmZlciA9ICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbc3RhdGljQnVmZmVyLCBuZXcgVWludDhBcnJheSgzMildKTtcbiAgICAgICAgY29uc3QgbmV3RHluYW1pY0J1ZmZlciA9IHBhcnNlci5lbmNvZGUoe1xuICAgICAgICAgICAgYnVmZmVyOiBkeW5hbWljQnVmZmVyLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcGFja2VkLFxuICAgICAgICAgICAgdGlnaHQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdGljQnVmZmVyOiBuZXdTdGF0aWNCdWZmZXIsXG4gICAgICAgICAgICBkeW5hbWljQnVmZmVyOiBuZXdEeW5hbWljQnVmZmVyLFxuICAgICAgICAgICAgcG9pbnRlcnM6IFtcbiAgICAgICAgICAgICAgICAuLi5wb2ludGVycyxcbiAgICAgICAgICAgICAgICB7IHBvc2l0aW9uOiBzdGF0aWNCdWZmZXIubGVuZ3RoLCBwb2ludGVyOiBkeW5hbWljQnVmZmVyLmxlbmd0aCB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9LCB7XG4gICAgICAgIHN0YXRpY0J1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgZHluYW1pY0J1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgcG9pbnRlcnM6IFtdLFxuICAgIH0pO1xuICAgIC8vIElmIHBhY2tlZCBtb2RlIGlzIGVuYWJsZWQsIHRoZXJlIHNob3VsZG4ndCBiZSBhbnkgZHluYW1pYyB2YWx1ZXMuXG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KSgoIXBhY2tlZCAmJiAhYXJyYXlQYWNrZWQpIHx8IGR5bmFtaWNCdWZmZXIubGVuZ3RoID09PSAwLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoJ0ludmFsaWQgcGFjayBzdGF0ZS4nKSk7XG4gICAgY29uc3QgZHluYW1pY1N0YXJ0ID0gc3RhdGljQnVmZmVyLmxlbmd0aDtcbiAgICBjb25zdCB1cGRhdGVkQnVmZmVyID0gcG9pbnRlcnMucmVkdWNlKCh0YXJnZXQsIHsgcG9pbnRlciwgcG9zaXRpb24gfSkgPT4ge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoMCwgdXRpbHNfMi5wYWRTdGFydCkoKDAsIHV0aWxzXzEubnVtYmVyVG9CeXRlcykoZHluYW1pY1N0YXJ0ICsgcG9pbnRlcikpO1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzIuc2V0KSh0YXJnZXQsIG9mZnNldCwgcG9zaXRpb24pO1xuICAgIH0sIHN0YXRpY0J1ZmZlcik7XG4gICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbYnl0ZUFycmF5LCB1cGRhdGVkQnVmZmVyLCBkeW5hbWljQnVmZmVyXSk7XG59O1xuZXhwb3J0cy5wYWNrID0gcGFjaztcbmNvbnN0IHVucGFjayA9ICh0eXBlcywgYnVmZmVyKSA9PiB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSAoMCwgaXRlcmF0b3JfMS5pdGVyYXRlKShidWZmZXIpO1xuICAgIHJldHVybiB0eXBlcy5tYXAoKHR5cGUpID0+IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZTogeyB2YWx1ZSwgc2tpcCB9LCBkb25lLCB9ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKCFkb25lLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYFRoZSBlbmNvZGVkIHZhbHVlIGlzIGludmFsaWQgZm9yIHRoZSBwcm92aWRlZCB0eXBlcy4gUmVhY2hlZCBlbmQgb2YgYnVmZmVyIHdoaWxlIGF0dGVtcHRpbmcgdG8gcGFyc2UgXCIke3R5cGV9XCIuYCkpO1xuICAgICAgICBjb25zdCBwYXJzZXIgPSAoMCwgZXhwb3J0cy5nZXRQYXJzZXIpKHR5cGUpO1xuICAgICAgICBjb25zdCBpc0R5bmFtaWMgPSAoMCwgZXhwb3J0cy5pc0R5bmFtaWNQYXJzZXIpKHBhcnNlciwgdHlwZSk7XG4gICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXIgPSAoMCwgdXRpbHNfMS5ieXRlc1RvTnVtYmVyKSh2YWx1ZS5zdWJhcnJheSgwLCAzMikpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gYnVmZmVyLnN1YmFycmF5KHBvaW50ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5kZWNvZGUoeyB0eXBlLCB2YWx1ZTogdGFyZ2V0LCBza2lwIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZXIuZGVjb2RlKHsgdHlwZSwgdmFsdWUsIHNraXAgfSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy51bnBhY2sgPSB1bnBhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWNrZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/packer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/address.js":
/*!******************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/address.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.address = exports.getAddress = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst utils_2 = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js\");\n/**\n * Normalize an address value. This accepts the address as:\n *\n * - A hex string starting with the `0x` prefix.\n * - A byte array (`Uint8Array` or `Buffer`).\n *\n * It checks that the address is 20 bytes long.\n *\n * @param value - The value to normalize.\n * @returns The normalized address as `Uint8Array`.\n */\nconst getAddress = (value) => {\n    const bytesValue = (0, utils_1.createBytes)(value);\n    (0, utils_1.assert)(bytesValue.length <= 20, new errors_1.ParserError(`Invalid address value. Expected address to be 20 bytes long, but received ${bytesValue.length} bytes.`));\n    return (0, utils_2.padStart)(bytesValue, 20);\n};\nexports.getAddress = getAddress;\nexports.address = {\n    isDynamic: false,\n    /**\n     * Get if the given value is a valid address type. Since `address` is a simple\n     * type, this is just a check that the value is \"address\".\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a valid address type.\n     */\n    isType: (type) => type === 'address',\n    /**\n     * Get the byte length of an encoded address. Since `address` is a simple\n     * type, this always returns 32.\n     *\n     * Note that actual addresses are only 20 bytes long, but the encoding of\n     * the `address` type is always 32 bytes long.\n     *\n     * @returns The byte length of an encoded address.\n     */\n    getByteLength() {\n        return 32;\n    },\n    /**\n     * Encode the given address to a 32-byte-long byte array.\n     *\n     * @param args - The encoding arguments.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The address to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @returns The bytes with the encoded address added to it.\n     */\n    encode({ buffer, value, packed }) {\n        const addressValue = (0, exports.getAddress)(value);\n        // If we're using packed encoding, we can just add the address bytes to the\n        // byte array, without adding any padding.\n        if (packed) {\n            return (0, utils_1.concatBytes)([buffer, addressValue]);\n        }\n        const addressBuffer = (0, utils_2.padStart)(addressValue);\n        return (0, utils_1.concatBytes)([buffer, addressBuffer]);\n    },\n    /**\n     * Decode the given byte array to an address.\n     *\n     * @param args - The decoding arguments.\n     * @param args.value - The byte array to decode.\n     * @returns The decoded address as a hexadecimal string, starting with the\n     * \"0x\"-prefix.\n     */\n    decode({ value }) {\n        return (0, utils_1.add0x)((0, utils_1.bytesToHex)(value.slice(12, 32)));\n    },\n};\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsa0JBQWtCO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLDZHQUFpQjtBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBVztBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVKQUF1SixtQkFBbUI7QUFDMUs7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvcGFyc2Vycy9hZGRyZXNzLmpzP2NjNGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZHJlc3MgPSBleHBvcnRzLmdldEFkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG4vKipcbiAqIE5vcm1hbGl6ZSBhbiBhZGRyZXNzIHZhbHVlLiBUaGlzIGFjY2VwdHMgdGhlIGFkZHJlc3MgYXM6XG4gKlxuICogLSBBIGhleCBzdHJpbmcgc3RhcnRpbmcgd2l0aCB0aGUgYDB4YCBwcmVmaXguXG4gKiAtIEEgYnl0ZSBhcnJheSAoYFVpbnQ4QXJyYXlgIG9yIGBCdWZmZXJgKS5cbiAqXG4gKiBJdCBjaGVja3MgdGhhdCB0aGUgYWRkcmVzcyBpcyAyMCBieXRlcyBsb25nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBub3JtYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCBhZGRyZXNzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuY29uc3QgZ2V0QWRkcmVzcyA9ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGJ5dGVzVmFsdWUgPSAoMCwgdXRpbHNfMS5jcmVhdGVCeXRlcykodmFsdWUpO1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkoYnl0ZXNWYWx1ZS5sZW5ndGggPD0gMjAsIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCBhZGRyZXNzIHZhbHVlLiBFeHBlY3RlZCBhZGRyZXNzIHRvIGJlIDIwIGJ5dGVzIGxvbmcsIGJ1dCByZWNlaXZlZCAke2J5dGVzVmFsdWUubGVuZ3RofSBieXRlcy5gKSk7XG4gICAgcmV0dXJuICgwLCB1dGlsc18yLnBhZFN0YXJ0KShieXRlc1ZhbHVlLCAyMCk7XG59O1xuZXhwb3J0cy5nZXRBZGRyZXNzID0gZ2V0QWRkcmVzcztcbmV4cG9ydHMuYWRkcmVzcyA9IHtcbiAgICBpc0R5bmFtaWM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEdldCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCBhZGRyZXNzIHR5cGUuIFNpbmNlIGBhZGRyZXNzYCBpcyBhIHNpbXBsZVxuICAgICAqIHR5cGUsIHRoaXMgaXMganVzdCBhIGNoZWNrIHRoYXQgdGhlIHZhbHVlIGlzIFwiYWRkcmVzc1wiLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0eXBlIGlzIGEgdmFsaWQgYWRkcmVzcyB0eXBlLlxuICAgICAqL1xuICAgIGlzVHlwZTogKHR5cGUpID0+IHR5cGUgPT09ICdhZGRyZXNzJyxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIGVuY29kZWQgYWRkcmVzcy4gU2luY2UgYGFkZHJlc3NgIGlzIGEgc2ltcGxlXG4gICAgICogdHlwZSwgdGhpcyBhbHdheXMgcmV0dXJucyAzMi5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBhY3R1YWwgYWRkcmVzc2VzIGFyZSBvbmx5IDIwIGJ5dGVzIGxvbmcsIGJ1dCB0aGUgZW5jb2Rpbmcgb2ZcbiAgICAgKiB0aGUgYGFkZHJlc3NgIHR5cGUgaXMgYWx3YXlzIDMyIGJ5dGVzIGxvbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYnl0ZSBsZW5ndGggb2YgYW4gZW5jb2RlZCBhZGRyZXNzLlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiAzMjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUgZ2l2ZW4gYWRkcmVzcyB0byBhIDMyLWJ5dGUtbG9uZyBieXRlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZW5jb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLmJ1ZmZlciAtIFRoZSBieXRlIGFycmF5IHRvIGFkZCB0by5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSBhZGRyZXNzIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gYXJncy5wYWNrZWQgLSBXaGV0aGVyIHRvIHVzZSBwYWNrZWQgZW5jb2RpbmcuXG4gICAgICogQHJldHVybnMgVGhlIGJ5dGVzIHdpdGggdGhlIGVuY29kZWQgYWRkcmVzcyBhZGRlZCB0byBpdC5cbiAgICAgKi9cbiAgICBlbmNvZGUoeyBidWZmZXIsIHZhbHVlLCBwYWNrZWQgfSkge1xuICAgICAgICBjb25zdCBhZGRyZXNzVmFsdWUgPSAoMCwgZXhwb3J0cy5nZXRBZGRyZXNzKSh2YWx1ZSk7XG4gICAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIHBhY2tlZCBlbmNvZGluZywgd2UgY2FuIGp1c3QgYWRkIHRoZSBhZGRyZXNzIGJ5dGVzIHRvIHRoZVxuICAgICAgICAvLyBieXRlIGFycmF5LCB3aXRob3V0IGFkZGluZyBhbnkgcGFkZGluZy5cbiAgICAgICAgaWYgKHBhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbYnVmZmVyLCBhZGRyZXNzVmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzQnVmZmVyID0gKDAsIHV0aWxzXzIucGFkU3RhcnQpKGFkZHJlc3NWYWx1ZSk7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW2J1ZmZlciwgYWRkcmVzc0J1ZmZlcl0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVjb2RlIHRoZSBnaXZlbiBieXRlIGFycmF5IHRvIGFuIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBkZWNvZGluZyBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIGFyZ3MudmFsdWUgLSBUaGUgYnl0ZSBhcnJheSB0byBkZWNvZGUuXG4gICAgICogQHJldHVybnMgVGhlIGRlY29kZWQgYWRkcmVzcyBhcyBhIGhleGFkZWNpbWFsIHN0cmluZywgc3RhcnRpbmcgd2l0aCB0aGVcbiAgICAgKiBcIjB4XCItcHJlZml4LlxuICAgICAqL1xuICAgIGRlY29kZSh7IHZhbHVlIH0pIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmFkZDB4KSgoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KSh2YWx1ZS5zbGljZSgxMiwgMzIpKSk7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/array.js":
/*!****************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/array.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.array = exports.getTupleType = exports.getArrayType = exports.isArrayType = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst packer_1 = __webpack_require__(/*! ../packer */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/packer.js\");\nconst utils_2 = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js\");\nconst fixed_bytes_1 = __webpack_require__(/*! ./fixed-bytes */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js\");\nconst tuple_1 = __webpack_require__(/*! ./tuple */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/tuple.js\");\nconst ARRAY_REGEX = /^(?<type>.*)\\[(?<length>\\d*?)\\]$/u;\nconst isArrayType = (type) => ARRAY_REGEX.test(type);\nexports.isArrayType = isArrayType;\n/**\n * Get the type of the array.\n *\n * @param type - The type to get the array type for.\n * @returns The array type.\n */\nconst getArrayType = (type) => {\n    const match = type.match(ARRAY_REGEX);\n    (0, utils_1.assert)(match?.groups?.type, new errors_1.ParserError(`Invalid array type. Expected an array type, but received \"${type}\".`));\n    return [\n        match.groups.type,\n        match.groups.length ? parseInt(match.groups.length, 10) : undefined,\n    ];\n};\nexports.getArrayType = getArrayType;\n/**\n * Get the type of the array as a tuple type. This is used for encoding fixed\n * length arrays, which are encoded as tuples.\n *\n * @param innerType - The type of the array.\n * @param length - The length of the array.\n * @returns The tuple type.\n */\nconst getTupleType = (innerType, length) => {\n    return `(${new Array(length).fill(innerType).join(',')})`;\n};\nexports.getTupleType = getTupleType;\nexports.array = {\n    /**\n     * Check if the array is dynamic. Arrays are dynamic if the array does not\n     * have a fixed length, or if the array type is dynamic.\n     *\n     * @param type - The type to check.\n     * @returns Whether the array is dynamic.\n     */\n    isDynamic(type) {\n        const [innerType, length] = (0, exports.getArrayType)(type);\n        return (\n        // `T[]` is dynamic for any `T`. `T[k]` is dynamic for any dynamic `T` and\n        // any `k >= 0`.\n        length === undefined || (0, packer_1.isDynamicParser)((0, packer_1.getParser)(innerType), innerType));\n    },\n    /**\n     * Check if a type is an array type.\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is an array type.\n     */\n    isType(type) {\n        return (0, exports.isArrayType)(type);\n    },\n    /**\n     * Get the byte length of an encoded array. If the array is dynamic, this\n     * returns 32, i.e., the length of the pointer to the array. If the array is\n     * static, this returns the byte length of the resulting tuple type.\n     *\n     * @param type - The type to get the byte length for.\n     * @returns The byte length of an encoded array.\n     */\n    getByteLength(type) {\n        (0, utils_1.assert)((0, exports.isArrayType)(type), new errors_1.ParserError(`Expected an array type, but received \"${type}\".`));\n        const [innerType, length] = (0, exports.getArrayType)(type);\n        if (!(0, packer_1.isDynamicParser)(this, type) && length !== undefined) {\n            return tuple_1.tuple.getByteLength((0, exports.getTupleType)(innerType, length));\n        }\n        return 32;\n    },\n    /**\n     * Encode the given array to a byte array. If the array is static, this uses\n     * the tuple encoder.\n     *\n     * @param args - The encoding arguments.\n     * @param args.type - The type of the array.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The array to encode.\n     * @param args.packed - Whether to use non-standard packed encoding.\n     * @param args.tight - Whether to use non-standard tight encoding.\n     * @returns The bytes with the encoded array added to it.\n     */\n    encode({ type, buffer, value, packed, tight }) {\n        const [arrayType, fixedLength] = (0, exports.getArrayType)(type);\n        // Packed encoding does not support nested arrays.\n        (0, utils_1.assert)(!packed || !(0, exports.isArrayType)(arrayType), new errors_1.ParserError(`Cannot pack nested arrays.`));\n        // Tightly pack `T[]` where `T` is a dynamic type. This is not supported in\n        // Solidity, but is commonly used in the Ethereum ecosystem.\n        if (packed && (0, packer_1.isDynamicParser)((0, packer_1.getParser)(arrayType), arrayType)) {\n            return (0, packer_1.pack)({\n                types: new Array(value.length).fill(arrayType),\n                values: value,\n                byteArray: buffer,\n                packed,\n                arrayPacked: true,\n                tight,\n            });\n        }\n        if (fixedLength) {\n            (0, utils_1.assert)(fixedLength === value.length, new errors_1.ParserError(`Array length does not match type length. Expected a length of ${fixedLength}, but received ${value.length}.`));\n            // `T[k]` for any `T` and `k` is encoded as `(T[0], ..., T[k - 1])`.\n            return tuple_1.tuple.encode({\n                type: (0, exports.getTupleType)(arrayType, fixedLength),\n                buffer,\n                value,\n                // In \"tight\" mode, we don't pad the values to 32 bytes if the value is\n                // of type `bytesN`. This is an edge case in `ethereumjs-abi` that we\n                // support to provide compatibility with it.\n                packed: fixed_bytes_1.fixedBytes.isType(arrayType) && tight,\n                tight,\n            });\n        }\n        // For packed encoding, we don't need to encode the length of the array,\n        // so we can just encode the values.\n        if (packed) {\n            return (0, packer_1.pack)({\n                types: new Array(value.length).fill(arrayType),\n                values: value,\n                byteArray: buffer,\n                // In \"tight\" mode, we don't pad the values to 32 bytes if the value is\n                // of type `bytesN`. This is an edge case in `ethereumjs-abi` that we\n                // support to provide compatibility with it.\n                packed: fixed_bytes_1.fixedBytes.isType(arrayType) && tight,\n                arrayPacked: true,\n                tight,\n            });\n        }\n        // `T[]` with `k` elements is encoded as `k (T[0], ..., T[k - 1])`. That\n        // means that we just need to encode the length of the array, and then the\n        // array itself. The pointer is encoded by the {@link pack} function.\n        const arrayLength = (0, utils_2.padStart)((0, utils_1.numberToBytes)(value.length));\n        return (0, packer_1.pack)({\n            types: new Array(value.length).fill(arrayType),\n            values: value,\n            byteArray: (0, utils_1.concatBytes)([buffer, arrayLength]),\n            packed,\n            tight,\n        });\n    },\n    /**\n     * Decode an array from the given byte array.\n     *\n     * @param args - The decoding arguments.\n     * @param args.type - The type of the array.\n     * @param args.value - The byte array to decode.\n     * @returns The decoded array.\n     */\n    decode({ type, value, ...rest }) {\n        const [arrayType, fixedLength] = (0, exports.getArrayType)(type);\n        if (fixedLength) {\n            const result = tuple_1.tuple.decode({\n                type: (0, exports.getTupleType)(arrayType, fixedLength),\n                value,\n                ...rest,\n            });\n            (0, utils_1.assert)(result.length === fixedLength, new errors_1.ParserError(`Array length does not match type length. Expected a length of ${fixedLength}, but received ${result.length}.`));\n            return result;\n        }\n        const arrayLength = (0, utils_1.bytesToNumber)(value.subarray(0, 32));\n        return (0, packer_1.unpack)(new Array(arrayLength).fill(arrayType), value.subarray(32));\n    },\n};\n//# sourceMappingURL=array.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvYXJyYXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQjtBQUNqRixnQkFBZ0IsbUJBQU8sQ0FBQyw2R0FBaUI7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsMEVBQVc7QUFDcEMsaUJBQWlCLG1CQUFPLENBQUMsMEVBQVc7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQVU7QUFDbEMsc0JBQXNCLG1CQUFPLENBQUMsMkZBQWU7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQVM7QUFDakM7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUlBQW1JLEtBQUs7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRDQUE0QztBQUMzRDtBQUNBLG9CQUFvQjtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SEFBOEgsS0FBSztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0NBQW9DO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3SkFBd0osWUFBWSxpQkFBaUIsYUFBYTtBQUNsTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHlKQUF5SixZQUFZLGlCQUFpQixjQUFjO0FBQ3BNO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvYXJyYXkuanM/ZjliYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXJyYXkgPSBleHBvcnRzLmdldFR1cGxlVHlwZSA9IGV4cG9ydHMuZ2V0QXJyYXlUeXBlID0gZXhwb3J0cy5pc0FycmF5VHlwZSA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgcGFja2VyXzEgPSByZXF1aXJlKFwiLi4vcGFja2VyXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IGZpeGVkX2J5dGVzXzEgPSByZXF1aXJlKFwiLi9maXhlZC1ieXRlc1wiKTtcbmNvbnN0IHR1cGxlXzEgPSByZXF1aXJlKFwiLi90dXBsZVwiKTtcbmNvbnN0IEFSUkFZX1JFR0VYID0gL14oPzx0eXBlPi4qKVxcWyg/PGxlbmd0aD5cXGQqPylcXF0kL3U7XG5jb25zdCBpc0FycmF5VHlwZSA9ICh0eXBlKSA9PiBBUlJBWV9SRUdFWC50ZXN0KHR5cGUpO1xuZXhwb3J0cy5pc0FycmF5VHlwZSA9IGlzQXJyYXlUeXBlO1xuLyoqXG4gKiBHZXQgdGhlIHR5cGUgb2YgdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gZ2V0IHRoZSBhcnJheSB0eXBlIGZvci5cbiAqIEByZXR1cm5zIFRoZSBhcnJheSB0eXBlLlxuICovXG5jb25zdCBnZXRBcnJheVR5cGUgPSAodHlwZSkgPT4ge1xuICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChBUlJBWV9SRUdFWCk7XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShtYXRjaD8uZ3JvdXBzPy50eXBlLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYEludmFsaWQgYXJyYXkgdHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgdHlwZSwgYnV0IHJlY2VpdmVkIFwiJHt0eXBlfVwiLmApKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBtYXRjaC5ncm91cHMudHlwZSxcbiAgICAgICAgbWF0Y2guZ3JvdXBzLmxlbmd0aCA/IHBhcnNlSW50KG1hdGNoLmdyb3Vwcy5sZW5ndGgsIDEwKSA6IHVuZGVmaW5lZCxcbiAgICBdO1xufTtcbmV4cG9ydHMuZ2V0QXJyYXlUeXBlID0gZ2V0QXJyYXlUeXBlO1xuLyoqXG4gKiBHZXQgdGhlIHR5cGUgb2YgdGhlIGFycmF5IGFzIGEgdHVwbGUgdHlwZS4gVGhpcyBpcyB1c2VkIGZvciBlbmNvZGluZyBmaXhlZFxuICogbGVuZ3RoIGFycmF5cywgd2hpY2ggYXJlIGVuY29kZWQgYXMgdHVwbGVzLlxuICpcbiAqIEBwYXJhbSBpbm5lclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgYXJyYXkuXG4gKiBAcGFyYW0gbGVuZ3RoIC0gVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKiBAcmV0dXJucyBUaGUgdHVwbGUgdHlwZS5cbiAqL1xuY29uc3QgZ2V0VHVwbGVUeXBlID0gKGlubmVyVHlwZSwgbGVuZ3RoKSA9PiB7XG4gICAgcmV0dXJuIGAoJHtuZXcgQXJyYXkobGVuZ3RoKS5maWxsKGlubmVyVHlwZSkuam9pbignLCcpfSlgO1xufTtcbmV4cG9ydHMuZ2V0VHVwbGVUeXBlID0gZ2V0VHVwbGVUeXBlO1xuZXhwb3J0cy5hcnJheSA9IHtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgYXJyYXkgaXMgZHluYW1pYy4gQXJyYXlzIGFyZSBkeW5hbWljIGlmIHRoZSBhcnJheSBkb2VzIG5vdFxuICAgICAqIGhhdmUgYSBmaXhlZCBsZW5ndGgsIG9yIGlmIHRoZSBhcnJheSB0eXBlIGlzIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGFycmF5IGlzIGR5bmFtaWMuXG4gICAgICovXG4gICAgaXNEeW5hbWljKHR5cGUpIHtcbiAgICAgICAgY29uc3QgW2lubmVyVHlwZSwgbGVuZ3RoXSA9ICgwLCBleHBvcnRzLmdldEFycmF5VHlwZSkodHlwZSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIGBUW11gIGlzIGR5bmFtaWMgZm9yIGFueSBgVGAuIGBUW2tdYCBpcyBkeW5hbWljIGZvciBhbnkgZHluYW1pYyBgVGAgYW5kXG4gICAgICAgIC8vIGFueSBgayA+PSAwYC5cbiAgICAgICAgbGVuZ3RoID09PSB1bmRlZmluZWQgfHwgKDAsIHBhY2tlcl8xLmlzRHluYW1pY1BhcnNlcikoKDAsIHBhY2tlcl8xLmdldFBhcnNlcikoaW5uZXJUeXBlKSwgaW5uZXJUeXBlKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHR5cGUgaXMgYW4gYXJyYXkgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgdHlwZSBpcyBhbiBhcnJheSB0eXBlLlxuICAgICAqL1xuICAgIGlzVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5pc0FycmF5VHlwZSkodHlwZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIGVuY29kZWQgYXJyYXkuIElmIHRoZSBhcnJheSBpcyBkeW5hbWljLCB0aGlzXG4gICAgICogcmV0dXJucyAzMiwgaS5lLiwgdGhlIGxlbmd0aCBvZiB0aGUgcG9pbnRlciB0byB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBpc1xuICAgICAqIHN0YXRpYywgdGhpcyByZXR1cm5zIHRoZSBieXRlIGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHR1cGxlIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGdldCB0aGUgYnl0ZSBsZW5ndGggZm9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlIGxlbmd0aCBvZiBhbiBlbmNvZGVkIGFycmF5LlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgodHlwZSkge1xuICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKCgwLCBleHBvcnRzLmlzQXJyYXlUeXBlKSh0eXBlKSwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBFeHBlY3RlZCBhbiBhcnJheSB0eXBlLCBidXQgcmVjZWl2ZWQgXCIke3R5cGV9XCIuYCkpO1xuICAgICAgICBjb25zdCBbaW5uZXJUeXBlLCBsZW5ndGhdID0gKDAsIGV4cG9ydHMuZ2V0QXJyYXlUeXBlKSh0eXBlKTtcbiAgICAgICAgaWYgKCEoMCwgcGFja2VyXzEuaXNEeW5hbWljUGFyc2VyKSh0aGlzLCB0eXBlKSAmJiBsZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHR1cGxlXzEudHVwbGUuZ2V0Qnl0ZUxlbmd0aCgoMCwgZXhwb3J0cy5nZXRUdXBsZVR5cGUpKGlubmVyVHlwZSwgbGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDMyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5jb2RlIHRoZSBnaXZlbiBhcnJheSB0byBhIGJ5dGUgYXJyYXkuIElmIHRoZSBhcnJheSBpcyBzdGF0aWMsIHRoaXMgdXNlc1xuICAgICAqIHRoZSB0dXBsZSBlbmNvZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZW5jb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgYXJyYXkuXG4gICAgICogQHBhcmFtIGFyZ3MuYnVmZmVyIC0gVGhlIGJ5dGUgYXJyYXkgdG8gYWRkIHRvLlxuICAgICAqIEBwYXJhbSBhcmdzLnZhbHVlIC0gVGhlIGFycmF5IHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gYXJncy5wYWNrZWQgLSBXaGV0aGVyIHRvIHVzZSBub24tc3RhbmRhcmQgcGFja2VkIGVuY29kaW5nLlxuICAgICAqIEBwYXJhbSBhcmdzLnRpZ2h0IC0gV2hldGhlciB0byB1c2Ugbm9uLXN0YW5kYXJkIHRpZ2h0IGVuY29kaW5nLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlcyB3aXRoIHRoZSBlbmNvZGVkIGFycmF5IGFkZGVkIHRvIGl0LlxuICAgICAqL1xuICAgIGVuY29kZSh7IHR5cGUsIGJ1ZmZlciwgdmFsdWUsIHBhY2tlZCwgdGlnaHQgfSkge1xuICAgICAgICBjb25zdCBbYXJyYXlUeXBlLCBmaXhlZExlbmd0aF0gPSAoMCwgZXhwb3J0cy5nZXRBcnJheVR5cGUpKHR5cGUpO1xuICAgICAgICAvLyBQYWNrZWQgZW5jb2RpbmcgZG9lcyBub3Qgc3VwcG9ydCBuZXN0ZWQgYXJyYXlzLlxuICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKCFwYWNrZWQgfHwgISgwLCBleHBvcnRzLmlzQXJyYXlUeXBlKShhcnJheVR5cGUpLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYENhbm5vdCBwYWNrIG5lc3RlZCBhcnJheXMuYCkpO1xuICAgICAgICAvLyBUaWdodGx5IHBhY2sgYFRbXWAgd2hlcmUgYFRgIGlzIGEgZHluYW1pYyB0eXBlLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW5cbiAgICAgICAgLy8gU29saWRpdHksIGJ1dCBpcyBjb21tb25seSB1c2VkIGluIHRoZSBFdGhlcmV1bSBlY29zeXN0ZW0uXG4gICAgICAgIGlmIChwYWNrZWQgJiYgKDAsIHBhY2tlcl8xLmlzRHluYW1pY1BhcnNlcikoKDAsIHBhY2tlcl8xLmdldFBhcnNlcikoYXJyYXlUeXBlKSwgYXJyYXlUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBwYWNrZXJfMS5wYWNrKSh7XG4gICAgICAgICAgICAgICAgdHlwZXM6IG5ldyBBcnJheSh2YWx1ZS5sZW5ndGgpLmZpbGwoYXJyYXlUeXBlKSxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGJ5dGVBcnJheTogYnVmZmVyLFxuICAgICAgICAgICAgICAgIHBhY2tlZCxcbiAgICAgICAgICAgICAgICBhcnJheVBhY2tlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0aWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXhlZExlbmd0aCkge1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShmaXhlZExlbmd0aCA9PT0gdmFsdWUubGVuZ3RoLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYEFycmF5IGxlbmd0aCBkb2VzIG5vdCBtYXRjaCB0eXBlIGxlbmd0aC4gRXhwZWN0ZWQgYSBsZW5ndGggb2YgJHtmaXhlZExlbmd0aH0sIGJ1dCByZWNlaXZlZCAke3ZhbHVlLmxlbmd0aH0uYCkpO1xuICAgICAgICAgICAgLy8gYFRba11gIGZvciBhbnkgYFRgIGFuZCBga2AgaXMgZW5jb2RlZCBhcyBgKFRbMF0sIC4uLiwgVFtrIC0gMV0pYC5cbiAgICAgICAgICAgIHJldHVybiB0dXBsZV8xLnR1cGxlLmVuY29kZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogKDAsIGV4cG9ydHMuZ2V0VHVwbGVUeXBlKShhcnJheVR5cGUsIGZpeGVkTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgLy8gSW4gXCJ0aWdodFwiIG1vZGUsIHdlIGRvbid0IHBhZCB0aGUgdmFsdWVzIHRvIDMyIGJ5dGVzIGlmIHRoZSB2YWx1ZSBpc1xuICAgICAgICAgICAgICAgIC8vIG9mIHR5cGUgYGJ5dGVzTmAuIFRoaXMgaXMgYW4gZWRnZSBjYXNlIGluIGBldGhlcmV1bWpzLWFiaWAgdGhhdCB3ZVxuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgdG8gcHJvdmlkZSBjb21wYXRpYmlsaXR5IHdpdGggaXQuXG4gICAgICAgICAgICAgICAgcGFja2VkOiBmaXhlZF9ieXRlc18xLmZpeGVkQnl0ZXMuaXNUeXBlKGFycmF5VHlwZSkgJiYgdGlnaHQsXG4gICAgICAgICAgICAgICAgdGlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgcGFja2VkIGVuY29kaW5nLCB3ZSBkb24ndCBuZWVkIHRvIGVuY29kZSB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSxcbiAgICAgICAgLy8gc28gd2UgY2FuIGp1c3QgZW5jb2RlIHRoZSB2YWx1ZXMuXG4gICAgICAgIGlmIChwYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgcGFja2VyXzEucGFjaykoe1xuICAgICAgICAgICAgICAgIHR5cGVzOiBuZXcgQXJyYXkodmFsdWUubGVuZ3RoKS5maWxsKGFycmF5VHlwZSksXG4gICAgICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBieXRlQXJyYXk6IGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAvLyBJbiBcInRpZ2h0XCIgbW9kZSwgd2UgZG9uJ3QgcGFkIHRoZSB2YWx1ZXMgdG8gMzIgYnl0ZXMgaWYgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgICAgICAgLy8gb2YgdHlwZSBgYnl0ZXNOYC4gVGhpcyBpcyBhbiBlZGdlIGNhc2UgaW4gYGV0aGVyZXVtanMtYWJpYCB0aGF0IHdlXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCB0byBwcm92aWRlIGNvbXBhdGliaWxpdHkgd2l0aCBpdC5cbiAgICAgICAgICAgICAgICBwYWNrZWQ6IGZpeGVkX2J5dGVzXzEuZml4ZWRCeXRlcy5pc1R5cGUoYXJyYXlUeXBlKSAmJiB0aWdodCxcbiAgICAgICAgICAgICAgICBhcnJheVBhY2tlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0aWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBUW11gIHdpdGggYGtgIGVsZW1lbnRzIGlzIGVuY29kZWQgYXMgYGsgKFRbMF0sIC4uLiwgVFtrIC0gMV0pYC4gVGhhdFxuICAgICAgICAvLyBtZWFucyB0aGF0IHdlIGp1c3QgbmVlZCB0byBlbmNvZGUgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXksIGFuZCB0aGVuIHRoZVxuICAgICAgICAvLyBhcnJheSBpdHNlbGYuIFRoZSBwb2ludGVyIGlzIGVuY29kZWQgYnkgdGhlIHtAbGluayBwYWNrfSBmdW5jdGlvbi5cbiAgICAgICAgY29uc3QgYXJyYXlMZW5ndGggPSAoMCwgdXRpbHNfMi5wYWRTdGFydCkoKDAsIHV0aWxzXzEubnVtYmVyVG9CeXRlcykodmFsdWUubGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiAoMCwgcGFja2VyXzEucGFjaykoe1xuICAgICAgICAgICAgdHlwZXM6IG5ldyBBcnJheSh2YWx1ZS5sZW5ndGgpLmZpbGwoYXJyYXlUeXBlKSxcbiAgICAgICAgICAgIHZhbHVlczogdmFsdWUsXG4gICAgICAgICAgICBieXRlQXJyYXk6ICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbYnVmZmVyLCBhcnJheUxlbmd0aF0pLFxuICAgICAgICAgICAgcGFja2VkLFxuICAgICAgICAgICAgdGlnaHQsXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGFuIGFycmF5IGZyb20gdGhlIGdpdmVuIGJ5dGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBkZWNvZGluZyBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIGFyZ3MudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBhcnJheS5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSBieXRlIGFycmF5IHRvIGRlY29kZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBhcnJheS5cbiAgICAgKi9cbiAgICBkZWNvZGUoeyB0eXBlLCB2YWx1ZSwgLi4ucmVzdCB9KSB7XG4gICAgICAgIGNvbnN0IFthcnJheVR5cGUsIGZpeGVkTGVuZ3RoXSA9ICgwLCBleHBvcnRzLmdldEFycmF5VHlwZSkodHlwZSk7XG4gICAgICAgIGlmIChmaXhlZExlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdHVwbGVfMS50dXBsZS5kZWNvZGUoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICgwLCBleHBvcnRzLmdldFR1cGxlVHlwZSkoYXJyYXlUeXBlLCBmaXhlZExlbmd0aCksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShyZXN1bHQubGVuZ3RoID09PSBmaXhlZExlbmd0aCwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBBcnJheSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggdHlwZSBsZW5ndGguIEV4cGVjdGVkIGEgbGVuZ3RoIG9mICR7Zml4ZWRMZW5ndGh9LCBidXQgcmVjZWl2ZWQgJHtyZXN1bHQubGVuZ3RofS5gKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFycmF5TGVuZ3RoID0gKDAsIHV0aWxzXzEuYnl0ZXNUb051bWJlcikodmFsdWUuc3ViYXJyYXkoMCwgMzIpKTtcbiAgICAgICAgcmV0dXJuICgwLCBwYWNrZXJfMS51bnBhY2spKG5ldyBBcnJheShhcnJheUxlbmd0aCkuZmlsbChhcnJheVR5cGUpLCB2YWx1ZS5zdWJhcnJheSgzMikpO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/bool.js":
/*!***************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/bool.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bool = exports.getBooleanValue = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst number_1 = __webpack_require__(/*! ./number */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/number.js\");\nconst BooleanCoercer = (0, superstruct_1.coerce)((0, superstruct_1.boolean)(), (0, superstruct_1.union)([(0, superstruct_1.literal)('true'), (0, superstruct_1.literal)('false')]), (value) => value === 'true');\n/**\n * Normalize a boolean value. This accepts the boolean as:\n *\n * - A boolean literal.\n * - The string \"true\" or \"false\".\n *\n * @param value - The value to get a boolean for.\n * @returns The parsed boolean value. This is `BigInt(1)` for truthy values, or\n * `BigInt(0)` for falsy values.\n */\nconst getBooleanValue = (value) => {\n    try {\n        const booleanValue = (0, superstruct_1.create)(value, BooleanCoercer);\n        if (booleanValue) {\n            return BigInt(1);\n        }\n        return BigInt(0);\n    }\n    catch {\n        throw new errors_1.ParserError(`Invalid boolean value. Expected a boolean literal, or the string \"true\" or \"false\", but received \"${value}\".`);\n    }\n};\nexports.getBooleanValue = getBooleanValue;\nexports.bool = {\n    isDynamic: false,\n    /**\n     * Get if the given value is a valid boolean type. Since `bool` is a simple\n     * type, this is just a check that the value is \"bool\".\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a valid boolean type.\n     */\n    isType: (type) => type === 'bool',\n    /**\n     * Get the byte length of an encoded boolean. Since `bool` is a simple\n     * type, this always returns 32.\n     *\n     * Note that actual booleans are only 1 byte long, but the encoding of\n     * the `bool` type is always 32 bytes long.\n     *\n     * @returns The byte length of an encoded boolean.\n     */\n    getByteLength() {\n        return 32;\n    },\n    /**\n     * Encode the given boolean to a byte array.\n     *\n     * @param args - The encoding arguments.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The boolean to encode.\n     * @param args.packed - Whether the value is packed.\n     * @param args.tight - Whether to use non-standard tight encoding.\n     * @returns The bytes with the encoded boolean added to it.\n     */\n    encode({ buffer, value, packed, tight }) {\n        const booleanValue = (0, exports.getBooleanValue)(value);\n        // For packed encoding, we add a single byte (`0x00` or `0x01`) to the byte\n        // array.\n        if (packed) {\n            return (0, utils_1.concatBytes)([buffer, (0, utils_1.bigIntToBytes)(booleanValue)]);\n        }\n        // Booleans are encoded as 32-byte integers, so we use the number parser\n        // to encode the boolean value.\n        return number_1.number.encode({\n            type: 'uint256',\n            buffer,\n            value: booleanValue,\n            packed,\n            tight,\n        });\n    },\n    /**\n     * Decode the given byte array to a boolean.\n     *\n     * @param args - The decoding arguments.\n     * @returns The decoded boolean.\n     */\n    decode(args) {\n        // Booleans are encoded as 32-byte integers, so we use the number parser\n        // to decode the boolean value.\n        return number_1.number.decode({ ...args, type: 'uint256' }) === BigInt(1);\n    },\n};\n//# sourceMappingURL=bool.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvYm9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsdUJBQXVCO0FBQ3RDLHNCQUFzQixtQkFBTyxDQUFDLHdGQUF1QjtBQUNyRCxnQkFBZ0IsbUJBQU8sQ0FBQyw2R0FBaUI7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsMEVBQVc7QUFDcEMsaUJBQWlCLG1CQUFPLENBQUMsaUZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRJQUE0SSxNQUFNO0FBQ2xKO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhCQUE4QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMEJBQTBCO0FBQ2xFLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL2Jvb2wuanM/ZjViMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYm9vbCA9IGV4cG9ydHMuZ2V0Qm9vbGVhblZhbHVlID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IG51bWJlcl8xID0gcmVxdWlyZShcIi4vbnVtYmVyXCIpO1xuY29uc3QgQm9vbGVhbkNvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLmJvb2xlYW4pKCksICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEubGl0ZXJhbCkoJ3RydWUnKSwgKDAsIHN1cGVyc3RydWN0XzEubGl0ZXJhbCkoJ2ZhbHNlJyldKSwgKHZhbHVlKSA9PiB2YWx1ZSA9PT0gJ3RydWUnKTtcbi8qKlxuICogTm9ybWFsaXplIGEgYm9vbGVhbiB2YWx1ZS4gVGhpcyBhY2NlcHRzIHRoZSBib29sZWFuIGFzOlxuICpcbiAqIC0gQSBib29sZWFuIGxpdGVyYWwuXG4gKiAtIFRoZSBzdHJpbmcgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBnZXQgYSBib29sZWFuIGZvci5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgYm9vbGVhbiB2YWx1ZS4gVGhpcyBpcyBgQmlnSW50KDEpYCBmb3IgdHJ1dGh5IHZhbHVlcywgb3JcbiAqIGBCaWdJbnQoMClgIGZvciBmYWxzeSB2YWx1ZXMuXG4gKi9cbmNvbnN0IGdldEJvb2xlYW5WYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJvb2xlYW5WYWx1ZSA9ICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIEJvb2xlYW5Db2VyY2VyKTtcbiAgICAgICAgaWYgKGJvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KDApO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCBib29sZWFuIHZhbHVlLiBFeHBlY3RlZCBhIGJvb2xlYW4gbGl0ZXJhbCwgb3IgdGhlIHN0cmluZyBcInRydWVcIiBvciBcImZhbHNlXCIsIGJ1dCByZWNlaXZlZCBcIiR7dmFsdWV9XCIuYCk7XG4gICAgfVxufTtcbmV4cG9ydHMuZ2V0Qm9vbGVhblZhbHVlID0gZ2V0Qm9vbGVhblZhbHVlO1xuZXhwb3J0cy5ib29sID0ge1xuICAgIGlzRHluYW1pYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogR2V0IGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIGJvb2xlYW4gdHlwZS4gU2luY2UgYGJvb2xgIGlzIGEgc2ltcGxlXG4gICAgICogdHlwZSwgdGhpcyBpcyBqdXN0IGEgY2hlY2sgdGhhdCB0aGUgdmFsdWUgaXMgXCJib29sXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHR5cGUgaXMgYSB2YWxpZCBib29sZWFuIHR5cGUuXG4gICAgICovXG4gICAgaXNUeXBlOiAodHlwZSkgPT4gdHlwZSA9PT0gJ2Jvb2wnLFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZSBsZW5ndGggb2YgYW4gZW5jb2RlZCBib29sZWFuLiBTaW5jZSBgYm9vbGAgaXMgYSBzaW1wbGVcbiAgICAgKiB0eXBlLCB0aGlzIGFsd2F5cyByZXR1cm5zIDMyLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGFjdHVhbCBib29sZWFucyBhcmUgb25seSAxIGJ5dGUgbG9uZywgYnV0IHRoZSBlbmNvZGluZyBvZlxuICAgICAqIHRoZSBgYm9vbGAgdHlwZSBpcyBhbHdheXMgMzIgYnl0ZXMgbG9uZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlIGxlbmd0aCBvZiBhbiBlbmNvZGVkIGJvb2xlYW4uXG4gICAgICovXG4gICAgZ2V0Qnl0ZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIDMyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5jb2RlIHRoZSBnaXZlbiBib29sZWFuIHRvIGEgYnl0ZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGVuY29kaW5nIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gYXJncy5idWZmZXIgLSBUaGUgYnl0ZSBhcnJheSB0byBhZGQgdG8uXG4gICAgICogQHBhcmFtIGFyZ3MudmFsdWUgLSBUaGUgYm9vbGVhbiB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MucGFja2VkIC0gV2hldGhlciB0aGUgdmFsdWUgaXMgcGFja2VkLlxuICAgICAqIEBwYXJhbSBhcmdzLnRpZ2h0IC0gV2hldGhlciB0byB1c2Ugbm9uLXN0YW5kYXJkIHRpZ2h0IGVuY29kaW5nLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlcyB3aXRoIHRoZSBlbmNvZGVkIGJvb2xlYW4gYWRkZWQgdG8gaXQuXG4gICAgICovXG4gICAgZW5jb2RlKHsgYnVmZmVyLCB2YWx1ZSwgcGFja2VkLCB0aWdodCB9KSB7XG4gICAgICAgIGNvbnN0IGJvb2xlYW5WYWx1ZSA9ICgwLCBleHBvcnRzLmdldEJvb2xlYW5WYWx1ZSkodmFsdWUpO1xuICAgICAgICAvLyBGb3IgcGFja2VkIGVuY29kaW5nLCB3ZSBhZGQgYSBzaW5nbGUgYnl0ZSAoYDB4MDBgIG9yIGAweDAxYCkgdG8gdGhlIGJ5dGVcbiAgICAgICAgLy8gYXJyYXkuXG4gICAgICAgIGlmIChwYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW2J1ZmZlciwgKDAsIHV0aWxzXzEuYmlnSW50VG9CeXRlcykoYm9vbGVhblZhbHVlKV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJvb2xlYW5zIGFyZSBlbmNvZGVkIGFzIDMyLWJ5dGUgaW50ZWdlcnMsIHNvIHdlIHVzZSB0aGUgbnVtYmVyIHBhcnNlclxuICAgICAgICAvLyB0byBlbmNvZGUgdGhlIGJvb2xlYW4gdmFsdWUuXG4gICAgICAgIHJldHVybiBudW1iZXJfMS5udW1iZXIuZW5jb2RlKHtcbiAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgIHZhbHVlOiBib29sZWFuVmFsdWUsXG4gICAgICAgICAgICBwYWNrZWQsXG4gICAgICAgICAgICB0aWdodCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWNvZGUgdGhlIGdpdmVuIGJ5dGUgYXJyYXkgdG8gYSBib29sZWFuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZGVjb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIGJvb2xlYW4uXG4gICAgICovXG4gICAgZGVjb2RlKGFyZ3MpIHtcbiAgICAgICAgLy8gQm9vbGVhbnMgYXJlIGVuY29kZWQgYXMgMzItYnl0ZSBpbnRlZ2Vycywgc28gd2UgdXNlIHRoZSBudW1iZXIgcGFyc2VyXG4gICAgICAgIC8vIHRvIGRlY29kZSB0aGUgYm9vbGVhbiB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG51bWJlcl8xLm51bWJlci5kZWNvZGUoeyAuLi5hcmdzLCB0eXBlOiAndWludDI1NicgfSkgPT09IEJpZ0ludCgxKTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb2wuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/bool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/bytes.js":
/*!****************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/bytes.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bytes = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs\");\nconst utils_2 = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js\");\nexports.bytes = {\n    isDynamic: true,\n    /**\n     * Check if a type is a bytes type. Since `bytes` is a simple type, this is\n     * just a check that the type is \"bytes\".\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a bytes type.\n     */\n    isType: (type) => type === 'bytes',\n    /**\n     * Get the byte length of an encoded bytes value. Since `bytes` is a simple\n     * type, this always returns 32.\n     *\n     * Note that actual length of a bytes value is variable, but the encoded\n     * static value (pointer) is always 32 bytes long.\n     *\n     * @returns The byte length of an encoded bytes value.\n     */\n    getByteLength() {\n        return 32;\n    },\n    /**\n     * Encode the given bytes value to a byte array.\n     *\n     * @param args - The encoding arguments.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The bytes value to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @returns The bytes with the encoded bytes value added to it.\n     */\n    encode({ buffer, value, packed }) {\n        const bufferValue = (0, utils_1.createBytes)(value);\n        // For packed encoding, we can just add the bytes value to the byte array,\n        // without adding any padding or alignment. There is also no need to\n        // encode the length of the bytes.\n        if (packed) {\n            return (0, utils_1.concatBytes)([buffer, bufferValue]);\n        }\n        const paddedSize = Math.ceil(bufferValue.byteLength / 32) * 32;\n        // Bytes of length `k` are encoded as `k pad_right(bytes)`.\n        return (0, utils_1.concatBytes)([\n            buffer,\n            (0, utils_2.padStart)((0, utils_1.numberToBytes)(bufferValue.byteLength)),\n            (0, utils_2.padEnd)(bufferValue, paddedSize),\n        ]);\n    },\n    /**\n     * Decode the given byte array to a bytes value.\n     *\n     * @param args - The decoding arguments.\n     * @param args.value - The byte array to decode.\n     * @returns The decoded bytes value as a `Uint8Array`.\n     */\n    decode({ value }) {\n        const bytesValue = value.subarray(0, 32);\n        const length = (0, utils_1.bytesToNumber)(bytesValue);\n        // Since we're returning a `Uint8Array`, we use `slice` to copy the bytes\n        // into a new array.\n        return value.slice(32, 32 + length);\n    },\n};\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvYnl0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGdCQUFnQixtQkFBTyxDQUFDLDZHQUFpQjtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBVTtBQUNsQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvcGFyc2Vycy9ieXRlcy5qcz85OGFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ieXRlcyA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmV4cG9ydHMuYnl0ZXMgPSB7XG4gICAgaXNEeW5hbWljOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdHlwZSBpcyBhIGJ5dGVzIHR5cGUuIFNpbmNlIGBieXRlc2AgaXMgYSBzaW1wbGUgdHlwZSwgdGhpcyBpc1xuICAgICAqIGp1c3QgYSBjaGVjayB0aGF0IHRoZSB0eXBlIGlzIFwiYnl0ZXNcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgdHlwZSBpcyBhIGJ5dGVzIHR5cGUuXG4gICAgICovXG4gICAgaXNUeXBlOiAodHlwZSkgPT4gdHlwZSA9PT0gJ2J5dGVzJyxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIGVuY29kZWQgYnl0ZXMgdmFsdWUuIFNpbmNlIGBieXRlc2AgaXMgYSBzaW1wbGVcbiAgICAgKiB0eXBlLCB0aGlzIGFsd2F5cyByZXR1cm5zIDMyLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGFjdHVhbCBsZW5ndGggb2YgYSBieXRlcyB2YWx1ZSBpcyB2YXJpYWJsZSwgYnV0IHRoZSBlbmNvZGVkXG4gICAgICogc3RhdGljIHZhbHVlIChwb2ludGVyKSBpcyBhbHdheXMgMzIgYnl0ZXMgbG9uZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlIGxlbmd0aCBvZiBhbiBlbmNvZGVkIGJ5dGVzIHZhbHVlLlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiAzMjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUgZ2l2ZW4gYnl0ZXMgdmFsdWUgdG8gYSBieXRlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZW5jb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLmJ1ZmZlciAtIFRoZSBieXRlIGFycmF5IHRvIGFkZCB0by5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSBieXRlcyB2YWx1ZSB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MucGFja2VkIC0gV2hldGhlciB0byB1c2UgcGFja2VkIGVuY29kaW5nLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlcyB3aXRoIHRoZSBlbmNvZGVkIGJ5dGVzIHZhbHVlIGFkZGVkIHRvIGl0LlxuICAgICAqL1xuICAgIGVuY29kZSh7IGJ1ZmZlciwgdmFsdWUsIHBhY2tlZCB9KSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlclZhbHVlID0gKDAsIHV0aWxzXzEuY3JlYXRlQnl0ZXMpKHZhbHVlKTtcbiAgICAgICAgLy8gRm9yIHBhY2tlZCBlbmNvZGluZywgd2UgY2FuIGp1c3QgYWRkIHRoZSBieXRlcyB2YWx1ZSB0byB0aGUgYnl0ZSBhcnJheSxcbiAgICAgICAgLy8gd2l0aG91dCBhZGRpbmcgYW55IHBhZGRpbmcgb3IgYWxpZ25tZW50LiBUaGVyZSBpcyBhbHNvIG5vIG5lZWQgdG9cbiAgICAgICAgLy8gZW5jb2RlIHRoZSBsZW5ndGggb2YgdGhlIGJ5dGVzLlxuICAgICAgICBpZiAocGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKFtidWZmZXIsIGJ1ZmZlclZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFkZGVkU2l6ZSA9IE1hdGguY2VpbChidWZmZXJWYWx1ZS5ieXRlTGVuZ3RoIC8gMzIpICogMzI7XG4gICAgICAgIC8vIEJ5dGVzIG9mIGxlbmd0aCBga2AgYXJlIGVuY29kZWQgYXMgYGsgcGFkX3JpZ2h0KGJ5dGVzKWAuXG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW1xuICAgICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgICAgKDAsIHV0aWxzXzIucGFkU3RhcnQpKCgwLCB1dGlsc18xLm51bWJlclRvQnl0ZXMpKGJ1ZmZlclZhbHVlLmJ5dGVMZW5ndGgpKSxcbiAgICAgICAgICAgICgwLCB1dGlsc18yLnBhZEVuZCkoYnVmZmVyVmFsdWUsIHBhZGRlZFNpemUpLFxuICAgICAgICBdKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERlY29kZSB0aGUgZ2l2ZW4gYnl0ZSBhcnJheSB0byBhIGJ5dGVzIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZGVjb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLnZhbHVlIC0gVGhlIGJ5dGUgYXJyYXkgdG8gZGVjb2RlLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIGJ5dGVzIHZhbHVlIGFzIGEgYFVpbnQ4QXJyYXlgLlxuICAgICAqL1xuICAgIGRlY29kZSh7IHZhbHVlIH0pIHtcbiAgICAgICAgY29uc3QgYnl0ZXNWYWx1ZSA9IHZhbHVlLnN1YmFycmF5KDAsIDMyKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gKDAsIHV0aWxzXzEuYnl0ZXNUb051bWJlcikoYnl0ZXNWYWx1ZSk7XG4gICAgICAgIC8vIFNpbmNlIHdlJ3JlIHJldHVybmluZyBhIGBVaW50OEFycmF5YCwgd2UgdXNlIGBzbGljZWAgdG8gY29weSB0aGUgYnl0ZXNcbiAgICAgICAgLy8gaW50byBhIG5ldyBhcnJheS5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDMyLCAzMiArIGxlbmd0aCk7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fixedBytes = exports.getByteLength = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst utils_2 = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js\");\nconst BYTES_REGEX = /^bytes([0-9]{1,2})$/u;\n/**\n * Get the length of the specified type. If a length is not specified, or if the\n * length is out of range (0 < n <= 32), this will throw an error.\n *\n * @param type - The type to get the length for.\n * @returns The byte length of the type.\n */\nconst getByteLength = (type) => {\n    const bytes = type.match(BYTES_REGEX)?.[1];\n    (0, utils_1.assert)(bytes, `Invalid byte length. Expected a number between 1 and 32, but received \"${type}\".`);\n    const length = Number(bytes);\n    (0, utils_1.assert)(length > 0 && length <= 32, new errors_1.ParserError(`Invalid byte length. Expected a number between 1 and 32, but received \"${type}\".`));\n    return length;\n};\nexports.getByteLength = getByteLength;\nexports.fixedBytes = {\n    isDynamic: false,\n    /**\n     * Check if a type is a fixed bytes type.\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a fixed bytes type.\n     */\n    isType(type) {\n        return BYTES_REGEX.test(type);\n    },\n    /**\n     * Get the byte length of an encoded fixed bytes type.\n     *\n     * @returns The byte length of the type.\n     */\n    getByteLength() {\n        return 32;\n    },\n    /**\n     * Encode a fixed bytes value.\n     *\n     * @param args - The arguments to encode.\n     * @param args.type - The type of the value.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The value to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @returns The bytes with the encoded value added to it.\n     */\n    encode({ type, buffer, value, packed }) {\n        const length = (0, exports.getByteLength)(type);\n        const bufferValue = (0, utils_1.createBytes)(value);\n        (0, utils_1.assert)(bufferValue.length <= length, new errors_1.ParserError(`Expected a value of length ${length}, but received a value of length ${bufferValue.length}.`));\n        // For packed encoding, the value is padded to the length of the type, and\n        // then added to the byte array.\n        if (packed) {\n            return (0, utils_1.concatBytes)([buffer, (0, utils_2.padEnd)(bufferValue, length)]);\n        }\n        return (0, utils_1.concatBytes)([buffer, (0, utils_2.padEnd)(bufferValue)]);\n    },\n    /**\n     * Decode a fixed bytes value.\n     *\n     * @param args - The arguments to decode.\n     * @param args.type - The type of the value.\n     * @param args.value - The value to decode.\n     * @returns The decoded value as a `Uint8Array`.\n     */\n    decode({ type, value }) {\n        const length = (0, exports.getByteLength)(type);\n        // Since we're returning a `Uint8Array`, we use `slice` to copy the bytes\n        // into a new array.\n        return value.slice(0, length);\n    },\n};\n//# sourceMappingURL=fixed-bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvZml4ZWQtYnl0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcscUJBQXFCO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLDZHQUFpQjtBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBVztBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBVTtBQUNsQyxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsS0FBSztBQUM5RztBQUNBLHVKQUF1SixLQUFLO0FBQzVKO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0E7QUFDQSxpSEFBaUgsT0FBTyxtQ0FBbUMsbUJBQW1CO0FBQzlLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvZml4ZWQtYnl0ZXMuanM/M2RkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZml4ZWRCeXRlcyA9IGV4cG9ydHMuZ2V0Qnl0ZUxlbmd0aCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IEJZVEVTX1JFR0VYID0gL15ieXRlcyhbMC05XXsxLDJ9KSQvdTtcbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBJZiBhIGxlbmd0aCBpcyBub3Qgc3BlY2lmaWVkLCBvciBpZiB0aGVcbiAqIGxlbmd0aCBpcyBvdXQgb2YgcmFuZ2UgKDAgPCBuIDw9IDMyKSwgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gZ2V0IHRoZSBsZW5ndGggZm9yLlxuICogQHJldHVybnMgVGhlIGJ5dGUgbGVuZ3RoIG9mIHRoZSB0eXBlLlxuICovXG5jb25zdCBnZXRCeXRlTGVuZ3RoID0gKHR5cGUpID0+IHtcbiAgICBjb25zdCBieXRlcyA9IHR5cGUubWF0Y2goQllURVNfUkVHRVgpPy5bMV07XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShieXRlcywgYEludmFsaWQgYnl0ZSBsZW5ndGguIEV4cGVjdGVkIGEgbnVtYmVyIGJldHdlZW4gMSBhbmQgMzIsIGJ1dCByZWNlaXZlZCBcIiR7dHlwZX1cIi5gKTtcbiAgICBjb25zdCBsZW5ndGggPSBOdW1iZXIoYnl0ZXMpO1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkobGVuZ3RoID4gMCAmJiBsZW5ndGggPD0gMzIsIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCBieXRlIGxlbmd0aC4gRXhwZWN0ZWQgYSBudW1iZXIgYmV0d2VlbiAxIGFuZCAzMiwgYnV0IHJlY2VpdmVkIFwiJHt0eXBlfVwiLmApKTtcbiAgICByZXR1cm4gbGVuZ3RoO1xufTtcbmV4cG9ydHMuZ2V0Qnl0ZUxlbmd0aCA9IGdldEJ5dGVMZW5ndGg7XG5leHBvcnRzLmZpeGVkQnl0ZXMgPSB7XG4gICAgaXNEeW5hbWljOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHR5cGUgaXMgYSBmaXhlZCBieXRlcyB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0eXBlIGlzIGEgZml4ZWQgYnl0ZXMgdHlwZS5cbiAgICAgKi9cbiAgICBpc1R5cGUodHlwZSkge1xuICAgICAgICByZXR1cm4gQllURVNfUkVHRVgudGVzdCh0eXBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZSBsZW5ndGggb2YgYW4gZW5jb2RlZCBmaXhlZCBieXRlcyB0eXBlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJ5dGUgbGVuZ3RoIG9mIHRoZSB0eXBlLlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiAzMjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuY29kZSBhIGZpeGVkIGJ5dGVzIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gYXJncy50eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlLlxuICAgICAqIEBwYXJhbSBhcmdzLmJ1ZmZlciAtIFRoZSBieXRlIGFycmF5IHRvIGFkZCB0by5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MucGFja2VkIC0gV2hldGhlciB0byB1c2UgcGFja2VkIGVuY29kaW5nLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlcyB3aXRoIHRoZSBlbmNvZGVkIHZhbHVlIGFkZGVkIHRvIGl0LlxuICAgICAqL1xuICAgIGVuY29kZSh7IHR5cGUsIGJ1ZmZlciwgdmFsdWUsIHBhY2tlZCB9KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9ICgwLCBleHBvcnRzLmdldEJ5dGVMZW5ndGgpKHR5cGUpO1xuICAgICAgICBjb25zdCBidWZmZXJWYWx1ZSA9ICgwLCB1dGlsc18xLmNyZWF0ZUJ5dGVzKSh2YWx1ZSk7XG4gICAgICAgICgwLCB1dGlsc18xLmFzc2VydCkoYnVmZmVyVmFsdWUubGVuZ3RoIDw9IGxlbmd0aCwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBFeHBlY3RlZCBhIHZhbHVlIG9mIGxlbmd0aCAke2xlbmd0aH0sIGJ1dCByZWNlaXZlZCBhIHZhbHVlIG9mIGxlbmd0aCAke2J1ZmZlclZhbHVlLmxlbmd0aH0uYCkpO1xuICAgICAgICAvLyBGb3IgcGFja2VkIGVuY29kaW5nLCB0aGUgdmFsdWUgaXMgcGFkZGVkIHRvIHRoZSBsZW5ndGggb2YgdGhlIHR5cGUsIGFuZFxuICAgICAgICAvLyB0aGVuIGFkZGVkIHRvIHRoZSBieXRlIGFycmF5LlxuICAgICAgICBpZiAocGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKFtidWZmZXIsICgwLCB1dGlsc18yLnBhZEVuZCkoYnVmZmVyVmFsdWUsIGxlbmd0aCldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKFtidWZmZXIsICgwLCB1dGlsc18yLnBhZEVuZCkoYnVmZmVyVmFsdWUpXSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYSBmaXhlZCBieXRlcyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBkZWNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSB2YWx1ZSB0byBkZWNvZGUuXG4gICAgICogQHJldHVybnMgVGhlIGRlY29kZWQgdmFsdWUgYXMgYSBgVWludDhBcnJheWAuXG4gICAgICovXG4gICAgZGVjb2RlKHsgdHlwZSwgdmFsdWUgfSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSAoMCwgZXhwb3J0cy5nZXRCeXRlTGVuZ3RoKSh0eXBlKTtcbiAgICAgICAgLy8gU2luY2Ugd2UncmUgcmV0dXJuaW5nIGEgYFVpbnQ4QXJyYXlgLCB3ZSB1c2UgYHNsaWNlYCB0byBjb3B5IHRoZSBieXRlc1xuICAgICAgICAvLyBpbnRvIGEgbmV3IGFycmF5LlxuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkLWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/function.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/function.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fn = exports.getFunction = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst fixed_bytes_1 = __webpack_require__(/*! ./fixed-bytes */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js\");\n/**\n * A struct that represents a Solidity function. The value must be a hex string\n * or a byte array. The created value will always be an object with an `address`\n * and `selector` property.\n */\nconst FunctionStruct = (0, superstruct_1.coerce)((0, superstruct_1.object)({\n    address: utils_1.StrictHexStruct,\n    selector: utils_1.StrictHexStruct,\n}), (0, superstruct_1.union)([utils_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]), (value) => {\n    const bytes = (0, utils_1.createBytes)(value);\n    (0, utils_1.assert)(bytes.length === 24, new errors_1.ParserError(`Invalid Solidity function. Expected function to be 24 bytes long, but received ${bytes.length} bytes.`));\n    return {\n        address: (0, utils_1.bytesToHex)(bytes.subarray(0, 20)),\n        selector: (0, utils_1.bytesToHex)(bytes.subarray(20, 24)),\n    };\n});\n/**\n * Normalize a function. This accepts the function as:\n *\n * - A {@link SolidityFunction} object.\n * - A hexadecimal string.\n * - A byte array.\n *\n * @param input - The function-like input.\n * @returns The function as buffer.\n */\nconst getFunction = (input) => {\n    const value = (0, superstruct_1.create)(input, FunctionStruct);\n    return (0, utils_1.concatBytes)([(0, utils_1.hexToBytes)(value.address), (0, utils_1.hexToBytes)(value.selector)]);\n};\nexports.getFunction = getFunction;\nexports.fn = {\n    isDynamic: false,\n    /**\n     * Check if a type is a function type. Since `function` is a simple type, this\n     * is just a check that the type is \"function\".\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a function type.\n     */\n    isType: (type) => type === 'function',\n    /**\n     * Get the byte length of an encoded function. Since `function` is a simple\n     * type, this always returns 32.\n     *\n     * Note that actual functions are only 24 bytes long, but the encoding of\n     * the `function` type is always 32 bytes long.\n     *\n     * @returns The byte length of an encoded function.\n     */\n    getByteLength() {\n        return 32;\n    },\n    /**\n     * Encode the given function to a byte array.\n     *\n     * @param args - The encoding arguments.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The function to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @param args.tight - Whether to use non-standard tight encoding.\n     * @returns The bytes with the encoded function added to it.\n     */\n    encode({ buffer, value, packed, tight }) {\n        const fnValue = (0, exports.getFunction)(value);\n        // Functions are encoded as `bytes24`, so we use the fixedBytes parser to\n        // encode the function.\n        return fixed_bytes_1.fixedBytes.encode({\n            type: 'bytes24',\n            buffer,\n            value: fnValue,\n            packed,\n            tight,\n        });\n    },\n    /**\n     * Decode the given byte array to a function.\n     *\n     * @param args - The decoding arguments.\n     * @param args.value - The byte array to decode.\n     * @returns The decoded function as a {@link SolidityFunction} object.\n     */\n    decode({ value }) {\n        return {\n            address: (0, utils_1.bytesToHex)(value.slice(0, 20)),\n            selector: (0, utils_1.bytesToHex)(value.slice(20, 24)),\n        };\n    },\n};\n//# sourceMappingURL=function.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvZnVuY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsVUFBVSxHQUFHLG1CQUFtQjtBQUNoQyxzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBdUI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsNkdBQWlCO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFXO0FBQ3BDLHNCQUFzQixtQkFBTyxDQUFDLDJGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx3SkFBd0osY0FBYztBQUN0SztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdCQUF3QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOEJBQThCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx3QkFBd0I7QUFDbkU7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvcGFyc2Vycy9mdW5jdGlvbi5qcz80YTA5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mbiA9IGV4cG9ydHMuZ2V0RnVuY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zdXBlcnN0cnVjdFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgZml4ZWRfYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2ZpeGVkLWJ5dGVzXCIpO1xuLyoqXG4gKiBBIHN0cnVjdCB0aGF0IHJlcHJlc2VudHMgYSBTb2xpZGl0eSBmdW5jdGlvbi4gVGhlIHZhbHVlIG11c3QgYmUgYSBoZXggc3RyaW5nXG4gKiBvciBhIGJ5dGUgYXJyYXkuIFRoZSBjcmVhdGVkIHZhbHVlIHdpbGwgYWx3YXlzIGJlIGFuIG9iamVjdCB3aXRoIGFuIGBhZGRyZXNzYFxuICogYW5kIGBzZWxlY3RvcmAgcHJvcGVydHkuXG4gKi9cbmNvbnN0IEZ1bmN0aW9uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKSgoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBhZGRyZXNzOiB1dGlsc18xLlN0cmljdEhleFN0cnVjdCxcbiAgICBzZWxlY3RvcjogdXRpbHNfMS5TdHJpY3RIZXhTdHJ1Y3QsXG59KSwgKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFt1dGlsc18xLlN0cmljdEhleFN0cnVjdCwgKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpXSksICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGJ5dGVzID0gKDAsIHV0aWxzXzEuY3JlYXRlQnl0ZXMpKHZhbHVlKTtcbiAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKGJ5dGVzLmxlbmd0aCA9PT0gMjQsIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCBTb2xpZGl0eSBmdW5jdGlvbi4gRXhwZWN0ZWQgZnVuY3Rpb24gdG8gYmUgMjQgYnl0ZXMgbG9uZywgYnV0IHJlY2VpdmVkICR7Ynl0ZXMubGVuZ3RofSBieXRlcy5gKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogKDAsIHV0aWxzXzEuYnl0ZXNUb0hleCkoYnl0ZXMuc3ViYXJyYXkoMCwgMjApKSxcbiAgICAgICAgc2VsZWN0b3I6ICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKGJ5dGVzLnN1YmFycmF5KDIwLCAyNCkpLFxuICAgIH07XG59KTtcbi8qKlxuICogTm9ybWFsaXplIGEgZnVuY3Rpb24uIFRoaXMgYWNjZXB0cyB0aGUgZnVuY3Rpb24gYXM6XG4gKlxuICogLSBBIHtAbGluayBTb2xpZGl0eUZ1bmN0aW9ufSBvYmplY3QuXG4gKiAtIEEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogLSBBIGJ5dGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIGZ1bmN0aW9uLWxpa2UgaW5wdXQuXG4gKiBAcmV0dXJucyBUaGUgZnVuY3Rpb24gYXMgYnVmZmVyLlxuICovXG5jb25zdCBnZXRGdW5jdGlvbiA9IChpbnB1dCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKShpbnB1dCwgRnVuY3Rpb25TdHJ1Y3QpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoWygwLCB1dGlsc18xLmhleFRvQnl0ZXMpKHZhbHVlLmFkZHJlc3MpLCAoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKSh2YWx1ZS5zZWxlY3RvcildKTtcbn07XG5leHBvcnRzLmdldEZ1bmN0aW9uID0gZ2V0RnVuY3Rpb247XG5leHBvcnRzLmZuID0ge1xuICAgIGlzRHluYW1pYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0eXBlIGlzIGEgZnVuY3Rpb24gdHlwZS4gU2luY2UgYGZ1bmN0aW9uYCBpcyBhIHNpbXBsZSB0eXBlLCB0aGlzXG4gICAgICogaXMganVzdCBhIGNoZWNrIHRoYXQgdGhlIHR5cGUgaXMgXCJmdW5jdGlvblwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0eXBlIGlzIGEgZnVuY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBpc1R5cGU6ICh0eXBlKSA9PiB0eXBlID09PSAnZnVuY3Rpb24nLFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZSBsZW5ndGggb2YgYW4gZW5jb2RlZCBmdW5jdGlvbi4gU2luY2UgYGZ1bmN0aW9uYCBpcyBhIHNpbXBsZVxuICAgICAqIHR5cGUsIHRoaXMgYWx3YXlzIHJldHVybnMgMzIuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgYWN0dWFsIGZ1bmN0aW9ucyBhcmUgb25seSAyNCBieXRlcyBsb25nLCBidXQgdGhlIGVuY29kaW5nIG9mXG4gICAgICogdGhlIGBmdW5jdGlvbmAgdHlwZSBpcyBhbHdheXMgMzIgYnl0ZXMgbG9uZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlIGxlbmd0aCBvZiBhbiBlbmNvZGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiAzMjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG8gYSBieXRlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZW5jb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLmJ1ZmZlciAtIFRoZSBieXRlIGFycmF5IHRvIGFkZCB0by5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSBmdW5jdGlvbiB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MucGFja2VkIC0gV2hldGhlciB0byB1c2UgcGFja2VkIGVuY29kaW5nLlxuICAgICAqIEBwYXJhbSBhcmdzLnRpZ2h0IC0gV2hldGhlciB0byB1c2Ugbm9uLXN0YW5kYXJkIHRpZ2h0IGVuY29kaW5nLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlcyB3aXRoIHRoZSBlbmNvZGVkIGZ1bmN0aW9uIGFkZGVkIHRvIGl0LlxuICAgICAqL1xuICAgIGVuY29kZSh7IGJ1ZmZlciwgdmFsdWUsIHBhY2tlZCwgdGlnaHQgfSkge1xuICAgICAgICBjb25zdCBmblZhbHVlID0gKDAsIGV4cG9ydHMuZ2V0RnVuY3Rpb24pKHZhbHVlKTtcbiAgICAgICAgLy8gRnVuY3Rpb25zIGFyZSBlbmNvZGVkIGFzIGBieXRlczI0YCwgc28gd2UgdXNlIHRoZSBmaXhlZEJ5dGVzIHBhcnNlciB0b1xuICAgICAgICAvLyBlbmNvZGUgdGhlIGZ1bmN0aW9uLlxuICAgICAgICByZXR1cm4gZml4ZWRfYnl0ZXNfMS5maXhlZEJ5dGVzLmVuY29kZSh7XG4gICAgICAgICAgICB0eXBlOiAnYnl0ZXMyNCcsXG4gICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICB2YWx1ZTogZm5WYWx1ZSxcbiAgICAgICAgICAgIHBhY2tlZCxcbiAgICAgICAgICAgIHRpZ2h0LFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERlY29kZSB0aGUgZ2l2ZW4gYnl0ZSBhcnJheSB0byBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZGVjb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLnZhbHVlIC0gVGhlIGJ5dGUgYXJyYXkgdG8gZGVjb2RlLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIGZ1bmN0aW9uIGFzIGEge0BsaW5rIFNvbGlkaXR5RnVuY3Rpb259IG9iamVjdC5cbiAgICAgKi9cbiAgICBkZWNvZGUoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KSh2YWx1ZS5zbGljZSgwLCAyMCkpLFxuICAgICAgICAgICAgc2VsZWN0b3I6ICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKHZhbHVlLnNsaWNlKDIwLCAyNCkpLFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/function.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./address */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/address.js\"), exports);\n__exportStar(__webpack_require__(/*! ./array */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/array.js\"), exports);\n__exportStar(__webpack_require__(/*! ./bool */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/bool.js\"), exports);\n__exportStar(__webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/bytes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./fixed-bytes */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./function */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/function.js\"), exports);\n__exportStar(__webpack_require__(/*! ./number */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/number.js\"), exports);\n__exportStar(__webpack_require__(/*! ./parser */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/parser.js\"), exports);\n__exportStar(__webpack_require__(/*! ./string */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/string.js\"), exports);\n__exportStar(__webpack_require__(/*! ./tuple */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/tuple.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLG1GQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQywrRUFBUztBQUM5QixhQUFhLG1CQUFPLENBQUMsNkVBQVE7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLCtFQUFTO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQywyRkFBZTtBQUNwQyxhQUFhLG1CQUFPLENBQUMscUZBQVk7QUFDakMsYUFBYSxtQkFBTyxDQUFDLGlGQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxpRkFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsaUZBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLCtFQUFTO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL2luZGV4LmpzP2Q5N2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hZGRyZXNzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hcnJheVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYm9vbFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYnl0ZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ZpeGVkLWJ5dGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mdW5jdGlvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbnVtYmVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wYXJzZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N0cmluZ1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHVwbGVcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/number.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/number.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.number = exports.getBigInt = exports.assertNumberLength = exports.getLength = exports.isSigned = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst utils_2 = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js\");\nconst NUMBER_REGEX = /^u?int(?<length>[0-9]*)?$/u;\n/**\n * Check if a number type is signed.\n *\n * @param type - The type to check.\n * @returns Whether the type is signed.\n */\nconst isSigned = (type) => {\n    return !type.startsWith('u');\n};\nexports.isSigned = isSigned;\n/**\n * Get the length of the specified type. If a length is not specified, if the\n * length is out of range (8 <= n <= 256), or if the length is not a multiple of\n * 8, this will throw an error.\n *\n * @param type - The type to get the length for.\n * @returns The bit length of the type.\n */\nconst getLength = (type) => {\n    if (type === 'int' || type === 'uint') {\n        return 256;\n    }\n    const match = type.match(NUMBER_REGEX);\n    (0, utils_1.assert)(match?.groups?.length, new errors_1.ParserError(`Invalid number type. Expected a number type, but received \"${type}\".`));\n    const length = parseInt(match.groups.length, 10);\n    (0, utils_1.assert)(length >= 8 && length <= 256, new errors_1.ParserError(`Invalid number length. Expected a number between 8 and 256, but received \"${type}\".`));\n    (0, utils_1.assert)(length % 8 === 0, new errors_1.ParserError(`Invalid number length. Expected a multiple of 8, but received \"${type}\".`));\n    return length;\n};\nexports.getLength = getLength;\n/**\n * Assert that the byte length of the given value is in range for the given\n * number type.\n *\n * @param value - The value to check.\n * @param type - The type of the value.\n * @throws If the value is out of range for the type.\n */\nconst assertNumberLength = (value, type) => {\n    const length = (0, exports.getLength)(type);\n    const maxValue = BigInt(2) ** BigInt(length - ((0, exports.isSigned)(type) ? 1 : 0)) - BigInt(1);\n    if ((0, exports.isSigned)(type)) {\n        // Signed types must be in the range of `-(2^(length - 1))` to\n        // `2^(length - 1) - 1`.\n        (0, utils_1.assert)(value >= -(maxValue + BigInt(1)) && value <= maxValue, new errors_1.ParserError(`Number \"${value}\" is out of range for type \"${type}\".`));\n        return;\n    }\n    // Unsigned types must be in the range of `0` to `2^length - 1`.\n    (0, utils_1.assert)(value <= maxValue, new errors_1.ParserError(`Number \"${value}\" is out of range for type \"${type}\".`));\n};\nexports.assertNumberLength = assertNumberLength;\n/**\n * Normalize a `bigint` value. This accepts the value as:\n *\n * - A `bigint`.\n * - A `number`.\n * - A decimal string, i.e., a string that does not start with \"0x\".\n * - A hexadecimal string, i.e., a string that starts with \"0x\".\n *\n * @param value - The number-like value to parse.\n * @returns The value parsed as bigint.\n */\nconst getBigInt = (value) => {\n    try {\n        return (0, utils_1.createBigInt)(value);\n    }\n    catch {\n        throw new errors_1.ParserError(`Invalid number. Expected a valid number value, but received \"${value}\".`);\n    }\n};\nexports.getBigInt = getBigInt;\nexports.number = {\n    isDynamic: false,\n    /**\n     * Check if a type is a number type.\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a number type.\n     */\n    isType(type) {\n        return NUMBER_REGEX.test(type);\n    },\n    /**\n     * Get the byte length of an encoded number type. Since `int` and `uint` are\n     * simple types, this will always return 32.\n     *\n     * @returns The byte length of the type.\n     */\n    getByteLength() {\n        return 32;\n    },\n    /**\n     * Encode a number value.\n     *\n     * @param args - The arguments to encode.\n     * @param args.type - The type of the value.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The value to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @returns The bytes with the encoded value added to it.\n     */\n    encode({ type, buffer, value, packed }) {\n        const bigIntValue = (0, exports.getBigInt)(value);\n        (0, exports.assertNumberLength)(bigIntValue, type);\n        if ((0, exports.isSigned)(type)) {\n            // For packed encoding, the value is padded to the length of the type, and\n            // then added to the byte array.\n            if (packed) {\n                const length = (0, exports.getLength)(type) / 8;\n                return (0, utils_1.concatBytes)([buffer, (0, utils_1.signedBigIntToBytes)(bigIntValue, length)]);\n            }\n            return (0, utils_1.concatBytes)([\n                buffer,\n                (0, utils_2.padStart)((0, utils_1.signedBigIntToBytes)(bigIntValue, 32)),\n            ]);\n        }\n        // For packed encoding, the value is padded to the length of the type, and\n        // then added to the byte array.\n        if (packed) {\n            const length = (0, exports.getLength)(type) / 8;\n            return (0, utils_1.concatBytes)([\n                buffer,\n                (0, utils_2.padStart)((0, utils_1.bigIntToBytes)(bigIntValue), length),\n            ]);\n        }\n        return (0, utils_1.concatBytes)([buffer, (0, utils_2.padStart)((0, utils_1.bigIntToBytes)(bigIntValue))]);\n    },\n    /**\n     * Decode a number value.\n     *\n     * @param args - The decoding arguments.\n     * @param args.type - The type of the value.\n     * @param args.value - The value to decode.\n     * @returns The decoded value.\n     */\n    decode({ type, value }) {\n        const buffer = value.subarray(0, 32);\n        if ((0, exports.isSigned)(type)) {\n            const numberValue = (0, utils_1.bytesToSignedBigInt)(buffer);\n            (0, exports.assertNumberLength)(numberValue, type);\n            return numberValue;\n        }\n        const numberValue = (0, utils_1.bytesToBigInt)(buffer);\n        (0, exports.assertNumberLength)(numberValue, type);\n        return numberValue;\n    },\n};\n//# sourceMappingURL=number.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvbnVtYmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxpQkFBaUIsR0FBRywwQkFBMEIsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0I7QUFDdEcsZ0JBQWdCLG1CQUFPLENBQUMsNkdBQWlCO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFXO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJLEtBQUs7QUFDM0k7QUFDQSw0SkFBNEosS0FBSztBQUNqSyxxSUFBcUksS0FBSztBQUMxSTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUgsTUFBTSw4QkFBOEIsS0FBSztBQUNoSztBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsTUFBTSw4QkFBOEIsS0FBSztBQUN4SDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxNQUFNO0FBQzdHO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvbnVtYmVyLmpzPzBjMDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm51bWJlciA9IGV4cG9ydHMuZ2V0QmlnSW50ID0gZXhwb3J0cy5hc3NlcnROdW1iZXJMZW5ndGggPSBleHBvcnRzLmdldExlbmd0aCA9IGV4cG9ydHMuaXNTaWduZWQgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBOVU1CRVJfUkVHRVggPSAvXnU/aW50KD88bGVuZ3RoPlswLTldKik/JC91O1xuLyoqXG4gKiBDaGVjayBpZiBhIG51bWJlciB0eXBlIGlzIHNpZ25lZC5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdHlwZSBpcyBzaWduZWQuXG4gKi9cbmNvbnN0IGlzU2lnbmVkID0gKHR5cGUpID0+IHtcbiAgICByZXR1cm4gIXR5cGUuc3RhcnRzV2l0aCgndScpO1xufTtcbmV4cG9ydHMuaXNTaWduZWQgPSBpc1NpZ25lZDtcbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIHNwZWNpZmllZCB0eXBlLiBJZiBhIGxlbmd0aCBpcyBub3Qgc3BlY2lmaWVkLCBpZiB0aGVcbiAqIGxlbmd0aCBpcyBvdXQgb2YgcmFuZ2UgKDggPD0gbiA8PSAyNTYpLCBvciBpZiB0aGUgbGVuZ3RoIGlzIG5vdCBhIG11bHRpcGxlIG9mXG4gKiA4LCB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBnZXQgdGhlIGxlbmd0aCBmb3IuXG4gKiBAcmV0dXJucyBUaGUgYml0IGxlbmd0aCBvZiB0aGUgdHlwZS5cbiAqL1xuY29uc3QgZ2V0TGVuZ3RoID0gKHR5cGUpID0+IHtcbiAgICBpZiAodHlwZSA9PT0gJ2ludCcgfHwgdHlwZSA9PT0gJ3VpbnQnKSB7XG4gICAgICAgIHJldHVybiAyNTY7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChOVU1CRVJfUkVHRVgpO1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkobWF0Y2g/Lmdyb3Vwcz8ubGVuZ3RoLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYEludmFsaWQgbnVtYmVyIHR5cGUuIEV4cGVjdGVkIGEgbnVtYmVyIHR5cGUsIGJ1dCByZWNlaXZlZCBcIiR7dHlwZX1cIi5gKSk7XG4gICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQobWF0Y2guZ3JvdXBzLmxlbmd0aCwgMTApO1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkobGVuZ3RoID49IDggJiYgbGVuZ3RoIDw9IDI1NiwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBJbnZhbGlkIG51bWJlciBsZW5ndGguIEV4cGVjdGVkIGEgbnVtYmVyIGJldHdlZW4gOCBhbmQgMjU2LCBidXQgcmVjZWl2ZWQgXCIke3R5cGV9XCIuYCkpO1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkobGVuZ3RoICUgOCA9PT0gMCwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBJbnZhbGlkIG51bWJlciBsZW5ndGguIEV4cGVjdGVkIGEgbXVsdGlwbGUgb2YgOCwgYnV0IHJlY2VpdmVkIFwiJHt0eXBlfVwiLmApKTtcbiAgICByZXR1cm4gbGVuZ3RoO1xufTtcbmV4cG9ydHMuZ2V0TGVuZ3RoID0gZ2V0TGVuZ3RoO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgYnl0ZSBsZW5ndGggb2YgdGhlIGdpdmVuIHZhbHVlIGlzIGluIHJhbmdlIGZvciB0aGUgZ2l2ZW5cbiAqIG51bWJlciB0eXBlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgb3V0IG9mIHJhbmdlIGZvciB0aGUgdHlwZS5cbiAqL1xuY29uc3QgYXNzZXJ0TnVtYmVyTGVuZ3RoID0gKHZhbHVlLCB0eXBlKSA9PiB7XG4gICAgY29uc3QgbGVuZ3RoID0gKDAsIGV4cG9ydHMuZ2V0TGVuZ3RoKSh0eXBlKTtcbiAgICBjb25zdCBtYXhWYWx1ZSA9IEJpZ0ludCgyKSAqKiBCaWdJbnQobGVuZ3RoIC0gKCgwLCBleHBvcnRzLmlzU2lnbmVkKSh0eXBlKSA/IDEgOiAwKSkgLSBCaWdJbnQoMSk7XG4gICAgaWYgKCgwLCBleHBvcnRzLmlzU2lnbmVkKSh0eXBlKSkge1xuICAgICAgICAvLyBTaWduZWQgdHlwZXMgbXVzdCBiZSBpbiB0aGUgcmFuZ2Ugb2YgYC0oMl4obGVuZ3RoIC0gMSkpYCB0b1xuICAgICAgICAvLyBgMl4obGVuZ3RoIC0gMSkgLSAxYC5cbiAgICAgICAgKDAsIHV0aWxzXzEuYXNzZXJ0KSh2YWx1ZSA+PSAtKG1heFZhbHVlICsgQmlnSW50KDEpKSAmJiB2YWx1ZSA8PSBtYXhWYWx1ZSwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBOdW1iZXIgXCIke3ZhbHVlfVwiIGlzIG91dCBvZiByYW5nZSBmb3IgdHlwZSBcIiR7dHlwZX1cIi5gKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVW5zaWduZWQgdHlwZXMgbXVzdCBiZSBpbiB0aGUgcmFuZ2Ugb2YgYDBgIHRvIGAyXmxlbmd0aCAtIDFgLlxuICAgICgwLCB1dGlsc18xLmFzc2VydCkodmFsdWUgPD0gbWF4VmFsdWUsIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgTnVtYmVyIFwiJHt2YWx1ZX1cIiBpcyBvdXQgb2YgcmFuZ2UgZm9yIHR5cGUgXCIke3R5cGV9XCIuYCkpO1xufTtcbmV4cG9ydHMuYXNzZXJ0TnVtYmVyTGVuZ3RoID0gYXNzZXJ0TnVtYmVyTGVuZ3RoO1xuLyoqXG4gKiBOb3JtYWxpemUgYSBgYmlnaW50YCB2YWx1ZS4gVGhpcyBhY2NlcHRzIHRoZSB2YWx1ZSBhczpcbiAqXG4gKiAtIEEgYGJpZ2ludGAuXG4gKiAtIEEgYG51bWJlcmAuXG4gKiAtIEEgZGVjaW1hbCBzdHJpbmcsIGkuZS4sIGEgc3RyaW5nIHRoYXQgZG9lcyBub3Qgc3RhcnQgd2l0aCBcIjB4XCIuXG4gKiAtIEEgaGV4YWRlY2ltYWwgc3RyaW5nLCBpLmUuLCBhIHN0cmluZyB0aGF0IHN0YXJ0cyB3aXRoIFwiMHhcIi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyLWxpa2UgdmFsdWUgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgcGFyc2VkIGFzIGJpZ2ludC5cbiAqL1xuY29uc3QgZ2V0QmlnSW50ID0gKHZhbHVlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNyZWF0ZUJpZ0ludCkodmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCBudW1iZXIuIEV4cGVjdGVkIGEgdmFsaWQgbnVtYmVyIHZhbHVlLCBidXQgcmVjZWl2ZWQgXCIke3ZhbHVlfVwiLmApO1xuICAgIH1cbn07XG5leHBvcnRzLmdldEJpZ0ludCA9IGdldEJpZ0ludDtcbmV4cG9ydHMubnVtYmVyID0ge1xuICAgIGlzRHluYW1pYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0eXBlIGlzIGEgbnVtYmVyIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHR5cGUgaXMgYSBudW1iZXIgdHlwZS5cbiAgICAgKi9cbiAgICBpc1R5cGUodHlwZSkge1xuICAgICAgICByZXR1cm4gTlVNQkVSX1JFR0VYLnRlc3QodHlwZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIGVuY29kZWQgbnVtYmVyIHR5cGUuIFNpbmNlIGBpbnRgIGFuZCBgdWludGAgYXJlXG4gICAgICogc2ltcGxlIHR5cGVzLCB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiAzMi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlIGxlbmd0aCBvZiB0aGUgdHlwZS5cbiAgICAgKi9cbiAgICBnZXRCeXRlTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gMzI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmNvZGUgYSBudW1iZXIgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSBhcmdzLnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUuXG4gICAgICogQHBhcmFtIGFyZ3MuYnVmZmVyIC0gVGhlIGJ5dGUgYXJyYXkgdG8gYWRkIHRvLlxuICAgICAqIEBwYXJhbSBhcmdzLnZhbHVlIC0gVGhlIHZhbHVlIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gYXJncy5wYWNrZWQgLSBXaGV0aGVyIHRvIHVzZSBwYWNrZWQgZW5jb2RpbmcuXG4gICAgICogQHJldHVybnMgVGhlIGJ5dGVzIHdpdGggdGhlIGVuY29kZWQgdmFsdWUgYWRkZWQgdG8gaXQuXG4gICAgICovXG4gICAgZW5jb2RlKHsgdHlwZSwgYnVmZmVyLCB2YWx1ZSwgcGFja2VkIH0pIHtcbiAgICAgICAgY29uc3QgYmlnSW50VmFsdWUgPSAoMCwgZXhwb3J0cy5nZXRCaWdJbnQpKHZhbHVlKTtcbiAgICAgICAgKDAsIGV4cG9ydHMuYXNzZXJ0TnVtYmVyTGVuZ3RoKShiaWdJbnRWYWx1ZSwgdHlwZSk7XG4gICAgICAgIGlmICgoMCwgZXhwb3J0cy5pc1NpZ25lZCkodHlwZSkpIHtcbiAgICAgICAgICAgIC8vIEZvciBwYWNrZWQgZW5jb2RpbmcsIHRoZSB2YWx1ZSBpcyBwYWRkZWQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgdHlwZSwgYW5kXG4gICAgICAgICAgICAvLyB0aGVuIGFkZGVkIHRvIHRoZSBieXRlIGFycmF5LlxuICAgICAgICAgICAgaWYgKHBhY2tlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9ICgwLCBleHBvcnRzLmdldExlbmd0aCkodHlwZSkgLyA4O1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW2J1ZmZlciwgKDAsIHV0aWxzXzEuc2lnbmVkQmlnSW50VG9CeXRlcykoYmlnSW50VmFsdWUsIGxlbmd0aCldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW1xuICAgICAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMi5wYWRTdGFydCkoKDAsIHV0aWxzXzEuc2lnbmVkQmlnSW50VG9CeXRlcykoYmlnSW50VmFsdWUsIDMyKSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgcGFja2VkIGVuY29kaW5nLCB0aGUgdmFsdWUgaXMgcGFkZGVkIHRvIHRoZSBsZW5ndGggb2YgdGhlIHR5cGUsIGFuZFxuICAgICAgICAvLyB0aGVuIGFkZGVkIHRvIHRoZSBieXRlIGFycmF5LlxuICAgICAgICBpZiAocGFja2VkKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSAoMCwgZXhwb3J0cy5nZXRMZW5ndGgpKHR5cGUpIC8gODtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW1xuICAgICAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMi5wYWRTdGFydCkoKDAsIHV0aWxzXzEuYmlnSW50VG9CeXRlcykoYmlnSW50VmFsdWUpLCBsZW5ndGgpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbYnVmZmVyLCAoMCwgdXRpbHNfMi5wYWRTdGFydCkoKDAsIHV0aWxzXzEuYmlnSW50VG9CeXRlcykoYmlnSW50VmFsdWUpKV0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGEgbnVtYmVyIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZGVjb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUuXG4gICAgICogQHBhcmFtIGFyZ3MudmFsdWUgLSBUaGUgdmFsdWUgdG8gZGVjb2RlLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZSh7IHR5cGUsIHZhbHVlIH0pIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdmFsdWUuc3ViYXJyYXkoMCwgMzIpO1xuICAgICAgICBpZiAoKDAsIGV4cG9ydHMuaXNTaWduZWQpKHR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBudW1iZXJWYWx1ZSA9ICgwLCB1dGlsc18xLmJ5dGVzVG9TaWduZWRCaWdJbnQpKGJ1ZmZlcik7XG4gICAgICAgICAgICAoMCwgZXhwb3J0cy5hc3NlcnROdW1iZXJMZW5ndGgpKG51bWJlclZhbHVlLCB0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW1iZXJWYWx1ZSA9ICgwLCB1dGlsc18xLmJ5dGVzVG9CaWdJbnQpKGJ1ZmZlcik7XG4gICAgICAgICgwLCBleHBvcnRzLmFzc2VydE51bWJlckxlbmd0aCkobnVtYmVyVmFsdWUsIHR5cGUpO1xuICAgICAgICByZXR1cm4gbnVtYmVyVmFsdWU7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/parser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/parser.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL3BhcnNlci5qcz83YWZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/string.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/string.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.string = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/bytes.js\");\nexports.string = {\n    isDynamic: true,\n    /**\n     * Check if a type is a string type. Since `string` is a simple type, this\n     * is just a check if the type is \"string\".\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a string type.\n     */\n    isType: (type) => type === 'string',\n    /**\n     * Get the byte length of an encoded string type. Since `string` is a simple\n     * type, this will always return 32.\n     *\n     * Note that actual strings are variable in length, but the encoded static\n     * value (pointer) is always 32 bytes long.\n     *\n     * @returns The byte length of an encoded string.\n     */\n    getByteLength() {\n        return 32;\n    },\n    /**\n     * Encode the given string value to a byte array.\n     *\n     * @param args - The encoding arguments.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The string value to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @param args.tight - Whether to use non-standard tight encoding.\n     * @returns The bytes with the encoded string value added to it.\n     */\n    encode({ buffer, value, packed, tight }) {\n        // Strings are encoded as UTF-8 bytes, so we use the bytes parser to encode\n        // the string as bytes.\n        return bytes_1.bytes.encode({\n            type: 'bytes',\n            buffer,\n            value: (0, utils_1.stringToBytes)(value),\n            packed,\n            tight,\n        });\n    },\n    /**\n     * Decode the given byte array to a string value.\n     *\n     * @param args - The decoding arguments.\n     * @returns The decoded string value.\n     */\n    decode(args) {\n        // Strings are encoded as UTF-8 bytes, so we use the bytes parser to decode\n        // the bytes, and convert them to a string.\n        return (0, utils_1.bytesToString)(bytes_1.bytes.decode(args));\n    },\n};\n//# sourceMappingURL=string.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvc3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxnQkFBZ0IsbUJBQU8sQ0FBQyw2R0FBaUI7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQVM7QUFDakMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhCQUE4QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL3N0cmluZy5qcz9hMTliIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJpbmcgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbmV4cG9ydHMuc3RyaW5nID0ge1xuICAgIGlzRHluYW1pYzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHR5cGUgaXMgYSBzdHJpbmcgdHlwZS4gU2luY2UgYHN0cmluZ2AgaXMgYSBzaW1wbGUgdHlwZSwgdGhpc1xuICAgICAqIGlzIGp1c3QgYSBjaGVjayBpZiB0aGUgdHlwZSBpcyBcInN0cmluZ1wiLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0eXBlIGlzIGEgc3RyaW5nIHR5cGUuXG4gICAgICovXG4gICAgaXNUeXBlOiAodHlwZSkgPT4gdHlwZSA9PT0gJ3N0cmluZycsXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBieXRlIGxlbmd0aCBvZiBhbiBlbmNvZGVkIHN0cmluZyB0eXBlLiBTaW5jZSBgc3RyaW5nYCBpcyBhIHNpbXBsZVxuICAgICAqIHR5cGUsIHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIDMyLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGFjdHVhbCBzdHJpbmdzIGFyZSB2YXJpYWJsZSBpbiBsZW5ndGgsIGJ1dCB0aGUgZW5jb2RlZCBzdGF0aWNcbiAgICAgKiB2YWx1ZSAocG9pbnRlcikgaXMgYWx3YXlzIDMyIGJ5dGVzIGxvbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYnl0ZSBsZW5ndGggb2YgYW4gZW5jb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZ2V0Qnl0ZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIDMyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5jb2RlIHRoZSBnaXZlbiBzdHJpbmcgdmFsdWUgdG8gYSBieXRlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZW5jb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLmJ1ZmZlciAtIFRoZSBieXRlIGFycmF5IHRvIGFkZCB0by5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSBzdHJpbmcgdmFsdWUgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSBhcmdzLnBhY2tlZCAtIFdoZXRoZXIgdG8gdXNlIHBhY2tlZCBlbmNvZGluZy5cbiAgICAgKiBAcGFyYW0gYXJncy50aWdodCAtIFdoZXRoZXIgdG8gdXNlIG5vbi1zdGFuZGFyZCB0aWdodCBlbmNvZGluZy5cbiAgICAgKiBAcmV0dXJucyBUaGUgYnl0ZXMgd2l0aCB0aGUgZW5jb2RlZCBzdHJpbmcgdmFsdWUgYWRkZWQgdG8gaXQuXG4gICAgICovXG4gICAgZW5jb2RlKHsgYnVmZmVyLCB2YWx1ZSwgcGFja2VkLCB0aWdodCB9KSB7XG4gICAgICAgIC8vIFN0cmluZ3MgYXJlIGVuY29kZWQgYXMgVVRGLTggYnl0ZXMsIHNvIHdlIHVzZSB0aGUgYnl0ZXMgcGFyc2VyIHRvIGVuY29kZVxuICAgICAgICAvLyB0aGUgc3RyaW5nIGFzIGJ5dGVzLlxuICAgICAgICByZXR1cm4gYnl0ZXNfMS5ieXRlcy5lbmNvZGUoe1xuICAgICAgICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgIHZhbHVlOiAoMCwgdXRpbHNfMS5zdHJpbmdUb0J5dGVzKSh2YWx1ZSksXG4gICAgICAgICAgICBwYWNrZWQsXG4gICAgICAgICAgICB0aWdodCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWNvZGUgdGhlIGdpdmVuIGJ5dGUgYXJyYXkgdG8gYSBzdHJpbmcgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBkZWNvZGluZyBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMgVGhlIGRlY29kZWQgc3RyaW5nIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZShhcmdzKSB7XG4gICAgICAgIC8vIFN0cmluZ3MgYXJlIGVuY29kZWQgYXMgVVRGLTggYnl0ZXMsIHNvIHdlIHVzZSB0aGUgYnl0ZXMgcGFyc2VyIHRvIGRlY29kZVxuICAgICAgICAvLyB0aGUgYnl0ZXMsIGFuZCBjb252ZXJ0IHRoZW0gdG8gYSBzdHJpbmcuXG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5ieXRlc1RvU3RyaW5nKShieXRlc18xLmJ5dGVzLmRlY29kZShhcmdzKSk7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/tuple.js":
/*!****************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/tuple.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tuple = exports.getTupleElements = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst packer_1 = __webpack_require__(/*! ../packer */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/packer.js\");\nconst TUPLE_REGEX = /^\\((.+)\\)$/u;\nconst isTupleType = (type) => TUPLE_REGEX.test(type);\n/**\n * Get elements from a tuple type.\n *\n * @param type - The tuple type to get the types for.\n * @returns The elements of the tuple as string array.\n */\nconst getTupleElements = (type) => {\n    (0, utils_1.assert)(type.startsWith('(') && type.endsWith(')'), new errors_1.ParserError(`Invalid tuple type. Expected tuple type, but received \"${type}\".`));\n    const elements = [];\n    let current = '';\n    let depth = 0;\n    for (let i = 1; i < type.length - 1; i++) {\n        const char = type[i];\n        if (char === ',' && depth === 0) {\n            elements.push(current.trim());\n            current = '';\n        }\n        else {\n            current += char;\n            if (char === '(') {\n                depth += 1;\n            }\n            else if (char === ')') {\n                depth -= 1;\n            }\n        }\n    }\n    if (current.trim()) {\n        elements.push(current.trim());\n    }\n    return elements;\n};\nexports.getTupleElements = getTupleElements;\nexports.tuple = {\n    /**\n     * Check if the tuple is dynamic. Tuples are dynamic if one or more elements\n     * of the tuple are dynamic.\n     *\n     * @param type - The type to check.\n     * @returns Whether the tuple is dynamic.\n     */\n    isDynamic(type) {\n        const elements = (0, exports.getTupleElements)(type);\n        return elements.some((element) => {\n            const parser = (0, packer_1.getParser)(element);\n            return (0, packer_1.isDynamicParser)(parser, element);\n        });\n    },\n    /**\n     * Check if a type is a tuple type.\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a tuple type.\n     */\n    isType(type) {\n        return isTupleType(type);\n    },\n    /**\n     * Get the byte length of a tuple type. If the tuple is dynamic, this will\n     * always return 32. If the tuple is static, this will return the sum of the\n     * byte lengths of the tuple elements.\n     *\n     * @param type - The type to get the byte length for.\n     * @returns The byte length of the tuple type.\n     */\n    getByteLength(type) {\n        if ((0, packer_1.isDynamicParser)(this, type)) {\n            return 32;\n        }\n        const elements = (0, exports.getTupleElements)(type);\n        return elements.reduce((total, element) => {\n            return total + (0, packer_1.getParser)(element).getByteLength(element);\n        }, 0);\n    },\n    /**\n     * Encode a tuple value.\n     *\n     * @param args - The encoding arguments.\n     * @param args.type - The type of the value.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The value to encode.\n     * @param args.packed - Whether to use non-standard packed encoding.\n     * @param args.tight - Whether to use non-standard tight encoding.\n     * @returns The bytes with the encoded value added to it.\n     */\n    encode({ type, buffer, value, packed, tight }) {\n        const elements = (0, exports.getTupleElements)(type);\n        return (0, packer_1.pack)({\n            types: elements,\n            values: value,\n            byteArray: buffer,\n            packed,\n            tight,\n        });\n    },\n    /**\n     * Decode a tuple value.\n     *\n     * @param args - The decoding arguments.\n     * @param args.type - The type of the value.\n     * @param args.value - The value to decode.\n     * @param args.skip - A function to skip a number of bytes.\n     * @returns The decoded value.\n     */\n    decode({ type, value, skip }) {\n        const elements = (0, exports.getTupleElements)(type);\n        const length = this.getByteLength(type) - 32;\n        skip(length);\n        return (0, packer_1.unpack)(elements, value);\n    },\n};\n//# sourceMappingURL=tuple.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvdHVwbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLHdCQUF3QjtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyw2R0FBaUI7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsMEVBQVc7QUFDcEMsaUJBQWlCLG1CQUFPLENBQUMsMEVBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKLEtBQUs7QUFDNUo7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQ0FBb0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvdHVwbGUuanM/MjNjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHVwbGUgPSBleHBvcnRzLmdldFR1cGxlRWxlbWVudHMgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHBhY2tlcl8xID0gcmVxdWlyZShcIi4uL3BhY2tlclwiKTtcbmNvbnN0IFRVUExFX1JFR0VYID0gL15cXCgoLispXFwpJC91O1xuY29uc3QgaXNUdXBsZVR5cGUgPSAodHlwZSkgPT4gVFVQTEVfUkVHRVgudGVzdCh0eXBlKTtcbi8qKlxuICogR2V0IGVsZW1lbnRzIGZyb20gYSB0dXBsZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR1cGxlIHR5cGUgdG8gZ2V0IHRoZSB0eXBlcyBmb3IuXG4gKiBAcmV0dXJucyBUaGUgZWxlbWVudHMgb2YgdGhlIHR1cGxlIGFzIHN0cmluZyBhcnJheS5cbiAqL1xuY29uc3QgZ2V0VHVwbGVFbGVtZW50cyA9ICh0eXBlKSA9PiB7XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KSh0eXBlLnN0YXJ0c1dpdGgoJygnKSAmJiB0eXBlLmVuZHNXaXRoKCcpJyksIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCB0dXBsZSB0eXBlLiBFeHBlY3RlZCB0dXBsZSB0eXBlLCBidXQgcmVjZWl2ZWQgXCIke3R5cGV9XCIuYCkpO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgbGV0IGN1cnJlbnQgPSAnJztcbiAgICBsZXQgZGVwdGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdHlwZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHR5cGVbaV07XG4gICAgICAgIGlmIChjaGFyID09PSAnLCcgJiYgZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goY3VycmVudC50cmltKCkpO1xuICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudCArPSBjaGFyO1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICcoJykge1xuICAgICAgICAgICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICBkZXB0aCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50LnRyaW0oKSkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKGN1cnJlbnQudHJpbSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xufTtcbmV4cG9ydHMuZ2V0VHVwbGVFbGVtZW50cyA9IGdldFR1cGxlRWxlbWVudHM7XG5leHBvcnRzLnR1cGxlID0ge1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSB0dXBsZSBpcyBkeW5hbWljLiBUdXBsZXMgYXJlIGR5bmFtaWMgaWYgb25lIG9yIG1vcmUgZWxlbWVudHNcbiAgICAgKiBvZiB0aGUgdHVwbGUgYXJlIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHR1cGxlIGlzIGR5bmFtaWMuXG4gICAgICovXG4gICAgaXNEeW5hbWljKHR5cGUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSAoMCwgZXhwb3J0cy5nZXRUdXBsZUVsZW1lbnRzKSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzLnNvbWUoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9ICgwLCBwYWNrZXJfMS5nZXRQYXJzZXIpKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBwYWNrZXJfMS5pc0R5bmFtaWNQYXJzZXIpKHBhcnNlciwgZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0eXBlIGlzIGEgdHVwbGUgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgdHlwZSBpcyBhIHR1cGxlIHR5cGUuXG4gICAgICovXG4gICAgaXNUeXBlKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGlzVHVwbGVUeXBlKHR5cGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBieXRlIGxlbmd0aCBvZiBhIHR1cGxlIHR5cGUuIElmIHRoZSB0dXBsZSBpcyBkeW5hbWljLCB0aGlzIHdpbGxcbiAgICAgKiBhbHdheXMgcmV0dXJuIDMyLiBJZiB0aGUgdHVwbGUgaXMgc3RhdGljLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBzdW0gb2YgdGhlXG4gICAgICogYnl0ZSBsZW5ndGhzIG9mIHRoZSB0dXBsZSBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gZ2V0IHRoZSBieXRlIGxlbmd0aCBmb3IuXG4gICAgICogQHJldHVybnMgVGhlIGJ5dGUgbGVuZ3RoIG9mIHRoZSB0dXBsZSB0eXBlLlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgodHlwZSkge1xuICAgICAgICBpZiAoKDAsIHBhY2tlcl8xLmlzRHluYW1pY1BhcnNlcikodGhpcywgdHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9ICgwLCBleHBvcnRzLmdldFR1cGxlRWxlbWVudHMpKHR5cGUpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKCh0b3RhbCwgZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgKDAsIHBhY2tlcl8xLmdldFBhcnNlcikoZWxlbWVudCkuZ2V0Qnl0ZUxlbmd0aChlbGVtZW50KTtcbiAgICAgICAgfSwgMCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmNvZGUgYSB0dXBsZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGVuY29kaW5nIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gYXJncy50eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlLlxuICAgICAqIEBwYXJhbSBhcmdzLmJ1ZmZlciAtIFRoZSBieXRlIGFycmF5IHRvIGFkZCB0by5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MucGFja2VkIC0gV2hldGhlciB0byB1c2Ugbm9uLXN0YW5kYXJkIHBhY2tlZCBlbmNvZGluZy5cbiAgICAgKiBAcGFyYW0gYXJncy50aWdodCAtIFdoZXRoZXIgdG8gdXNlIG5vbi1zdGFuZGFyZCB0aWdodCBlbmNvZGluZy5cbiAgICAgKiBAcmV0dXJucyBUaGUgYnl0ZXMgd2l0aCB0aGUgZW5jb2RlZCB2YWx1ZSBhZGRlZCB0byBpdC5cbiAgICAgKi9cbiAgICBlbmNvZGUoeyB0eXBlLCBidWZmZXIsIHZhbHVlLCBwYWNrZWQsIHRpZ2h0IH0pIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSAoMCwgZXhwb3J0cy5nZXRUdXBsZUVsZW1lbnRzKSh0eXBlKTtcbiAgICAgICAgcmV0dXJuICgwLCBwYWNrZXJfMS5wYWNrKSh7XG4gICAgICAgICAgICB0eXBlczogZWxlbWVudHMsXG4gICAgICAgICAgICB2YWx1ZXM6IHZhbHVlLFxuICAgICAgICAgICAgYnl0ZUFycmF5OiBidWZmZXIsXG4gICAgICAgICAgICBwYWNrZWQsXG4gICAgICAgICAgICB0aWdodCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYSB0dXBsZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGRlY29kaW5nIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gYXJncy50eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlLlxuICAgICAqIEBwYXJhbSBhcmdzLnZhbHVlIC0gVGhlIHZhbHVlIHRvIGRlY29kZS5cbiAgICAgKiBAcGFyYW0gYXJncy5za2lwIC0gQSBmdW5jdGlvbiB0byBza2lwIGEgbnVtYmVyIG9mIGJ5dGVzLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZSh7IHR5cGUsIHZhbHVlLCBza2lwIH0pIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSAoMCwgZXhwb3J0cy5nZXRUdXBsZUVsZW1lbnRzKSh0eXBlKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5nZXRCeXRlTGVuZ3RoKHR5cGUpIC0gMzI7XG4gICAgICAgIHNraXAobGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuICgwLCBwYWNrZXJfMS51bnBhY2spKGVsZW1lbnRzLCB2YWx1ZSk7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dXBsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/tuple.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/types/abi.js":
/*!************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/types/abi.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=abi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3R5cGVzL2FiaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvdHlwZXMvYWJpLmpzP2E2MmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/types/abi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/types/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/types/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./abi */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/types/abi.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3R5cGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyx5RUFBTztBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvdHlwZXMvaW5kZXguanM/Yzg3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FiaVwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/types/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/utils/buffer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/utils/buffer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.padEnd = exports.padStart = exports.set = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs\");\nconst BUFFER_WIDTH = 32;\n/**\n * Set `buffer` in `target` at the specified position.\n *\n * @param target - The buffer to set to.\n * @param buffer - The buffer to set in the target.\n * @param position - The position at which to set the target.\n * @returns The combined buffer.\n */\nconst set = (target, buffer, position) => {\n    return (0, utils_1.concatBytes)([\n        target.subarray(0, position),\n        buffer,\n        target.subarray(position + buffer.length),\n    ]);\n};\nexports.set = set;\n/**\n * Add padding to a buffer. If the buffer is larger than `length`, this function won't do anything. If it's smaller, the\n * buffer will be padded to the specified length, with extra zeroes at the start.\n *\n * @param buffer - The buffer to add padding to.\n * @param length - The number of bytes to pad the buffer to.\n * @returns The padded buffer.\n */\nconst padStart = (buffer, length = BUFFER_WIDTH) => {\n    const padding = new Uint8Array(Math.max(length - buffer.length, 0)).fill(0x00);\n    return (0, utils_1.concatBytes)([padding, buffer]);\n};\nexports.padStart = padStart;\n/**\n * Add padding to a buffer. If the buffer is larger than `length`, this function won't do anything. If it's smaller, the\n * buffer will be padded to the specified length, with extra zeroes at the end.\n *\n * @param buffer - The buffer to add padding to.\n * @param length - The number of bytes to pad the buffer to.\n * @returns The padded buffer.\n */\nconst padEnd = (buffer, length = BUFFER_WIDTH) => {\n    const padding = new Uint8Array(Math.max(length - buffer.length, 0)).fill(0x00);\n    return (0, utils_1.concatBytes)([buffer, padding]);\n};\nexports.padEnd = padEnd;\n//# sourceMappingURL=buffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3V0aWxzL2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsZ0JBQWdCLEdBQUcsV0FBVztBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQyw2R0FBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvdXRpbHMvYnVmZmVyLmpzPzVjMWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhZEVuZCA9IGV4cG9ydHMucGFkU3RhcnQgPSBleHBvcnRzLnNldCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3QgQlVGRkVSX1dJRFRIID0gMzI7XG4vKipcbiAqIFNldCBgYnVmZmVyYCBpbiBgdGFyZ2V0YCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgYnVmZmVyIHRvIHNldCB0by5cbiAqIEBwYXJhbSBidWZmZXIgLSBUaGUgYnVmZmVyIHRvIHNldCBpbiB0aGUgdGFyZ2V0LlxuICogQHBhcmFtIHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRvIHNldCB0aGUgdGFyZ2V0LlxuICogQHJldHVybnMgVGhlIGNvbWJpbmVkIGJ1ZmZlci5cbiAqL1xuY29uc3Qgc2V0ID0gKHRhcmdldCwgYnVmZmVyLCBwb3NpdGlvbikgPT4ge1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW1xuICAgICAgICB0YXJnZXQuc3ViYXJyYXkoMCwgcG9zaXRpb24pLFxuICAgICAgICBidWZmZXIsXG4gICAgICAgIHRhcmdldC5zdWJhcnJheShwb3NpdGlvbiArIGJ1ZmZlci5sZW5ndGgpLFxuICAgIF0pO1xufTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuLyoqXG4gKiBBZGQgcGFkZGluZyB0byBhIGJ1ZmZlci4gSWYgdGhlIGJ1ZmZlciBpcyBsYXJnZXIgdGhhbiBgbGVuZ3RoYCwgdGhpcyBmdW5jdGlvbiB3b24ndCBkbyBhbnl0aGluZy4gSWYgaXQncyBzbWFsbGVyLCB0aGVcbiAqIGJ1ZmZlciB3aWxsIGJlIHBhZGRlZCB0byB0aGUgc3BlY2lmaWVkIGxlbmd0aCwgd2l0aCBleHRyYSB6ZXJvZXMgYXQgdGhlIHN0YXJ0LlxuICpcbiAqIEBwYXJhbSBidWZmZXIgLSBUaGUgYnVmZmVyIHRvIGFkZCBwYWRkaW5nIHRvLlxuICogQHBhcmFtIGxlbmd0aCAtIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcGFkIHRoZSBidWZmZXIgdG8uXG4gKiBAcmV0dXJucyBUaGUgcGFkZGVkIGJ1ZmZlci5cbiAqL1xuY29uc3QgcGFkU3RhcnQgPSAoYnVmZmVyLCBsZW5ndGggPSBCVUZGRVJfV0lEVEgpID0+IHtcbiAgICBjb25zdCBwYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5tYXgobGVuZ3RoIC0gYnVmZmVyLmxlbmd0aCwgMCkpLmZpbGwoMHgwMCk7XG4gICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbcGFkZGluZywgYnVmZmVyXSk7XG59O1xuZXhwb3J0cy5wYWRTdGFydCA9IHBhZFN0YXJ0O1xuLyoqXG4gKiBBZGQgcGFkZGluZyB0byBhIGJ1ZmZlci4gSWYgdGhlIGJ1ZmZlciBpcyBsYXJnZXIgdGhhbiBgbGVuZ3RoYCwgdGhpcyBmdW5jdGlvbiB3b24ndCBkbyBhbnl0aGluZy4gSWYgaXQncyBzbWFsbGVyLCB0aGVcbiAqIGJ1ZmZlciB3aWxsIGJlIHBhZGRlZCB0byB0aGUgc3BlY2lmaWVkIGxlbmd0aCwgd2l0aCBleHRyYSB6ZXJvZXMgYXQgdGhlIGVuZC5cbiAqXG4gKiBAcGFyYW0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB0byBhZGQgcGFkZGluZyB0by5cbiAqIEBwYXJhbSBsZW5ndGggLSBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHBhZCB0aGUgYnVmZmVyIHRvLlxuICogQHJldHVybnMgVGhlIHBhZGRlZCBidWZmZXIuXG4gKi9cbmNvbnN0IHBhZEVuZCA9IChidWZmZXIsIGxlbmd0aCA9IEJVRkZFUl9XSURUSCkgPT4ge1xuICAgIGNvbnN0IHBhZGRpbmcgPSBuZXcgVWludDhBcnJheShNYXRoLm1heChsZW5ndGggLSBidWZmZXIubGVuZ3RoLCAwKSkuZmlsbCgweDAwKTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKFtidWZmZXIsIHBhZGRpbmddKTtcbn07XG5leHBvcnRzLnBhZEVuZCA9IHBhZEVuZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/utils/buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/utils/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./buffer */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/utils/buffer.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3V0aWxzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQywrRUFBVTtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvdXRpbHMvaW5kZXguanM/NmU0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J1ZmZlclwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/eth-sig-util/dist/encryption.js":
/*!****************************************************************!*\
  !*** ./node_modules/@metamask/eth-sig-util/dist/encryption.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;\nconst base_1 = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/index.js\");\nconst nacl = __importStar(__webpack_require__(/*! tweetnacl */ \"(ssr)/./node_modules/tweetnacl/nacl-fast.js\"));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@metamask/eth-sig-util/dist/utils.js\");\n/**\n * Encrypt a message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nfunction encrypt({ publicKey, data, version, }) {\n    if ((0, utils_1.isNullish)(publicKey)) {\n        throw new Error('Missing publicKey parameter');\n    }\n    else if ((0, utils_1.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_1.isNullish)(version)) {\n        throw new Error('Missing version parameter');\n    }\n    switch (version) {\n        case 'x25519-xsalsa20-poly1305': {\n            if (typeof data !== 'string') {\n                throw new Error('Message data must be given as a string');\n            }\n            // generate ephemeral keypair\n            const ephemeralKeyPair = nacl.box.keyPair();\n            // assemble encryption parameters - from string to UInt8\n            let pubKeyUInt8Array;\n            try {\n                pubKeyUInt8Array = base_1.base64.decode(publicKey);\n            }\n            catch (err) {\n                throw new Error('Bad public key');\n            }\n            const msgParamsUInt8Array = base_1.utf8.decode(data);\n            const nonce = nacl.randomBytes(nacl.box.nonceLength);\n            // encrypt\n            const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);\n            // handle encrypted data\n            const output = {\n                version: 'x25519-xsalsa20-poly1305',\n                nonce: base_1.base64.encode(nonce),\n                ephemPublicKey: base_1.base64.encode(ephemeralKeyPair.publicKey),\n                ciphertext: base_1.base64.encode(encryptedMessage),\n            };\n            // return encrypted msg data\n            return output;\n        }\n        default:\n            throw new Error('Encryption type/version not supported');\n    }\n}\nexports.encrypt = encrypt;\n/**\n * Encrypt a message in a way that obscures the message length.\n *\n * The message is padded to a multiple of 2048 before being encrypted so that the length of the\n * resulting encrypted message can't be used to guess the exact length of the original message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nfunction encryptSafely({ publicKey, data, version, }) {\n    if ((0, utils_1.isNullish)(publicKey)) {\n        throw new Error('Missing publicKey parameter');\n    }\n    else if ((0, utils_1.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_1.isNullish)(version)) {\n        throw new Error('Missing version parameter');\n    }\n    const DEFAULT_PADDING_LENGTH = 2 ** 11;\n    const NACL_EXTRA_BYTES = 16;\n    if (typeof data === 'object' && data && 'toJSON' in data) {\n        // remove toJSON attack vector\n        // TODO, check all possible children\n        throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');\n    }\n    // add padding\n    const dataWithPadding = {\n        data,\n        padding: '',\n    };\n    // calculate padding\n    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');\n    const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n    let padLength = 0;\n    // Only pad if necessary\n    if (modVal > 0) {\n        padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n    }\n    dataWithPadding.padding = '0'.repeat(padLength);\n    const paddedMessage = JSON.stringify(dataWithPadding);\n    return encrypt({ publicKey, data: paddedMessage, version });\n}\nexports.encryptSafely = encryptSafely;\n/**\n * Decrypt a message.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nfunction decrypt({ encryptedData, privateKey, }) {\n    if ((0, utils_1.isNullish)(encryptedData)) {\n        throw new Error('Missing encryptedData parameter');\n    }\n    else if ((0, utils_1.isNullish)(privateKey)) {\n        throw new Error('Missing privateKey parameter');\n    }\n    switch (encryptedData.version) {\n        case 'x25519-xsalsa20-poly1305': {\n            const receiverPrivateKeyUint8Array = Buffer.from(privateKey, 'hex');\n            const receiverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(receiverPrivateKeyUint8Array).secretKey;\n            // assemble decryption parameters\n            const nonce = base_1.base64.decode(encryptedData.nonce);\n            const ciphertext = base_1.base64.decode(encryptedData.ciphertext);\n            const ephemPublicKey = base_1.base64.decode(encryptedData.ephemPublicKey);\n            // decrypt\n            const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, receiverEncryptionPrivateKey);\n            // return decrypted msg data\n            try {\n                if (!decryptedMessage) {\n                    throw new Error();\n                }\n                const output = base_1.utf8.encode(decryptedMessage);\n                // TODO: This is probably extraneous but was kept to minimize changes during refactor\n                if (!output) {\n                    throw new Error();\n                }\n                return output;\n            }\n            catch (err) {\n                if (err && typeof err.message === 'string' && err.message.length) {\n                    throw new Error(`Decryption failed: ${err.message}`);\n                }\n                throw new Error(`Decryption failed.`);\n            }\n        }\n        default:\n            throw new Error('Encryption type/version not supported.');\n    }\n}\nexports.decrypt = decrypt;\n/**\n * Decrypt a message that has been encrypted using `encryptSafely`.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nfunction decryptSafely({ encryptedData, privateKey, }) {\n    if ((0, utils_1.isNullish)(encryptedData)) {\n        throw new Error('Missing encryptedData parameter');\n    }\n    else if ((0, utils_1.isNullish)(privateKey)) {\n        throw new Error('Missing privateKey parameter');\n    }\n    const dataWithPadding = JSON.parse(decrypt({ encryptedData, privateKey }));\n    return dataWithPadding.data;\n}\nexports.decryptSafely = decryptSafely;\n/**\n * Get the encryption public key for the given key.\n *\n * @param privateKey - The private key to generate the encryption public key with.\n * @returns The encryption public key.\n */\nfunction getEncryptionPublicKey(privateKey) {\n    const privateKeyUint8Array = Buffer.from(privateKey, 'hex');\n    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n    return base_1.base64.encode(encryptionPublicKey);\n}\nexports.getEncryptionPublicKey = getEncryptionPublicKey;\n//# sourceMappingURL=encryption.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L2VuY3J5cHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLHFCQUFxQixHQUFHLGVBQWUsR0FBRyxxQkFBcUIsR0FBRyxlQUFlO0FBQ2xILGVBQWUsbUJBQU8sQ0FBQyxrRUFBYTtBQUNwQywwQkFBMEIsbUJBQU8sQ0FBQyw4REFBVztBQUM3QyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUNBQXlDO0FBQzlEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxZQUFZO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0QkFBNEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDJCQUEyQjtBQUM1RTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L2VuY3J5cHRpb24uanM/MDMwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFbmNyeXB0aW9uUHVibGljS2V5ID0gZXhwb3J0cy5kZWNyeXB0U2FmZWx5ID0gZXhwb3J0cy5kZWNyeXB0ID0gZXhwb3J0cy5lbmNyeXB0U2FmZWx5ID0gZXhwb3J0cy5lbmNyeXB0ID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIkBzY3VyZS9iYXNlXCIpO1xuY29uc3QgbmFjbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwidHdlZXRuYWNsXCIpKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogRW5jcnlwdCBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgZW5jcnlwdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMucHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgb2YgdGhlIG1lc3NhZ2UgcmVjaXBpZW50LlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSBtZXNzYWdlIGRhdGEuXG4gKiBAcGFyYW0gb3B0aW9ucy52ZXJzaW9uIC0gVGhlIHR5cGUgb2YgZW5jcnlwdGlvbiB0byB1c2UuXG4gKiBAcmV0dXJucyBUaGUgZW5jcnlwdGVkIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGVuY3J5cHQoeyBwdWJsaWNLZXksIGRhdGEsIHZlcnNpb24sIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShwdWJsaWNLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwdWJsaWNLZXkgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkodmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHZlcnNpb24gcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgICBjYXNlICd4MjU1MTkteHNhbHNhMjAtcG9seTEzMDUnOiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlIGRhdGEgbXVzdCBiZSBnaXZlbiBhcyBhIHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgZXBoZW1lcmFsIGtleXBhaXJcbiAgICAgICAgICAgIGNvbnN0IGVwaGVtZXJhbEtleVBhaXIgPSBuYWNsLmJveC5rZXlQYWlyKCk7XG4gICAgICAgICAgICAvLyBhc3NlbWJsZSBlbmNyeXB0aW9uIHBhcmFtZXRlcnMgLSBmcm9tIHN0cmluZyB0byBVSW50OFxuICAgICAgICAgICAgbGV0IHB1YktleVVJbnQ4QXJyYXk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHB1YktleVVJbnQ4QXJyYXkgPSBiYXNlXzEuYmFzZTY0LmRlY29kZShwdWJsaWNLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHB1YmxpYyBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1zZ1BhcmFtc1VJbnQ4QXJyYXkgPSBiYXNlXzEudXRmOC5kZWNvZGUoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IG5hY2wucmFuZG9tQnl0ZXMobmFjbC5ib3gubm9uY2VMZW5ndGgpO1xuICAgICAgICAgICAgLy8gZW5jcnlwdFxuICAgICAgICAgICAgY29uc3QgZW5jcnlwdGVkTWVzc2FnZSA9IG5hY2wuYm94KG1zZ1BhcmFtc1VJbnQ4QXJyYXksIG5vbmNlLCBwdWJLZXlVSW50OEFycmF5LCBlcGhlbWVyYWxLZXlQYWlyLnNlY3JldEtleSk7XG4gICAgICAgICAgICAvLyBoYW5kbGUgZW5jcnlwdGVkIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAneDI1NTE5LXhzYWxzYTIwLXBvbHkxMzA1JyxcbiAgICAgICAgICAgICAgICBub25jZTogYmFzZV8xLmJhc2U2NC5lbmNvZGUobm9uY2UpLFxuICAgICAgICAgICAgICAgIGVwaGVtUHVibGljS2V5OiBiYXNlXzEuYmFzZTY0LmVuY29kZShlcGhlbWVyYWxLZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dDogYmFzZV8xLmJhc2U2NC5lbmNvZGUoZW5jcnlwdGVkTWVzc2FnZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gcmV0dXJuIGVuY3J5cHRlZCBtc2cgZGF0YVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIHR5cGUvdmVyc2lvbiBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxufVxuZXhwb3J0cy5lbmNyeXB0ID0gZW5jcnlwdDtcbi8qKlxuICogRW5jcnlwdCBhIG1lc3NhZ2UgaW4gYSB3YXkgdGhhdCBvYnNjdXJlcyB0aGUgbWVzc2FnZSBsZW5ndGguXG4gKlxuICogVGhlIG1lc3NhZ2UgaXMgcGFkZGVkIHRvIGEgbXVsdGlwbGUgb2YgMjA0OCBiZWZvcmUgYmVpbmcgZW5jcnlwdGVkIHNvIHRoYXQgdGhlIGxlbmd0aCBvZiB0aGVcbiAqIHJlc3VsdGluZyBlbmNyeXB0ZWQgbWVzc2FnZSBjYW4ndCBiZSB1c2VkIHRvIGd1ZXNzIHRoZSBleGFjdCBsZW5ndGggb2YgdGhlIG9yaWdpbmFsIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgZW5jcnlwdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMucHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgb2YgdGhlIG1lc3NhZ2UgcmVjaXBpZW50LlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSBtZXNzYWdlIGRhdGEuXG4gKiBAcGFyYW0gb3B0aW9ucy52ZXJzaW9uIC0gVGhlIHR5cGUgb2YgZW5jcnlwdGlvbiB0byB1c2UuXG4gKiBAcmV0dXJucyBUaGUgZW5jcnlwdGVkIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGVuY3J5cHRTYWZlbHkoeyBwdWJsaWNLZXksIGRhdGEsIHZlcnNpb24sIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShwdWJsaWNLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwdWJsaWNLZXkgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkodmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHZlcnNpb24gcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IERFRkFVTFRfUEFERElOR19MRU5HVEggPSAyICoqIDExO1xuICAgIGNvbnN0IE5BQ0xfRVhUUkFfQllURVMgPSAxNjtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgJiYgJ3RvSlNPTicgaW4gZGF0YSkge1xuICAgICAgICAvLyByZW1vdmUgdG9KU09OIGF0dGFjayB2ZWN0b3JcbiAgICAgICAgLy8gVE9ETywgY2hlY2sgYWxsIHBvc3NpYmxlIGNoaWxkcmVuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgd2l0aCB0b0pTT04gcHJvcGVydHkuICBQbGVhc2UgcmVtb3ZlIHRvSlNPTiBwcm9wZXJ0eScpO1xuICAgIH1cbiAgICAvLyBhZGQgcGFkZGluZ1xuICAgIGNvbnN0IGRhdGFXaXRoUGFkZGluZyA9IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcGFkZGluZzogJycsXG4gICAgfTtcbiAgICAvLyBjYWxjdWxhdGUgcGFkZGluZ1xuICAgIGNvbnN0IGRhdGFMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChKU09OLnN0cmluZ2lmeShkYXRhV2l0aFBhZGRpbmcpLCAndXRmLTgnKTtcbiAgICBjb25zdCBtb2RWYWwgPSBkYXRhTGVuZ3RoICUgREVGQVVMVF9QQURESU5HX0xFTkdUSDtcbiAgICBsZXQgcGFkTGVuZ3RoID0gMDtcbiAgICAvLyBPbmx5IHBhZCBpZiBuZWNlc3NhcnlcbiAgICBpZiAobW9kVmFsID4gMCkge1xuICAgICAgICBwYWRMZW5ndGggPSBERUZBVUxUX1BBRERJTkdfTEVOR1RIIC0gbW9kVmFsIC0gTkFDTF9FWFRSQV9CWVRFUzsgLy8gbmFjbCBleHRyYSBieXRlc1xuICAgIH1cbiAgICBkYXRhV2l0aFBhZGRpbmcucGFkZGluZyA9ICcwJy5yZXBlYXQocGFkTGVuZ3RoKTtcbiAgICBjb25zdCBwYWRkZWRNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZGF0YVdpdGhQYWRkaW5nKTtcbiAgICByZXR1cm4gZW5jcnlwdCh7IHB1YmxpY0tleSwgZGF0YTogcGFkZGVkTWVzc2FnZSwgdmVyc2lvbiB9KTtcbn1cbmV4cG9ydHMuZW5jcnlwdFNhZmVseSA9IGVuY3J5cHRTYWZlbHk7XG4vKipcbiAqIERlY3J5cHQgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGRlY3J5cHRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLmVuY3J5cHRlZERhdGEgLSBUaGUgZW5jcnlwdGVkIGRhdGEuXG4gKiBAcGFyYW0gb3B0aW9ucy5wcml2YXRlS2V5IC0gVGhlIHByaXZhdGUga2V5IHRvIGRlY3J5cHQgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNyeXB0ZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZGVjcnlwdCh7IGVuY3J5cHRlZERhdGEsIHByaXZhdGVLZXksIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShlbmNyeXB0ZWREYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZW5jcnlwdGVkRGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShwcml2YXRlS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZUtleSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgc3dpdGNoIChlbmNyeXB0ZWREYXRhLnZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAneDI1NTE5LXhzYWxzYTIwLXBvbHkxMzA1Jzoge1xuICAgICAgICAgICAgY29uc3QgcmVjZWl2ZXJQcml2YXRlS2V5VWludDhBcnJheSA9IEJ1ZmZlci5mcm9tKHByaXZhdGVLZXksICdoZXgnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVyRW5jcnlwdGlvblByaXZhdGVLZXkgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkocmVjZWl2ZXJQcml2YXRlS2V5VWludDhBcnJheSkuc2VjcmV0S2V5O1xuICAgICAgICAgICAgLy8gYXNzZW1ibGUgZGVjcnlwdGlvbiBwYXJhbWV0ZXJzXG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGJhc2VfMS5iYXNlNjQuZGVjb2RlKGVuY3J5cHRlZERhdGEubm9uY2UpO1xuICAgICAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IGJhc2VfMS5iYXNlNjQuZGVjb2RlKGVuY3J5cHRlZERhdGEuY2lwaGVydGV4dCk7XG4gICAgICAgICAgICBjb25zdCBlcGhlbVB1YmxpY0tleSA9IGJhc2VfMS5iYXNlNjQuZGVjb2RlKGVuY3J5cHRlZERhdGEuZXBoZW1QdWJsaWNLZXkpO1xuICAgICAgICAgICAgLy8gZGVjcnlwdFxuICAgICAgICAgICAgY29uc3QgZGVjcnlwdGVkTWVzc2FnZSA9IG5hY2wuYm94Lm9wZW4oY2lwaGVydGV4dCwgbm9uY2UsIGVwaGVtUHVibGljS2V5LCByZWNlaXZlckVuY3J5cHRpb25Qcml2YXRlS2V5KTtcbiAgICAgICAgICAgIC8vIHJldHVybiBkZWNyeXB0ZWQgbXNnIGRhdGFcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkZWNyeXB0ZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBiYXNlXzEudXRmOC5lbmNvZGUoZGVjcnlwdGVkTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBwcm9iYWJseSBleHRyYW5lb3VzIGJ1dCB3YXMga2VwdCB0byBtaW5pbWl6ZSBjaGFuZ2VzIGR1cmluZyByZWZhY3RvclxuICAgICAgICAgICAgICAgIGlmICghb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiBlcnIubWVzc2FnZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWNyeXB0aW9uIGZhaWxlZDogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWNyeXB0aW9uIGZhaWxlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIHR5cGUvdmVyc2lvbiBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVjcnlwdCA9IGRlY3J5cHQ7XG4vKipcbiAqIERlY3J5cHQgYSBtZXNzYWdlIHRoYXQgaGFzIGJlZW4gZW5jcnlwdGVkIHVzaW5nIGBlbmNyeXB0U2FmZWx5YC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBkZWNyeXB0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5lbmNyeXB0ZWREYXRhIC0gVGhlIGVuY3J5cHRlZCBkYXRhLlxuICogQHBhcmFtIG9wdGlvbnMucHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSB0byBkZWNyeXB0IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgZGVjcnlwdGVkIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGRlY3J5cHRTYWZlbHkoeyBlbmNyeXB0ZWREYXRhLCBwcml2YXRlS2V5LCB9KSB7XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZW5jcnlwdGVkRGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGVuY3J5cHRlZERhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByaXZhdGVLZXkgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGFXaXRoUGFkZGluZyA9IEpTT04ucGFyc2UoZGVjcnlwdCh7IGVuY3J5cHRlZERhdGEsIHByaXZhdGVLZXkgfSkpO1xuICAgIHJldHVybiBkYXRhV2l0aFBhZGRpbmcuZGF0YTtcbn1cbmV4cG9ydHMuZGVjcnlwdFNhZmVseSA9IGRlY3J5cHRTYWZlbHk7XG4vKipcbiAqIEdldCB0aGUgZW5jcnlwdGlvbiBwdWJsaWMga2V5IGZvciB0aGUgZ2l2ZW4ga2V5LlxuICpcbiAqIEBwYXJhbSBwcml2YXRlS2V5IC0gVGhlIHByaXZhdGUga2V5IHRvIGdlbmVyYXRlIHRoZSBlbmNyeXB0aW9uIHB1YmxpYyBrZXkgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBlbmNyeXB0aW9uIHB1YmxpYyBrZXkuXG4gKi9cbmZ1bmN0aW9uIGdldEVuY3J5cHRpb25QdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIGNvbnN0IHByaXZhdGVLZXlVaW50OEFycmF5ID0gQnVmZmVyLmZyb20ocHJpdmF0ZUtleSwgJ2hleCcpO1xuICAgIGNvbnN0IGVuY3J5cHRpb25QdWJsaWNLZXkgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkocHJpdmF0ZUtleVVpbnQ4QXJyYXkpLnB1YmxpY0tleTtcbiAgICByZXR1cm4gYmFzZV8xLmJhc2U2NC5lbmNvZGUoZW5jcnlwdGlvblB1YmxpY0tleSk7XG59XG5leHBvcnRzLmdldEVuY3J5cHRpb25QdWJsaWNLZXkgPSBnZXRFbmNyeXB0aW9uUHVibGljS2V5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jcnlwdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/eth-sig-util/dist/encryption.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/eth-sig-util/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/eth-sig-util/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.normalize = exports.concatSig = void 0;\n__exportStar(__webpack_require__(/*! ./personal-sign */ \"(ssr)/./node_modules/@metamask/eth-sig-util/dist/personal-sign.js\"), exports);\n__exportStar(__webpack_require__(/*! ./sign-typed-data */ \"(ssr)/./node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js\"), exports);\n__exportStar(__webpack_require__(/*! ./encryption */ \"(ssr)/./node_modules/@metamask/eth-sig-util/dist/encryption.js\"), exports);\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@metamask/eth-sig-util/dist/utils.js\");\nObject.defineProperty(exports, \"concatSig\", ({ enumerable: true, get: function () { return utils_1.concatSig; } }));\nObject.defineProperty(exports, \"normalize\", ({ enumerable: true, get: function () { return utils_1.normalize; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLGlCQUFpQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsMEZBQWlCO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyw4RkFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLG9GQUFjO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQywwRUFBUztBQUMvQiw2Q0FBNEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDakgsNkNBQTRDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ2pIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9pbmRleC5qcz9iNDE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IGV4cG9ydHMuY29uY2F0U2lnID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3BlcnNvbmFsLXNpZ25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NpZ24tdHlwZWQtZGF0YVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZW5jcnlwdGlvblwiKSwgZXhwb3J0cyk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0U2lnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmNvbmNhdFNpZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vcm1hbGl6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5ub3JtYWxpemU7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/eth-sig-util/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/eth-sig-util/dist/personal-sign.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@metamask/eth-sig-util/dist/personal-sign.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = void 0;\nconst util_1 = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/./node_modules/@ethereumjs/util/dist/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@metamask/eth-sig-util/dist/utils.js\");\n/**\n * Create an Ethereum-specific signature for a message.\n *\n * This function is equivalent to the `eth_sign` Ethereum JSON-RPC method as specified in EIP-1417,\n * as well as the MetaMask's `personal_sign` method.\n *\n * @param options - The personal sign options.\n * @param options.privateKey - The key to sign with.\n * @param options.data - The hex data to sign.\n * @returns The '0x'-prefixed hex encoded signature.\n */\nfunction personalSign({ privateKey, data, }) {\n    if ((0, utils_1.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_1.isNullish)(privateKey)) {\n        throw new Error('Missing privateKey parameter');\n    }\n    const message = (0, utils_1.legacyToBuffer)(data);\n    const msgHash = (0, util_1.hashPersonalMessage)(message);\n    const sig = (0, util_1.ecsign)(msgHash, privateKey);\n    const serialized = (0, utils_1.concatSig)((0, util_1.toBuffer)(sig.v), sig.r, sig.s);\n    return serialized;\n}\nexports.personalSign = personalSign;\n/**\n * Recover the address of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The signature recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded address of the message signer.\n */\nfunction recoverPersonalSignature({ data, signature, }) {\n    if ((0, utils_1.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_1.isNullish)(signature)) {\n        throw new Error('Missing signature parameter');\n    }\n    const publicKey = getPublicKeyFor(data, signature);\n    const sender = (0, util_1.publicToAddress)(publicKey);\n    const senderHex = (0, util_1.bufferToHex)(sender);\n    return senderHex;\n}\nexports.recoverPersonalSignature = recoverPersonalSignature;\n/**\n * Recover the public key of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The public key recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded public key of the message signer.\n */\nfunction extractPublicKey({ data, signature, }) {\n    if ((0, utils_1.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_1.isNullish)(signature)) {\n        throw new Error('Missing signature parameter');\n    }\n    const publicKey = getPublicKeyFor(data, signature);\n    return `0x${publicKey.toString('hex')}`;\n}\nexports.extractPublicKey = extractPublicKey;\n/**\n * Get the public key for the given signature and message.\n *\n * @param message - The message that was signed.\n * @param signature - The '0x'-prefixed hex encoded message signature.\n * @returns The public key of the signer.\n */\nfunction getPublicKeyFor(message, signature) {\n    const messageHash = (0, util_1.hashPersonalMessage)((0, utils_1.legacyToBuffer)(message));\n    return (0, utils_1.recoverPublicKey)(messageHash, signature);\n}\n//# sourceMappingURL=personal-sign.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L3BlcnNvbmFsLXNpZ24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsZ0NBQWdDLEdBQUcsb0JBQW9CO0FBQ2xGLGVBQWUsbUJBQU8sQ0FBQyw2RUFBa0I7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L3BlcnNvbmFsLXNpZ24uanM/OTFhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0cmFjdFB1YmxpY0tleSA9IGV4cG9ydHMucmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlID0gZXhwb3J0cy5wZXJzb25hbFNpZ24gPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvdXRpbFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogQ3JlYXRlIGFuIEV0aGVyZXVtLXNwZWNpZmljIHNpZ25hdHVyZSBmb3IgYSBtZXNzYWdlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byB0aGUgYGV0aF9zaWduYCBFdGhlcmV1bSBKU09OLVJQQyBtZXRob2QgYXMgc3BlY2lmaWVkIGluIEVJUC0xNDE3LFxuICogYXMgd2VsbCBhcyB0aGUgTWV0YU1hc2sncyBgcGVyc29uYWxfc2lnbmAgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBlcnNvbmFsIHNpZ24gb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLnByaXZhdGVLZXkgLSBUaGUga2V5IHRvIHNpZ24gd2l0aC5cbiAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBUaGUgaGV4IGRhdGEgdG8gc2lnbi5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIHNpZ25hdHVyZS5cbiAqL1xuZnVuY3Rpb24gcGVyc29uYWxTaWduKHsgcHJpdmF0ZUtleSwgZGF0YSwgfSkge1xuICAgIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkYXRhIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcml2YXRlS2V5IHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gKDAsIHV0aWxzXzEubGVnYWN5VG9CdWZmZXIpKGRhdGEpO1xuICAgIGNvbnN0IG1zZ0hhc2ggPSAoMCwgdXRpbF8xLmhhc2hQZXJzb25hbE1lc3NhZ2UpKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHNpZyA9ICgwLCB1dGlsXzEuZWNzaWduKShtc2dIYXNoLCBwcml2YXRlS2V5KTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gKDAsIHV0aWxzXzEuY29uY2F0U2lnKSgoMCwgdXRpbF8xLnRvQnVmZmVyKShzaWcudiksIHNpZy5yLCBzaWcucyk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5leHBvcnRzLnBlcnNvbmFsU2lnbiA9IHBlcnNvbmFsU2lnbjtcbi8qKlxuICogUmVjb3ZlciB0aGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB1c2VkIHRvIGNyZWF0ZSB0aGUgZ2l2ZW4gRXRoZXJldW0gc2lnbmF0dXJlLiBUaGUgbWVzc2FnZVxuICogbXVzdCBoYXZlIGJlZW4gc2lnbmVkIHVzaW5nIHRoZSBgcGVyc29uYWxTaWduYCBmdW5jdGlvbiwgb3IgYW4gZXF1aXZhbGVudCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBzaWduYXR1cmUgcmVjb3Zlcnkgb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBUaGUgaGV4IGRhdGEgdGhhdCB3YXMgc2lnbmVkLlxuICogQHBhcmFtIG9wdGlvbnMuc2lnbmF0dXJlIC0gVGhlICcweCctcHJlZml4ZWQgaGV4IGVuY29kZWQgbWVzc2FnZSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBhZGRyZXNzIG9mIHRoZSBtZXNzYWdlIHNpZ25lci5cbiAqL1xuZnVuY3Rpb24gcmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlKHsgZGF0YSwgc2lnbmF0dXJlLCB9KSB7XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoc2lnbmF0dXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc2lnbmF0dXJlIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGb3IoZGF0YSwgc2lnbmF0dXJlKTtcbiAgICBjb25zdCBzZW5kZXIgPSAoMCwgdXRpbF8xLnB1YmxpY1RvQWRkcmVzcykocHVibGljS2V5KTtcbiAgICBjb25zdCBzZW5kZXJIZXggPSAoMCwgdXRpbF8xLmJ1ZmZlclRvSGV4KShzZW5kZXIpO1xuICAgIHJldHVybiBzZW5kZXJIZXg7XG59XG5leHBvcnRzLnJlY292ZXJQZXJzb25hbFNpZ25hdHVyZSA9IHJlY292ZXJQZXJzb25hbFNpZ25hdHVyZTtcbi8qKlxuICogUmVjb3ZlciB0aGUgcHVibGljIGtleSBvZiB0aGUgYWNjb3VudCB1c2VkIHRvIGNyZWF0ZSB0aGUgZ2l2ZW4gRXRoZXJldW0gc2lnbmF0dXJlLiBUaGUgbWVzc2FnZVxuICogbXVzdCBoYXZlIGJlZW4gc2lnbmVkIHVzaW5nIHRoZSBgcGVyc29uYWxTaWduYCBmdW5jdGlvbiwgb3IgYW4gZXF1aXZhbGVudCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwdWJsaWMga2V5IHJlY292ZXJ5IG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIGhleCBkYXRhIHRoYXQgd2FzIHNpZ25lZC5cbiAqIEBwYXJhbSBvcHRpb25zLnNpZ25hdHVyZSAtIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIG1lc3NhZ2Ugc2lnbmF0dXJlLlxuICogQHJldHVybnMgVGhlICcweCctcHJlZml4ZWQgaGV4IGVuY29kZWQgcHVibGljIGtleSBvZiB0aGUgbWVzc2FnZSBzaWduZXIuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQdWJsaWNLZXkoeyBkYXRhLCBzaWduYXR1cmUsIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShzaWduYXR1cmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzaWduYXR1cmUgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleUZvcihkYXRhLCBzaWduYXR1cmUpO1xuICAgIHJldHVybiBgMHgke3B1YmxpY0tleS50b1N0cmluZygnaGV4Jyl9YDtcbn1cbmV4cG9ydHMuZXh0cmFjdFB1YmxpY0tleSA9IGV4dHJhY3RQdWJsaWNLZXk7XG4vKipcbiAqIEdldCB0aGUgcHVibGljIGtleSBmb3IgdGhlIGdpdmVuIHNpZ25hdHVyZSBhbmQgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRoYXQgd2FzIHNpZ25lZC5cbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBtZXNzYWdlIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBwdWJsaWMga2V5IG9mIHRoZSBzaWduZXIuXG4gKi9cbmZ1bmN0aW9uIGdldFB1YmxpY0tleUZvcihtZXNzYWdlLCBzaWduYXR1cmUpIHtcbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9ICgwLCB1dGlsXzEuaGFzaFBlcnNvbmFsTWVzc2FnZSkoKDAsIHV0aWxzXzEubGVnYWN5VG9CdWZmZXIpKG1lc3NhZ2UpKTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEucmVjb3ZlclB1YmxpY0tleSkobWVzc2FnZUhhc2gsIHNpZ25hdHVyZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZXJzb25hbC1zaWduLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/eth-sig-util/dist/personal-sign.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.recoverTypedSignature = exports.signTypedData = exports.typedSignatureHash = exports.TypedDataUtils = exports.TYPED_MESSAGE_SCHEMA = exports.SignTypedDataVersion = void 0;\nconst util_1 = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/./node_modules/@ethereumjs/util/dist/index.js\");\nconst abi_utils_1 = __webpack_require__(/*! @metamask/abi-utils */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/index.js\");\nconst parsers_1 = __webpack_require__(/*! @metamask/abi-utils/dist/parsers */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/index.js\");\nconst utils_1 = __webpack_require__(/*! @metamask/abi-utils/dist/utils */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js\");\nconst utils_2 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.cjs\");\nconst keccak_1 = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/./node_modules/ethereum-cryptography/keccak.js\");\nconst utils_3 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@metamask/eth-sig-util/dist/utils.js\");\n/**\n * Represents the version of `signTypedData` being used.\n *\n * V1 is based upon [an early version of\n * EIP-712](https://github.com/ethereum/EIPs/pull/712/commits/21abe254fe0452d8583d5b132b1d7be87c0439ca)\n * that lacked some later security improvements, and should generally be neglected in favor of\n * later versions.\n *\n * V3 is based on EIP-712, except that arrays and recursive data structures are not supported.\n *\n * V4 is based on EIP-712, and includes full support of arrays and recursive data structures.\n */\nvar SignTypedDataVersion;\n(function (SignTypedDataVersion) {\n    SignTypedDataVersion[\"V1\"] = \"V1\";\n    SignTypedDataVersion[\"V3\"] = \"V3\";\n    SignTypedDataVersion[\"V4\"] = \"V4\";\n})(SignTypedDataVersion = exports.SignTypedDataVersion || (exports.SignTypedDataVersion = {}));\nexports.TYPED_MESSAGE_SCHEMA = {\n    type: 'object',\n    properties: {\n        types: {\n            type: 'object',\n            additionalProperties: {\n                type: 'array',\n                items: {\n                    type: 'object',\n                    properties: {\n                        name: { type: 'string' },\n                        type: { type: 'string' },\n                    },\n                    required: ['name', 'type'],\n                },\n            },\n        },\n        primaryType: { type: 'string' },\n        domain: { type: 'object' },\n        message: { type: 'object' },\n    },\n    required: ['types', 'primaryType', 'domain', 'message'],\n};\n/**\n * Validate that the given value is a valid version string.\n *\n * @param version - The version value to validate.\n * @param allowedVersions - A list of allowed versions. If omitted, all versions are assumed to be\n * allowed.\n */\nfunction validateVersion(version, allowedVersions) {\n    if (!Object.keys(SignTypedDataVersion).includes(version)) {\n        throw new Error(`Invalid version: '${version}'`);\n    }\n    else if (allowedVersions && !allowedVersions.includes(version)) {\n        throw new Error(`SignTypedDataVersion not allowed: '${version}'. Allowed versions are: ${allowedVersions.join(', ')}`);\n    }\n}\n/**\n * Parse a string, number, or bigint value into a `Uint8Array`.\n *\n * @param type - The type of the value.\n * @param value - The value to parse.\n * @returns The parsed value.\n */\nfunction parseNumber(type, value) {\n    (0, utils_2.assert)(value !== null, `Unable to encode value: Invalid number. Expected a valid number value, but received \"${value}\".`);\n    const bigIntValue = BigInt(value);\n    const length = (0, parsers_1.getLength)(type);\n    const maxValue = BigInt(2) ** BigInt(length) - BigInt(1);\n    // Note that this is not accurate, since the actual maximum value for unsigned\n    // integers is `2 ^ (length - 1) - 1`, but this is required for backwards\n    // compatibility with the old implementation.\n    (0, utils_2.assert)(bigIntValue >= -maxValue && bigIntValue <= maxValue, `Unable to encode value: Number \"${value}\" is out of range for type \"${type}\".`);\n    return bigIntValue;\n}\n/**\n * Parse an address string to a `Uint8Array`. The behaviour of this is quite\n * strange, in that it does not parse the address as hexadecimal string, nor as\n * UTF-8. It does some weird stuff with the string and char codes, and then\n * returns the result as a `Uint8Array`.\n *\n * This is based on the old `ethereumjs-abi` implementation, which essentially\n * calls `new BN(address, 10)` on the address string, the equivalent of calling\n * `parseInt(address, 10)` in JavaScript. This is not a valid way to parse an\n * address and would result in `NaN` in plain JavaScript, but it is the\n * behaviour of the old implementation, and so we must preserve it for backwards\n * compatibility.\n *\n * @param address - The address to parse.\n * @returns The parsed address.\n */\nfunction reallyStrangeAddressToBytes(address) {\n    let addressValue = BigInt(0);\n    for (let i = 0; i < address.length; i++) {\n        const character = BigInt(address.charCodeAt(i) - 48);\n        addressValue *= BigInt(10);\n        // 'a'\n        if (character >= 49) {\n            addressValue += character - BigInt(49) + BigInt(0xa);\n            // 'A'\n        }\n        else if (character >= 17) {\n            addressValue += character - BigInt(17) + BigInt(0xa);\n            // '0' - '9'\n        }\n        else {\n            addressValue += character;\n        }\n    }\n    return (0, utils_1.padStart)((0, utils_2.bigIntToBytes)(addressValue), 20);\n}\n/**\n * Encode a single field.\n *\n * @param types - All type definitions.\n * @param name - The name of the field to encode.\n * @param type - The type of the field being encoded.\n * @param value - The value to encode.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns Encoded representation of the field.\n */\nfunction encodeField(types, name, type, \n// TODO: constrain type on `value`\nvalue, version) {\n    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);\n    if (types[type] !== undefined) {\n        return [\n            'bytes32',\n            // TODO: return Buffer, remove string from return type\n            version === SignTypedDataVersion.V4 && value == null // eslint-disable-line no-eq-null\n                ? '0x0000000000000000000000000000000000000000000000000000000000000000'\n                : (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodeData(type, value, types, version))),\n        ];\n    }\n    // `function` is supported in `@metamask/abi-utils`, but not allowed by\n    // EIP-712, so we throw an error here.\n    if (type === 'function') {\n        throw new Error('Unsupported or invalid type: \"function\"');\n    }\n    if (value === undefined) {\n        throw new Error(`missing value for field ${name} of type ${type}`);\n    }\n    if (type === 'address') {\n        if (typeof value === 'number') {\n            return ['address', (0, utils_1.padStart)((0, utils_2.numberToBytes)(value), 20)];\n        }\n        else if ((0, utils_2.isStrictHexString)(value)) {\n            return ['address', (0, utils_2.add0x)(value)];\n        }\n        else if (typeof value === 'string') {\n            return ['address', reallyStrangeAddressToBytes(value).subarray(0, 20)];\n        }\n    }\n    if (type === 'bool') {\n        return ['bool', Boolean(value)];\n    }\n    if (type === 'bytes') {\n        if (typeof value === 'number') {\n            value = (0, utils_2.numberToBytes)(value);\n        }\n        else if ((0, utils_2.isStrictHexString)(value) || value === '0x') {\n            value = (0, utils_2.hexToBytes)(value);\n        }\n        else if (typeof value === 'string') {\n            value = (0, utils_2.stringToBytes)(value);\n        }\n        return ['bytes32', (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))];\n    }\n    if (type.startsWith('bytes') && type !== 'bytes' && !type.includes('[')) {\n        if (typeof value === 'number') {\n            if (value < 0) {\n                return ['bytes32', new Uint8Array(32)];\n            }\n            return ['bytes32', (0, utils_2.bigIntToBytes)(BigInt(value))];\n        }\n        else if ((0, utils_2.isStrictHexString)(value)) {\n            return ['bytes32', (0, utils_2.hexToBytes)(value)];\n        }\n        return ['bytes32', value];\n    }\n    if (type.startsWith('int') && !type.includes('[')) {\n        const bigIntValue = parseNumber(type, value);\n        if (bigIntValue >= BigInt(0)) {\n            return ['uint256', bigIntValue];\n        }\n        return ['int256', bigIntValue];\n    }\n    if (type === 'string') {\n        if (typeof value === 'number') {\n            value = (0, utils_2.numberToBytes)(value);\n        }\n        else {\n            value = (0, utils_2.stringToBytes)(value !== null && value !== void 0 ? value : '');\n        }\n        return ['bytes32', (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))];\n    }\n    if (type.endsWith(']')) {\n        if (version === SignTypedDataVersion.V3) {\n            throw new Error('Arrays are unimplemented in encodeData; use V4 extension');\n        }\n        const parsedType = type.slice(0, type.lastIndexOf('['));\n        const typeValuePairs = value.map((item) => encodeField(types, name, parsedType, item, version));\n        return [\n            'bytes32',\n            (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, abi_utils_1.encode)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))),\n        ];\n    }\n    return [type, value];\n}\n/**\n * Encodes an object by encoding and concatenating each of its members.\n *\n * @param primaryType - The root type.\n * @param data - The object to encode.\n * @param types - Type definitions for all types included in the message.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns An encoded representation of an object.\n */\nfunction encodeData(primaryType, data, types, version) {\n    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);\n    const encodedTypes = ['bytes32'];\n    const encodedValues = [\n        hashType(primaryType, types),\n    ];\n    for (const field of types[primaryType]) {\n        if (version === SignTypedDataVersion.V3 && data[field.name] === undefined) {\n            continue;\n        }\n        const [type, value] = encodeField(types, field.name, field.type, data[field.name], version);\n        encodedTypes.push(type);\n        encodedValues.push(value);\n    }\n    return (0, util_1.arrToBufArr)((0, abi_utils_1.encode)(encodedTypes, encodedValues));\n}\n/**\n * Encodes the type of an object by encoding a comma delimited list of its members.\n *\n * @param primaryType - The root type to encode.\n * @param types - Type definitions for all types included in the message.\n * @returns An encoded representation of the primary type.\n */\nfunction encodeType(primaryType, types) {\n    let result = '';\n    const unsortedDeps = findTypeDependencies(primaryType, types);\n    unsortedDeps.delete(primaryType);\n    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n    for (const type of deps) {\n        const children = types[type];\n        if (!children) {\n            throw new Error(`No type definition specified: ${type}`);\n        }\n        result += `${type}(${types[type]\n            .map(({ name, type: t }) => `${t} ${name}`)\n            .join(',')})`;\n    }\n    return result;\n}\n/**\n * Finds all types within a type definition object.\n *\n * @param primaryType - The root type.\n * @param types - Type definitions for all types included in the message.\n * @param results - The current set of accumulated types.\n * @returns The set of all types found in the type definition.\n */\nfunction findTypeDependencies(primaryType, types, results = new Set()) {\n    if (typeof primaryType !== 'string') {\n        throw new Error(`Invalid findTypeDependencies input ${JSON.stringify(primaryType)}`);\n    }\n    const match = primaryType.match(/^\\w*/u);\n    [primaryType] = match;\n    if (results.has(primaryType) || types[primaryType] === undefined) {\n        return results;\n    }\n    results.add(primaryType);\n    for (const field of types[primaryType]) {\n        findTypeDependencies(field.type, types, results);\n    }\n    return results;\n}\n/**\n * Hashes an object.\n *\n * @param primaryType - The root type.\n * @param data - The object to hash.\n * @param types - Type definitions for all types included in the message.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns The hash of the object.\n */\nfunction hashStruct(primaryType, data, types, version) {\n    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);\n    const encoded = encodeData(primaryType, data, types, version);\n    const hashed = (0, keccak_1.keccak256)(encoded);\n    const buf = (0, util_1.arrToBufArr)(hashed);\n    return buf;\n}\n/**\n * Hashes the type of an object.\n *\n * @param primaryType - The root type to hash.\n * @param types - Type definitions for all types included in the message.\n * @returns The hash of the object type.\n */\nfunction hashType(primaryType, types) {\n    const encodedHashType = (0, utils_2.stringToBytes)(encodeType(primaryType, types));\n    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodedHashType));\n}\n/**\n * Removes properties from a message object that are not defined per EIP-712.\n *\n * @param data - The typed message object.\n * @returns The typed message object with only allowed fields.\n */\nfunction sanitizeData(data) {\n    const sanitizedData = {};\n    for (const key in exports.TYPED_MESSAGE_SCHEMA.properties) {\n        if (data[key]) {\n            sanitizedData[key] = data[key];\n        }\n    }\n    if ('types' in sanitizedData) {\n        // TODO: Fix types\n        sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);\n    }\n    return sanitizedData;\n}\n/**\n * Create a EIP-712 Domain Hash.\n * This hash is used at the top of the EIP-712 encoding.\n *\n * @param typedData - The typed message to hash.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns The hash of the domain object.\n */\nfunction eip712DomainHash(typedData, version) {\n    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);\n    const sanitizedData = sanitizeData(typedData);\n    const { domain } = sanitizedData;\n    const domainType = { EIP712Domain: sanitizedData.types.EIP712Domain };\n    return hashStruct('EIP712Domain', domain, domainType, version);\n}\n/**\n * Hash a typed message according to EIP-712. The returned message starts with the EIP-712 prefix,\n * which is \"1901\", followed by the hash of the domain separator, then the data (if any).\n * The result is hashed again and returned.\n *\n * This function does not sign the message. The resulting hash must still be signed to create an\n * EIP-712 signature.\n *\n * @param typedData - The typed message to hash.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns The hash of the typed message.\n */\nfunction eip712Hash(typedData, version) {\n    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);\n    const sanitizedData = sanitizeData(typedData);\n    const parts = [(0, utils_2.hexToBytes)('1901')];\n    parts.push(eip712DomainHash(typedData, version));\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n        parts.push(hashStruct(\n        // TODO: Validate that this is a string, so this type cast can be removed.\n        sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, version));\n    }\n    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, utils_2.concatBytes)(parts)));\n}\n/**\n * A collection of utility functions used for signing typed data.\n */\nexports.TypedDataUtils = {\n    encodeData,\n    encodeType,\n    findTypeDependencies,\n    hashStruct,\n    hashType,\n    sanitizeData,\n    eip712Hash,\n    eip712DomainHash,\n};\n/**\n * Generate the \"V1\" hash for the provided typed message.\n *\n * The hash will be generated in accordance with an earlier version of the EIP-712\n * specification. This hash is used in `signTypedData_v1`.\n *\n * @param typedData - The typed message.\n * @returns The '0x'-prefixed hex encoded hash representing the type of the provided message.\n */\nfunction typedSignatureHash(typedData) {\n    const hashBuffer = _typedSignatureHash(typedData);\n    return (0, utils_2.bytesToHex)(hashBuffer);\n}\nexports.typedSignatureHash = typedSignatureHash;\n/**\n * Normalize a value, so that `@metamask/abi-utils` can handle it. This\n * matches the behaviour of the `ethereumjs-abi` library.\n *\n * @param type - The type of the value to normalize.\n * @param value - The value to normalize.\n * @returns The normalized value.\n */\nfunction normalizeValue(type, value) {\n    if ((0, parsers_1.isArrayType)(type) && Array.isArray(value)) {\n        const [innerType] = (0, parsers_1.getArrayType)(type);\n        return value.map((item) => normalizeValue(innerType, item));\n    }\n    if (type === 'address') {\n        if (typeof value === 'number') {\n            return (0, utils_1.padStart)((0, utils_2.numberToBytes)(value), 20);\n        }\n        if ((0, utils_2.isStrictHexString)(value)) {\n            return (0, utils_1.padStart)((0, utils_2.hexToBytes)(value).subarray(0, 20), 20);\n        }\n        if (value instanceof Uint8Array) {\n            return (0, utils_1.padStart)(value.subarray(0, 20), 20);\n        }\n    }\n    if (type === 'bool') {\n        return Boolean(value);\n    }\n    if (type.startsWith('bytes') && type !== 'bytes') {\n        const length = (0, parsers_1.getByteLength)(type);\n        if (typeof value === 'number') {\n            if (value < 0) {\n                // `solidityPack(['bytesN'], [-1])` returns `0x00..00`.\n                return new Uint8Array();\n            }\n            return (0, utils_2.numberToBytes)(value).subarray(0, length);\n        }\n        if ((0, utils_2.isStrictHexString)(value)) {\n            return (0, utils_2.hexToBytes)(value).subarray(0, length);\n        }\n        if (value instanceof Uint8Array) {\n            return value.subarray(0, length);\n        }\n    }\n    if (type.startsWith('uint')) {\n        if (typeof value === 'number') {\n            return Math.abs(value);\n        }\n    }\n    if (type.startsWith('int')) {\n        if (typeof value === 'number') {\n            const length = (0, parsers_1.getLength)(type);\n            return BigInt.asIntN(length, BigInt(value));\n        }\n    }\n    return value;\n}\n/**\n * For some reason `ethereumjs-abi` treats `address` and `address[]` differently\n * so we need to normalize `address[]` differently.\n *\n * @param values - The values to normalize.\n * @returns The normalized values.\n */\nfunction normalizeAddresses(values) {\n    return values.map((value) => {\n        if (typeof value === 'number') {\n            return (0, utils_1.padStart)((0, utils_2.numberToBytes)(value), 32);\n        }\n        if ((0, utils_2.isStrictHexString)(value)) {\n            return (0, utils_1.padStart)((0, utils_2.hexToBytes)(value).subarray(0, 32), 32);\n        }\n        if (value instanceof Uint8Array) {\n            return (0, utils_1.padStart)(value.subarray(0, 32), 32);\n        }\n        return value;\n    });\n}\n/**\n * For some reason `ethereumjs-abi` treats `intN` and `intN[]` differently\n * so we need to normalize `intN[]` differently.\n *\n * @param type - The type of the value to normalize.\n * @param values - The values to normalize.\n * @returns The normalized values.\n */\nfunction normalizeIntegers(type, values) {\n    return values.map((value) => {\n        if (typeof value === 'string' ||\n            typeof value === 'number' ||\n            typeof value === 'bigint') {\n            const bigIntValue = parseNumber(type, value);\n            if (bigIntValue >= BigInt(0)) {\n                return (0, utils_1.padStart)((0, utils_2.bigIntToBytes)(bigIntValue), 32);\n            }\n            const length = (0, parsers_1.getLength)(type);\n            const asIntN = BigInt.asIntN(length, bigIntValue);\n            return (0, utils_2.signedBigIntToBytes)(asIntN, 32);\n        }\n        return value;\n    });\n}\n/**\n * Generate the \"V1\" hash for the provided typed message.\n *\n * The hash will be generated in accordance with an earlier version of the EIP-712\n * specification. This hash is used in `signTypedData_v1`.\n *\n * @param typedData - The typed message.\n * @returns The hash representing the type of the provided message.\n */\nfunction _typedSignatureHash(typedData) {\n    const error = new Error('Expect argument to be non-empty array');\n    if (typeof typedData !== 'object' ||\n        !('length' in typedData) ||\n        !typedData.length) {\n        throw error;\n    }\n    const normalizedData = typedData.map(({ name, type, value }) => {\n        // Handle an edge case with `address[]` types.\n        if (type === 'address[]') {\n            return {\n                name,\n                type: 'bytes32[]',\n                value: normalizeAddresses(value),\n            };\n        }\n        // Handle an edge case with `intN[]` types.\n        if (type.startsWith('int') && (0, parsers_1.isArrayType)(type)) {\n            const [innerType, length] = (0, parsers_1.getArrayType)(type);\n            return {\n                name,\n                type: `bytes32[${length !== null && length !== void 0 ? length : ''}]`,\n                value: normalizeIntegers(innerType, value),\n            };\n        }\n        return {\n            name,\n            type,\n            value: normalizeValue(type, value),\n        };\n    });\n    const data = normalizedData.map((e) => {\n        if (e.type !== 'bytes') {\n            return e.value;\n        }\n        return (0, utils_3.legacyToBuffer)(e.value);\n    });\n    const types = normalizedData.map((e) => {\n        if (e.type === 'function') {\n            throw new Error('Unsupported or invalid type: \"function\"');\n        }\n        return e.type;\n    });\n    const schema = typedData.map((e) => {\n        if (!e.name) {\n            throw error;\n        }\n        return `${e.type} ${e.name}`;\n    });\n    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, abi_utils_1.encodePacked)(['bytes32', 'bytes32'], [\n        (0, keccak_1.keccak256)((0, abi_utils_1.encodePacked)(['string[]'], [schema], true)),\n        (0, keccak_1.keccak256)((0, abi_utils_1.encodePacked)(types, data, true)),\n    ])));\n}\n/**\n * Sign typed data according to EIP-712. The signing differs based upon the `version`.\n *\n * V1 is based upon [an early version of\n * EIP-712](https://github.com/ethereum/EIPs/pull/712/commits/21abe254fe0452d8583d5b132b1d7be87c0439ca)\n * that lacked some later security improvements, and should generally be neglected in favor of\n * later versions.\n *\n * V3 is based on [EIP-712](https://eips.ethereum.org/EIPS/eip-712), except that arrays and\n * recursive data structures are not supported.\n *\n * V4 is based on [EIP-712](https://eips.ethereum.org/EIPS/eip-712), and includes full support of\n * arrays and recursive data structures.\n *\n * @param options - The signing options.\n * @param options.privateKey - The private key to sign with.\n * @param options.data - The typed data to sign.\n * @param options.version - The signing version to use.\n * @returns The '0x'-prefixed hex encoded signature.\n */\nfunction signTypedData({ privateKey, data, version, }) {\n    validateVersion(version);\n    if ((0, utils_3.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_3.isNullish)(privateKey)) {\n        throw new Error('Missing private key parameter');\n    }\n    const messageHash = version === SignTypedDataVersion.V1\n        ? _typedSignatureHash(data)\n        : exports.TypedDataUtils.eip712Hash(data, version);\n    const sig = (0, util_1.ecsign)(messageHash, privateKey);\n    return (0, utils_3.concatSig)((0, util_1.arrToBufArr)((0, utils_2.bigIntToBytes)(sig.v)), sig.r, sig.s);\n}\nexports.signTypedData = signTypedData;\n/**\n * Recover the address of the account that created the given EIP-712\n * signature. The version provided must match the version used to\n * create the signature.\n *\n * @param options - The signature recovery options.\n * @param options.data - The typed data that was signed.\n * @param options.signature - The '0x-prefixed hex encoded message signature.\n * @param options.version - The signing version to use.\n * @returns The '0x'-prefixed hex address of the signer.\n */\nfunction recoverTypedSignature({ data, signature, version, }) {\n    validateVersion(version);\n    if ((0, utils_3.isNullish)(data)) {\n        throw new Error('Missing data parameter');\n    }\n    else if ((0, utils_3.isNullish)(signature)) {\n        throw new Error('Missing signature parameter');\n    }\n    const messageHash = version === SignTypedDataVersion.V1\n        ? _typedSignatureHash(data)\n        : exports.TypedDataUtils.eip712Hash(data, version);\n    const publicKey = (0, utils_3.recoverPublicKey)(messageHash, signature);\n    const sender = (0, util_1.publicToAddress)(publicKey);\n    return (0, utils_2.bytesToHex)(sender);\n}\nexports.recoverTypedSignature = recoverTypedSignature;\n//# sourceMappingURL=sign-typed-data.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L3NpZ24tdHlwZWQtZGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxxQkFBcUIsR0FBRywwQkFBMEIsR0FBRyxzQkFBc0IsR0FBRyw0QkFBNEIsR0FBRyw0QkFBNEI7QUFDekssZUFBZSxtQkFBTyxDQUFDLDZFQUFrQjtBQUN6QyxvQkFBb0IsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDakQsa0JBQWtCLG1CQUFPLENBQUMsd0dBQWtDO0FBQzVELGdCQUFnQixtQkFBTyxDQUFDLG9HQUFnQztBQUN4RCxnQkFBZ0IsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsMEZBQThCO0FBQ3ZELGdCQUFnQixtQkFBTyxDQUFDLDBFQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBEQUEwRCw0QkFBNEIsS0FBSztBQUM1Riw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRCxnQ0FBZ0MsZ0JBQWdCO0FBQ2hELHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNULHVCQUF1QixnQkFBZ0I7QUFDdkMsa0JBQWtCLGdCQUFnQjtBQUNsQyxtQkFBbUIsZ0JBQWdCO0FBQ25DLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBLDhEQUE4RCxRQUFRLDJCQUEyQiwyQkFBMkI7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSUFBZ0ksTUFBTTtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0gsTUFBTSw4QkFBOEIsS0FBSztBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxNQUFNLFVBQVUsS0FBSztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxLQUFLO0FBQ2xFO0FBQ0EscUJBQXFCLEtBQUssR0FBRztBQUM3QixvQkFBb0IsZUFBZSxRQUFRLEdBQUcsRUFBRSxLQUFLO0FBQ3JELHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCw0QkFBNEI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsbUJBQW1CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1EQUFtRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRLEVBQUUsT0FBTztBQUNuQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEJBQTRCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkJBQTJCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L3NpZ24tdHlwZWQtZGF0YS5qcz9mNTE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWNvdmVyVHlwZWRTaWduYXR1cmUgPSBleHBvcnRzLnNpZ25UeXBlZERhdGEgPSBleHBvcnRzLnR5cGVkU2lnbmF0dXJlSGFzaCA9IGV4cG9ydHMuVHlwZWREYXRhVXRpbHMgPSBleHBvcnRzLlRZUEVEX01FU1NBR0VfU0NIRU1BID0gZXhwb3J0cy5TaWduVHlwZWREYXRhVmVyc2lvbiA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpO1xuY29uc3QgYWJpX3V0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2FiaS11dGlsc1wiKTtcbmNvbnN0IHBhcnNlcnNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvcGFyc2Vyc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3V0aWxzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5jb25zdCBrZWNjYWtfMSA9IHJlcXVpcmUoXCJldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrXCIpO1xuY29uc3QgdXRpbHNfMyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB2ZXJzaW9uIG9mIGBzaWduVHlwZWREYXRhYCBiZWluZyB1c2VkLlxuICpcbiAqIFYxIGlzIGJhc2VkIHVwb24gW2FuIGVhcmx5IHZlcnNpb24gb2ZcbiAqIEVJUC03MTJdKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9FSVBzL3B1bGwvNzEyL2NvbW1pdHMvMjFhYmUyNTRmZTA0NTJkODU4M2Q1YjEzMmIxZDdiZTg3YzA0MzljYSlcbiAqIHRoYXQgbGFja2VkIHNvbWUgbGF0ZXIgc2VjdXJpdHkgaW1wcm92ZW1lbnRzLCBhbmQgc2hvdWxkIGdlbmVyYWxseSBiZSBuZWdsZWN0ZWQgaW4gZmF2b3Igb2ZcbiAqIGxhdGVyIHZlcnNpb25zLlxuICpcbiAqIFYzIGlzIGJhc2VkIG9uIEVJUC03MTIsIGV4Y2VwdCB0aGF0IGFycmF5cyBhbmQgcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBWNCBpcyBiYXNlZCBvbiBFSVAtNzEyLCBhbmQgaW5jbHVkZXMgZnVsbCBzdXBwb3J0IG9mIGFycmF5cyBhbmQgcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlcy5cbiAqL1xudmFyIFNpZ25UeXBlZERhdGFWZXJzaW9uO1xuKGZ1bmN0aW9uIChTaWduVHlwZWREYXRhVmVyc2lvbikge1xuICAgIFNpZ25UeXBlZERhdGFWZXJzaW9uW1wiVjFcIl0gPSBcIlYxXCI7XG4gICAgU2lnblR5cGVkRGF0YVZlcnNpb25bXCJWM1wiXSA9IFwiVjNcIjtcbiAgICBTaWduVHlwZWREYXRhVmVyc2lvbltcIlY0XCJdID0gXCJWNFwiO1xufSkoU2lnblR5cGVkRGF0YVZlcnNpb24gPSBleHBvcnRzLlNpZ25UeXBlZERhdGFWZXJzaW9uIHx8IChleHBvcnRzLlNpZ25UeXBlZERhdGFWZXJzaW9uID0ge30pKTtcbmV4cG9ydHMuVFlQRURfTUVTU0FHRV9TQ0hFTUEgPSB7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICB0eXBlczoge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFsnbmFtZScsICd0eXBlJ10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHByaW1hcnlUeXBlOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIGRvbWFpbjogeyB0eXBlOiAnb2JqZWN0JyB9LFxuICAgICAgICBtZXNzYWdlOiB7IHR5cGU6ICdvYmplY3QnIH0sXG4gICAgfSxcbiAgICByZXF1aXJlZDogWyd0eXBlcycsICdwcmltYXJ5VHlwZScsICdkb21haW4nLCAnbWVzc2FnZSddLFxufTtcbi8qKlxuICogVmFsaWRhdGUgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB2ZXJzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSB2ZXJzaW9uIHZhbHVlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIGFsbG93ZWRWZXJzaW9ucyAtIEEgbGlzdCBvZiBhbGxvd2VkIHZlcnNpb25zLiBJZiBvbWl0dGVkLCBhbGwgdmVyc2lvbnMgYXJlIGFzc3VtZWQgdG8gYmVcbiAqIGFsbG93ZWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBhbGxvd2VkVmVyc2lvbnMpIHtcbiAgICBpZiAoIU9iamVjdC5rZXlzKFNpZ25UeXBlZERhdGFWZXJzaW9uKS5pbmNsdWRlcyh2ZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmVyc2lvbjogJyR7dmVyc2lvbn0nYCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsbG93ZWRWZXJzaW9ucyAmJiAhYWxsb3dlZFZlcnNpb25zLmluY2x1ZGVzKHZlcnNpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2lnblR5cGVkRGF0YVZlcnNpb24gbm90IGFsbG93ZWQ6ICcke3ZlcnNpb259Jy4gQWxsb3dlZCB2ZXJzaW9ucyBhcmU6ICR7YWxsb3dlZFZlcnNpb25zLmpvaW4oJywgJyl9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZywgbnVtYmVyLCBvciBiaWdpbnQgdmFsdWUgaW50byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTnVtYmVyKHR5cGUsIHZhbHVlKSB7XG4gICAgKDAsIHV0aWxzXzIuYXNzZXJ0KSh2YWx1ZSAhPT0gbnVsbCwgYFVuYWJsZSB0byBlbmNvZGUgdmFsdWU6IEludmFsaWQgbnVtYmVyLiBFeHBlY3RlZCBhIHZhbGlkIG51bWJlciB2YWx1ZSwgYnV0IHJlY2VpdmVkIFwiJHt2YWx1ZX1cIi5gKTtcbiAgICBjb25zdCBiaWdJbnRWYWx1ZSA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgY29uc3QgbGVuZ3RoID0gKDAsIHBhcnNlcnNfMS5nZXRMZW5ndGgpKHR5cGUpO1xuICAgIGNvbnN0IG1heFZhbHVlID0gQmlnSW50KDIpICoqIEJpZ0ludChsZW5ndGgpIC0gQmlnSW50KDEpO1xuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIG5vdCBhY2N1cmF0ZSwgc2luY2UgdGhlIGFjdHVhbCBtYXhpbXVtIHZhbHVlIGZvciB1bnNpZ25lZFxuICAgIC8vIGludGVnZXJzIGlzIGAyIF4gKGxlbmd0aCAtIDEpIC0gMWAsIGJ1dCB0aGlzIGlzIHJlcXVpcmVkIGZvciBiYWNrd2FyZHNcbiAgICAvLyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIG9sZCBpbXBsZW1lbnRhdGlvbi5cbiAgICAoMCwgdXRpbHNfMi5hc3NlcnQpKGJpZ0ludFZhbHVlID49IC1tYXhWYWx1ZSAmJiBiaWdJbnRWYWx1ZSA8PSBtYXhWYWx1ZSwgYFVuYWJsZSB0byBlbmNvZGUgdmFsdWU6IE51bWJlciBcIiR7dmFsdWV9XCIgaXMgb3V0IG9mIHJhbmdlIGZvciB0eXBlIFwiJHt0eXBlfVwiLmApO1xuICAgIHJldHVybiBiaWdJbnRWYWx1ZTtcbn1cbi8qKlxuICogUGFyc2UgYW4gYWRkcmVzcyBzdHJpbmcgdG8gYSBgVWludDhBcnJheWAuIFRoZSBiZWhhdmlvdXIgb2YgdGhpcyBpcyBxdWl0ZVxuICogc3RyYW5nZSwgaW4gdGhhdCBpdCBkb2VzIG5vdCBwYXJzZSB0aGUgYWRkcmVzcyBhcyBoZXhhZGVjaW1hbCBzdHJpbmcsIG5vciBhc1xuICogVVRGLTguIEl0IGRvZXMgc29tZSB3ZWlyZCBzdHVmZiB3aXRoIHRoZSBzdHJpbmcgYW5kIGNoYXIgY29kZXMsIGFuZCB0aGVuXG4gKiByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogVGhpcyBpcyBiYXNlZCBvbiB0aGUgb2xkIGBldGhlcmV1bWpzLWFiaWAgaW1wbGVtZW50YXRpb24sIHdoaWNoIGVzc2VudGlhbGx5XG4gKiBjYWxscyBgbmV3IEJOKGFkZHJlc3MsIDEwKWAgb24gdGhlIGFkZHJlc3Mgc3RyaW5nLCB0aGUgZXF1aXZhbGVudCBvZiBjYWxsaW5nXG4gKiBgcGFyc2VJbnQoYWRkcmVzcywgMTApYCBpbiBKYXZhU2NyaXB0LiBUaGlzIGlzIG5vdCBhIHZhbGlkIHdheSB0byBwYXJzZSBhblxuICogYWRkcmVzcyBhbmQgd291bGQgcmVzdWx0IGluIGBOYU5gIGluIHBsYWluIEphdmFTY3JpcHQsIGJ1dCBpdCBpcyB0aGVcbiAqIGJlaGF2aW91ciBvZiB0aGUgb2xkIGltcGxlbWVudGF0aW9uLCBhbmQgc28gd2UgbXVzdCBwcmVzZXJ2ZSBpdCBmb3IgYmFja3dhcmRzXG4gKiBjb21wYXRpYmlsaXR5LlxuICpcbiAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIGFkZHJlc3MuXG4gKi9cbmZ1bmN0aW9uIHJlYWxseVN0cmFuZ2VBZGRyZXNzVG9CeXRlcyhhZGRyZXNzKSB7XG4gICAgbGV0IGFkZHJlc3NWYWx1ZSA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHJlc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhcmFjdGVyID0gQmlnSW50KGFkZHJlc3MuY2hhckNvZGVBdChpKSAtIDQ4KTtcbiAgICAgICAgYWRkcmVzc1ZhbHVlICo9IEJpZ0ludCgxMCk7XG4gICAgICAgIC8vICdhJ1xuICAgICAgICBpZiAoY2hhcmFjdGVyID49IDQ5KSB7XG4gICAgICAgICAgICBhZGRyZXNzVmFsdWUgKz0gY2hhcmFjdGVyIC0gQmlnSW50KDQ5KSArIEJpZ0ludCgweGEpO1xuICAgICAgICAgICAgLy8gJ0EnXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyID49IDE3KSB7XG4gICAgICAgICAgICBhZGRyZXNzVmFsdWUgKz0gY2hhcmFjdGVyIC0gQmlnSW50KDE3KSArIEJpZ0ludCgweGEpO1xuICAgICAgICAgICAgLy8gJzAnIC0gJzknXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhZGRyZXNzVmFsdWUgKz0gY2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoMCwgdXRpbHNfMS5wYWRTdGFydCkoKDAsIHV0aWxzXzIuYmlnSW50VG9CeXRlcykoYWRkcmVzc1ZhbHVlKSwgMjApO1xufVxuLyoqXG4gKiBFbmNvZGUgYSBzaW5nbGUgZmllbGQuXG4gKlxuICogQHBhcmFtIHR5cGVzIC0gQWxsIHR5cGUgZGVmaW5pdGlvbnMuXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBmaWVsZCBiZWluZyBlbmNvZGVkLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIEVJUC03MTIgdmVyc2lvbiB0aGUgZW5jb2Rpbmcgc2hvdWxkIGNvbXBseSB3aXRoLlxuICogQHJldHVybnMgRW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZmllbGQuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUZpZWxkKHR5cGVzLCBuYW1lLCB0eXBlLCBcbi8vIFRPRE86IGNvbnN0cmFpbiB0eXBlIG9uIGB2YWx1ZWBcbnZhbHVlLCB2ZXJzaW9uKSB7XG4gICAgdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24sIFtTaWduVHlwZWREYXRhVmVyc2lvbi5WMywgU2lnblR5cGVkRGF0YVZlcnNpb24uVjRdKTtcbiAgICBpZiAodHlwZXNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2J5dGVzMzInLFxuICAgICAgICAgICAgLy8gVE9ETzogcmV0dXJuIEJ1ZmZlciwgcmVtb3ZlIHN0cmluZyBmcm9tIHJldHVybiB0eXBlXG4gICAgICAgICAgICB2ZXJzaW9uID09PSBTaWduVHlwZWREYXRhVmVyc2lvbi5WNCAmJiB2YWx1ZSA9PSBudWxsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbFxuICAgICAgICAgICAgICAgID8gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgICAgICAgICAgICAgICA6ICgwLCB1dGlsXzEuYXJyVG9CdWZBcnIpKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKGVuY29kZURhdGEodHlwZSwgdmFsdWUsIHR5cGVzLCB2ZXJzaW9uKSkpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvLyBgZnVuY3Rpb25gIGlzIHN1cHBvcnRlZCBpbiBgQG1ldGFtYXNrL2FiaS11dGlsc2AsIGJ1dCBub3QgYWxsb3dlZCBieVxuICAgIC8vIEVJUC03MTIsIHNvIHdlIHRocm93IGFuIGVycm9yIGhlcmUuXG4gICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvciBpbnZhbGlkIHR5cGU6IFwiZnVuY3Rpb25cIicpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgdmFsdWUgZm9yIGZpZWxkICR7bmFtZX0gb2YgdHlwZSAke3R5cGV9YCk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2FkZHJlc3MnLCAoMCwgdXRpbHNfMS5wYWRTdGFydCkoKDAsIHV0aWxzXzIubnVtYmVyVG9CeXRlcykodmFsdWUpLCAyMCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCB1dGlsc18yLmlzU3RyaWN0SGV4U3RyaW5nKSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2FkZHJlc3MnLCAoMCwgdXRpbHNfMi5hZGQweCkodmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gWydhZGRyZXNzJywgcmVhbGx5U3RyYW5nZUFkZHJlc3NUb0J5dGVzKHZhbHVlKS5zdWJhcnJheSgwLCAyMCldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIFsnYm9vbCcsIEJvb2xlYW4odmFsdWUpXTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIHV0aWxzXzIubnVtYmVyVG9CeXRlcykodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCB1dGlsc18yLmlzU3RyaWN0SGV4U3RyaW5nKSh2YWx1ZSkgfHwgdmFsdWUgPT09ICcweCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIHV0aWxzXzIuaGV4VG9CeXRlcykodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIHV0aWxzXzIuc3RyaW5nVG9CeXRlcykodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KSh2YWx1ZSkpXTtcbiAgICB9XG4gICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSAmJiB0eXBlICE9PSAnYnl0ZXMnICYmICF0eXBlLmluY2x1ZGVzKCdbJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydieXRlczMyJywgbmV3IFVpbnQ4QXJyYXkoMzIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCAoMCwgdXRpbHNfMi5iaWdJbnRUb0J5dGVzKShCaWdJbnQodmFsdWUpKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIHV0aWxzXzIuaXNTdHJpY3RIZXhTdHJpbmcpKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsICgwLCB1dGlsc18yLmhleFRvQnl0ZXMpKHZhbHVlKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIHZhbHVlXTtcbiAgICB9XG4gICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykgJiYgIXR5cGUuaW5jbHVkZXMoJ1snKSkge1xuICAgICAgICBjb25zdCBiaWdJbnRWYWx1ZSA9IHBhcnNlTnVtYmVyKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgaWYgKGJpZ0ludFZhbHVlID49IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsndWludDI1NicsIGJpZ0ludFZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWydpbnQyNTYnLCBiaWdJbnRWYWx1ZV07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFsdWUgPSAoMCwgdXRpbHNfMi5udW1iZXJUb0J5dGVzKSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICgwLCB1dGlsc18yLnN0cmluZ1RvQnl0ZXMpKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWydieXRlczMyJywgKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoKDAsIGtlY2Nha18xLmtlY2NhazI1NikodmFsdWUpKV07XG4gICAgfVxuICAgIGlmICh0eXBlLmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5cyBhcmUgdW5pbXBsZW1lbnRlZCBpbiBlbmNvZGVEYXRhOyB1c2UgVjQgZXh0ZW5zaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHR5cGUuc2xpY2UoMCwgdHlwZS5sYXN0SW5kZXhPZignWycpKTtcbiAgICAgICAgY29uc3QgdHlwZVZhbHVlUGFpcnMgPSB2YWx1ZS5tYXAoKGl0ZW0pID0+IGVuY29kZUZpZWxkKHR5cGVzLCBuYW1lLCBwYXJzZWRUeXBlLCBpdGVtLCB2ZXJzaW9uKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnYnl0ZXMzMicsXG4gICAgICAgICAgICAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KSgoMCwgYWJpX3V0aWxzXzEuZW5jb2RlKSh0eXBlVmFsdWVQYWlycy5tYXAoKFt0XSkgPT4gdCksIHR5cGVWYWx1ZVBhaXJzLm1hcCgoWywgdl0pID0+IHYpKSkpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW3R5cGUsIHZhbHVlXTtcbn1cbi8qKlxuICogRW5jb2RlcyBhbiBvYmplY3QgYnkgZW5jb2RpbmcgYW5kIGNvbmNhdGVuYXRpbmcgZWFjaCBvZiBpdHMgbWVtYmVycy5cbiAqXG4gKiBAcGFyYW0gcHJpbWFyeVR5cGUgLSBUaGUgcm9vdCB0eXBlLlxuICogQHBhcmFtIGRhdGEgLSBUaGUgb2JqZWN0IHRvIGVuY29kZS5cbiAqIEBwYXJhbSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCB0eXBlcyBpbmNsdWRlZCBpbiB0aGUgbWVzc2FnZS5cbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIEVJUC03MTIgdmVyc2lvbiB0aGUgZW5jb2Rpbmcgc2hvdWxkIGNvbXBseSB3aXRoLlxuICogQHJldHVybnMgQW4gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZURhdGEocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB2ZXJzaW9uKSB7XG4gICAgdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24sIFtTaWduVHlwZWREYXRhVmVyc2lvbi5WMywgU2lnblR5cGVkRGF0YVZlcnNpb24uVjRdKTtcbiAgICBjb25zdCBlbmNvZGVkVHlwZXMgPSBbJ2J5dGVzMzInXTtcbiAgICBjb25zdCBlbmNvZGVkVmFsdWVzID0gW1xuICAgICAgICBoYXNoVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1twcmltYXJ5VHlwZV0pIHtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYzICYmIGRhdGFbZmllbGQubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3R5cGUsIHZhbHVlXSA9IGVuY29kZUZpZWxkKHR5cGVzLCBmaWVsZC5uYW1lLCBmaWVsZC50eXBlLCBkYXRhW2ZpZWxkLm5hbWVdLCB2ZXJzaW9uKTtcbiAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwgYWJpX3V0aWxzXzEuZW5jb2RlKShlbmNvZGVkVHlwZXMsIGVuY29kZWRWYWx1ZXMpKTtcbn1cbi8qKlxuICogRW5jb2RlcyB0aGUgdHlwZSBvZiBhbiBvYmplY3QgYnkgZW5jb2RpbmcgYSBjb21tYSBkZWxpbWl0ZWQgbGlzdCBvZiBpdHMgbWVtYmVycy5cbiAqXG4gKiBAcGFyYW0gcHJpbWFyeVR5cGUgLSBUaGUgcm9vdCB0eXBlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCB0eXBlcyBpbmNsdWRlZCBpbiB0aGUgbWVzc2FnZS5cbiAqIEByZXR1cm5zIEFuIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaW1hcnkgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgY29uc3QgdW5zb3J0ZWREZXBzID0gZmluZFR5cGVEZXBlbmRlbmNpZXMocHJpbWFyeVR5cGUsIHR5cGVzKTtcbiAgICB1bnNvcnRlZERlcHMuZGVsZXRlKHByaW1hcnlUeXBlKTtcbiAgICBjb25zdCBkZXBzID0gW3ByaW1hcnlUeXBlLCAuLi5BcnJheS5mcm9tKHVuc29ydGVkRGVwcykuc29ydCgpXTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgZGVwcykge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHR5cGUgZGVmaW5pdGlvbiBzcGVjaWZpZWQ6ICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gYCR7dHlwZX0oJHt0eXBlc1t0eXBlXVxuICAgICAgICAgICAgLm1hcCgoeyBuYW1lLCB0eXBlOiB0IH0pID0+IGAke3R9ICR7bmFtZX1gKVxuICAgICAgICAgICAgLmpvaW4oJywnKX0pYDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogRmluZHMgYWxsIHR5cGVzIHdpdGhpbiBhIHR5cGUgZGVmaW5pdGlvbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZS5cbiAqIEBwYXJhbSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCB0eXBlcyBpbmNsdWRlZCBpbiB0aGUgbWVzc2FnZS5cbiAqIEBwYXJhbSByZXN1bHRzIC0gVGhlIGN1cnJlbnQgc2V0IG9mIGFjY3VtdWxhdGVkIHR5cGVzLlxuICogQHJldHVybnMgVGhlIHNldCBvZiBhbGwgdHlwZXMgZm91bmQgaW4gdGhlIHR5cGUgZGVmaW5pdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmluZFR5cGVEZXBlbmRlbmNpZXMocHJpbWFyeVR5cGUsIHR5cGVzLCByZXN1bHRzID0gbmV3IFNldCgpKSB7XG4gICAgaWYgKHR5cGVvZiBwcmltYXJ5VHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpbmRUeXBlRGVwZW5kZW5jaWVzIGlucHV0ICR7SlNPTi5zdHJpbmdpZnkocHJpbWFyeVR5cGUpfWApO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IHByaW1hcnlUeXBlLm1hdGNoKC9eXFx3Ki91KTtcbiAgICBbcHJpbWFyeVR5cGVdID0gbWF0Y2g7XG4gICAgaWYgKHJlc3VsdHMuaGFzKHByaW1hcnlUeXBlKSB8fCB0eXBlc1twcmltYXJ5VHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgcmVzdWx0cy5hZGQocHJpbWFyeVR5cGUpO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbcHJpbWFyeVR5cGVdKSB7XG4gICAgICAgIGZpbmRUeXBlRGVwZW5kZW5jaWVzKGZpZWxkLnR5cGUsIHR5cGVzLCByZXN1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG4vKipcbiAqIEhhc2hlcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZS5cbiAqIEBwYXJhbSBkYXRhIC0gVGhlIG9iamVjdCB0byBoYXNoLlxuICogQHBhcmFtIHR5cGVzIC0gVHlwZSBkZWZpbml0aW9ucyBmb3IgYWxsIHR5cGVzIGluY2x1ZGVkIGluIHRoZSBtZXNzYWdlLlxuICogQHBhcmFtIHZlcnNpb24gLSBUaGUgRUlQLTcxMiB2ZXJzaW9uIHRoZSBlbmNvZGluZyBzaG91bGQgY29tcGx5IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBoYXNoU3RydWN0KHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdmVyc2lvbikge1xuICAgIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBbU2lnblR5cGVkRGF0YVZlcnNpb24uVjMsIFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0XSk7XG4gICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZURhdGEocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBoYXNoZWQgPSAoMCwga2VjY2FrXzEua2VjY2FrMjU2KShlbmNvZGVkKTtcbiAgICBjb25zdCBidWYgPSAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKShoYXNoZWQpO1xuICAgIHJldHVybiBidWY7XG59XG4vKipcbiAqIEhhc2hlcyB0aGUgdHlwZSBvZiBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZSB0byBoYXNoLlxuICogQHBhcmFtIHR5cGVzIC0gVHlwZSBkZWZpbml0aW9ucyBmb3IgYWxsIHR5cGVzIGluY2x1ZGVkIGluIHRoZSBtZXNzYWdlLlxuICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhlIG9iamVjdCB0eXBlLlxuICovXG5mdW5jdGlvbiBoYXNoVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpIHtcbiAgICBjb25zdCBlbmNvZGVkSGFzaFR5cGUgPSAoMCwgdXRpbHNfMi5zdHJpbmdUb0J5dGVzKShlbmNvZGVUeXBlKHByaW1hcnlUeXBlLCB0eXBlcykpO1xuICAgIHJldHVybiAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KShlbmNvZGVkSGFzaFR5cGUpKTtcbn1cbi8qKlxuICogUmVtb3ZlcyBwcm9wZXJ0aWVzIGZyb20gYSBtZXNzYWdlIG9iamVjdCB0aGF0IGFyZSBub3QgZGVmaW5lZCBwZXIgRUlQLTcxMi5cbiAqXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSB0eXBlZCBtZXNzYWdlIG9iamVjdC5cbiAqIEByZXR1cm5zIFRoZSB0eXBlZCBtZXNzYWdlIG9iamVjdCB3aXRoIG9ubHkgYWxsb3dlZCBmaWVsZHMuXG4gKi9cbmZ1bmN0aW9uIHNhbml0aXplRGF0YShkYXRhKSB7XG4gICAgY29uc3Qgc2FuaXRpemVkRGF0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGV4cG9ydHMuVFlQRURfTUVTU0FHRV9TQ0hFTUEucHJvcGVydGllcykge1xuICAgICAgICBpZiAoZGF0YVtrZXldKSB7XG4gICAgICAgICAgICBzYW5pdGl6ZWREYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCd0eXBlcycgaW4gc2FuaXRpemVkRGF0YSkge1xuICAgICAgICAvLyBUT0RPOiBGaXggdHlwZXNcbiAgICAgICAgc2FuaXRpemVkRGF0YS50eXBlcyA9IE9iamVjdC5hc3NpZ24oeyBFSVA3MTJEb21haW46IFtdIH0sIHNhbml0aXplZERhdGEudHlwZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2FuaXRpemVkRGF0YTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgRUlQLTcxMiBEb21haW4gSGFzaC5cbiAqIFRoaXMgaGFzaCBpcyB1c2VkIGF0IHRoZSB0b3Agb2YgdGhlIEVJUC03MTIgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHR5cGVkRGF0YSAtIFRoZSB0eXBlZCBtZXNzYWdlIHRvIGhhc2guXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSBFSVAtNzEyIHZlcnNpb24gdGhlIGVuY29kaW5nIHNob3VsZCBjb21wbHkgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSBkb21haW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBlaXA3MTJEb21haW5IYXNoKHR5cGVkRGF0YSwgdmVyc2lvbikge1xuICAgIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBbU2lnblR5cGVkRGF0YVZlcnNpb24uVjMsIFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0XSk7XG4gICAgY29uc3Qgc2FuaXRpemVkRGF0YSA9IHNhbml0aXplRGF0YSh0eXBlZERhdGEpO1xuICAgIGNvbnN0IHsgZG9tYWluIH0gPSBzYW5pdGl6ZWREYXRhO1xuICAgIGNvbnN0IGRvbWFpblR5cGUgPSB7IEVJUDcxMkRvbWFpbjogc2FuaXRpemVkRGF0YS50eXBlcy5FSVA3MTJEb21haW4gfTtcbiAgICByZXR1cm4gaGFzaFN0cnVjdCgnRUlQNzEyRG9tYWluJywgZG9tYWluLCBkb21haW5UeXBlLCB2ZXJzaW9uKTtcbn1cbi8qKlxuICogSGFzaCBhIHR5cGVkIG1lc3NhZ2UgYWNjb3JkaW5nIHRvIEVJUC03MTIuIFRoZSByZXR1cm5lZCBtZXNzYWdlIHN0YXJ0cyB3aXRoIHRoZSBFSVAtNzEyIHByZWZpeCxcbiAqIHdoaWNoIGlzIFwiMTkwMVwiLCBmb2xsb3dlZCBieSB0aGUgaGFzaCBvZiB0aGUgZG9tYWluIHNlcGFyYXRvciwgdGhlbiB0aGUgZGF0YSAoaWYgYW55KS5cbiAqIFRoZSByZXN1bHQgaXMgaGFzaGVkIGFnYWluIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHNpZ24gdGhlIG1lc3NhZ2UuIFRoZSByZXN1bHRpbmcgaGFzaCBtdXN0IHN0aWxsIGJlIHNpZ25lZCB0byBjcmVhdGUgYW5cbiAqIEVJUC03MTIgc2lnbmF0dXJlLlxuICpcbiAqIEBwYXJhbSB0eXBlZERhdGEgLSBUaGUgdHlwZWQgbWVzc2FnZSB0byBoYXNoLlxuICogQHBhcmFtIHZlcnNpb24gLSBUaGUgRUlQLTcxMiB2ZXJzaW9uIHRoZSBlbmNvZGluZyBzaG91bGQgY29tcGx5IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgdHlwZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZWlwNzEySGFzaCh0eXBlZERhdGEsIHZlcnNpb24pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbiwgW1NpZ25UeXBlZERhdGFWZXJzaW9uLlYzLCBTaWduVHlwZWREYXRhVmVyc2lvbi5WNF0pO1xuICAgIGNvbnN0IHNhbml0aXplZERhdGEgPSBzYW5pdGl6ZURhdGEodHlwZWREYXRhKTtcbiAgICBjb25zdCBwYXJ0cyA9IFsoMCwgdXRpbHNfMi5oZXhUb0J5dGVzKSgnMTkwMScpXTtcbiAgICBwYXJ0cy5wdXNoKGVpcDcxMkRvbWFpbkhhc2godHlwZWREYXRhLCB2ZXJzaW9uKSk7XG4gICAgaWYgKHNhbml0aXplZERhdGEucHJpbWFyeVR5cGUgIT09ICdFSVA3MTJEb21haW4nKSB7XG4gICAgICAgIHBhcnRzLnB1c2goaGFzaFN0cnVjdChcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0aGlzIGlzIGEgc3RyaW5nLCBzbyB0aGlzIHR5cGUgY2FzdCBjYW4gYmUgcmVtb3ZlZC5cbiAgICAgICAgc2FuaXRpemVkRGF0YS5wcmltYXJ5VHlwZSwgc2FuaXRpemVkRGF0YS5tZXNzYWdlLCBzYW5pdGl6ZWREYXRhLnR5cGVzLCB2ZXJzaW9uKSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KSgoMCwgdXRpbHNfMi5jb25jYXRCeXRlcykocGFydHMpKSk7XG59XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIGZvciBzaWduaW5nIHR5cGVkIGRhdGEuXG4gKi9cbmV4cG9ydHMuVHlwZWREYXRhVXRpbHMgPSB7XG4gICAgZW5jb2RlRGF0YSxcbiAgICBlbmNvZGVUeXBlLFxuICAgIGZpbmRUeXBlRGVwZW5kZW5jaWVzLFxuICAgIGhhc2hTdHJ1Y3QsXG4gICAgaGFzaFR5cGUsXG4gICAgc2FuaXRpemVEYXRhLFxuICAgIGVpcDcxMkhhc2gsXG4gICAgZWlwNzEyRG9tYWluSGFzaCxcbn07XG4vKipcbiAqIEdlbmVyYXRlIHRoZSBcIlYxXCIgaGFzaCBmb3IgdGhlIHByb3ZpZGVkIHR5cGVkIG1lc3NhZ2UuXG4gKlxuICogVGhlIGhhc2ggd2lsbCBiZSBnZW5lcmF0ZWQgaW4gYWNjb3JkYW5jZSB3aXRoIGFuIGVhcmxpZXIgdmVyc2lvbiBvZiB0aGUgRUlQLTcxMlxuICogc3BlY2lmaWNhdGlvbi4gVGhpcyBoYXNoIGlzIHVzZWQgaW4gYHNpZ25UeXBlZERhdGFfdjFgLlxuICpcbiAqIEBwYXJhbSB0eXBlZERhdGEgLSBUaGUgdHlwZWQgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIGhhc2ggcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIHRoZSBwcm92aWRlZCBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiB0eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKSB7XG4gICAgY29uc3QgaGFzaEJ1ZmZlciA9IF90eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzIuYnl0ZXNUb0hleCkoaGFzaEJ1ZmZlcik7XG59XG5leHBvcnRzLnR5cGVkU2lnbmF0dXJlSGFzaCA9IHR5cGVkU2lnbmF0dXJlSGFzaDtcbi8qKlxuICogTm9ybWFsaXplIGEgdmFsdWUsIHNvIHRoYXQgYEBtZXRhbWFzay9hYmktdXRpbHNgIGNhbiBoYW5kbGUgaXQuIFRoaXNcbiAqIG1hdGNoZXMgdGhlIGJlaGF2aW91ciBvZiB0aGUgYGV0aGVyZXVtanMtYWJpYCBsaWJyYXJ5LlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIG5vcm1hbGl6ZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBub3JtYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAoKDAsIHBhcnNlcnNfMS5pc0FycmF5VHlwZSkodHlwZSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgW2lubmVyVHlwZV0gPSAoMCwgcGFyc2Vyc18xLmdldEFycmF5VHlwZSkodHlwZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKGl0ZW0pID0+IG5vcm1hbGl6ZVZhbHVlKGlubmVyVHlwZSwgaXRlbSkpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKCgwLCB1dGlsc18yLm51bWJlclRvQnl0ZXMpKHZhbHVlKSwgMjApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgdXRpbHNfMi5pc1N0cmljdEhleFN0cmluZykodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKCgwLCB1dGlsc18yLmhleFRvQnl0ZXMpKHZhbHVlKS5zdWJhcnJheSgwLCAyMCksIDIwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKHZhbHVlLnN1YmFycmF5KDAsIDIwKSwgMjApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZS5zdGFydHNXaXRoKCdieXRlcycpICYmIHR5cGUgIT09ICdieXRlcycpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gKDAsIHBhcnNlcnNfMS5nZXRCeXRlTGVuZ3RoKSh0eXBlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBgc29saWRpdHlQYWNrKFsnYnl0ZXNOJ10sIFstMV0pYCByZXR1cm5zIGAweDAwLi4wMGAuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzIubnVtYmVyVG9CeXRlcykodmFsdWUpLnN1YmFycmF5KDAsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCB1dGlsc18yLmlzU3RyaWN0SGV4U3RyaW5nKSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMi5oZXhUb0J5dGVzKSh2YWx1ZSkuc3ViYXJyYXkoMCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3ViYXJyYXkoMCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZS5zdGFydHNXaXRoKCd1aW50JykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9ICgwLCBwYXJzZXJzXzEuZ2V0TGVuZ3RoKSh0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQuYXNJbnROKGxlbmd0aCwgQmlnSW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBGb3Igc29tZSByZWFzb24gYGV0aGVyZXVtanMtYWJpYCB0cmVhdHMgYGFkZHJlc3NgIGFuZCBgYWRkcmVzc1tdYCBkaWZmZXJlbnRseVxuICogc28gd2UgbmVlZCB0byBub3JtYWxpemUgYGFkZHJlc3NbXWAgZGlmZmVyZW50bHkuXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gbm9ybWFsaXplLlxuICogQHJldHVybnMgVGhlIG5vcm1hbGl6ZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVBZGRyZXNzZXModmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKCgwLCB1dGlsc18yLm51bWJlclRvQnl0ZXMpKHZhbHVlKSwgMzIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgdXRpbHNfMi5pc1N0cmljdEhleFN0cmluZykodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKCgwLCB1dGlsc18yLmhleFRvQnl0ZXMpKHZhbHVlKS5zdWJhcnJheSgwLCAzMiksIDMyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKHZhbHVlLnN1YmFycmF5KDAsIDMyKSwgMzIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbn1cbi8qKlxuICogRm9yIHNvbWUgcmVhc29uIGBldGhlcmV1bWpzLWFiaWAgdHJlYXRzIGBpbnROYCBhbmQgYGludE5bXWAgZGlmZmVyZW50bHlcbiAqIHNvIHdlIG5lZWQgdG8gbm9ybWFsaXplIGBpbnROW11gIGRpZmZlcmVudGx5LlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIG5vcm1hbGl6ZS5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIG5vcm1hbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBub3JtYWxpemVkIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW50ZWdlcnModHlwZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBjb25zdCBiaWdJbnRWYWx1ZSA9IHBhcnNlTnVtYmVyKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChiaWdJbnRWYWx1ZSA+PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKCgwLCB1dGlsc18yLmJpZ0ludFRvQnl0ZXMpKGJpZ0ludFZhbHVlKSwgMzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gKDAsIHBhcnNlcnNfMS5nZXRMZW5ndGgpKHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgYXNJbnROID0gQmlnSW50LmFzSW50TihsZW5ndGgsIGJpZ0ludFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMi5zaWduZWRCaWdJbnRUb0J5dGVzKShhc0ludE4sIDMyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG59XG4vKipcbiAqIEdlbmVyYXRlIHRoZSBcIlYxXCIgaGFzaCBmb3IgdGhlIHByb3ZpZGVkIHR5cGVkIG1lc3NhZ2UuXG4gKlxuICogVGhlIGhhc2ggd2lsbCBiZSBnZW5lcmF0ZWQgaW4gYWNjb3JkYW5jZSB3aXRoIGFuIGVhcmxpZXIgdmVyc2lvbiBvZiB0aGUgRUlQLTcxMlxuICogc3BlY2lmaWNhdGlvbi4gVGhpcyBoYXNoIGlzIHVzZWQgaW4gYHNpZ25UeXBlZERhdGFfdjFgLlxuICpcbiAqIEBwYXJhbSB0eXBlZERhdGEgLSBUaGUgdHlwZWQgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIHJlcHJlc2VudGluZyB0aGUgdHlwZSBvZiB0aGUgcHJvdmlkZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gX3R5cGVkU2lnbmF0dXJlSGFzaCh0eXBlZERhdGEpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignRXhwZWN0IGFyZ3VtZW50IHRvIGJlIG5vbi1lbXB0eSBhcnJheScpO1xuICAgIGlmICh0eXBlb2YgdHlwZWREYXRhICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAhKCdsZW5ndGgnIGluIHR5cGVkRGF0YSkgfHxcbiAgICAgICAgIXR5cGVkRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWREYXRhID0gdHlwZWREYXRhLm1hcCgoeyBuYW1lLCB0eXBlLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIC8vIEhhbmRsZSBhbiBlZGdlIGNhc2Ugd2l0aCBgYWRkcmVzc1tdYCB0eXBlcy5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdhZGRyZXNzW10nKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J5dGVzMzJbXScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5vcm1hbGl6ZUFkZHJlc3Nlcyh2YWx1ZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBhbiBlZGdlIGNhc2Ugd2l0aCBgaW50TltdYCB0eXBlcy5cbiAgICAgICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykgJiYgKDAsIHBhcnNlcnNfMS5pc0FycmF5VHlwZSkodHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtpbm5lclR5cGUsIGxlbmd0aF0gPSAoMCwgcGFyc2Vyc18xLmdldEFycmF5VHlwZSkodHlwZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogYGJ5dGVzMzJbJHtsZW5ndGggIT09IG51bGwgJiYgbGVuZ3RoICE9PSB2b2lkIDAgPyBsZW5ndGggOiAnJ31dYCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbm9ybWFsaXplSW50ZWdlcnMoaW5uZXJUeXBlLCB2YWx1ZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBub3JtYWxpemVWYWx1ZSh0eXBlLCB2YWx1ZSksXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IG5vcm1hbGl6ZWREYXRhLm1hcCgoZSkgPT4ge1xuICAgICAgICBpZiAoZS50eXBlICE9PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzMubGVnYWN5VG9CdWZmZXIpKGUudmFsdWUpO1xuICAgIH0pO1xuICAgIGNvbnN0IHR5cGVzID0gbm9ybWFsaXplZERhdGEubWFwKChlKSA9PiB7XG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb3IgaW52YWxpZCB0eXBlOiBcImZ1bmN0aW9uXCInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZS50eXBlO1xuICAgIH0pO1xuICAgIGNvbnN0IHNjaGVtYSA9IHR5cGVkRGF0YS5tYXAoKGUpID0+IHtcbiAgICAgICAgaWYgKCFlLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtlLnR5cGV9ICR7ZS5uYW1lfWA7XG4gICAgfSk7XG4gICAgcmV0dXJuICgwLCB1dGlsXzEuYXJyVG9CdWZBcnIpKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKCgwLCBhYmlfdXRpbHNfMS5lbmNvZGVQYWNrZWQpKFsnYnl0ZXMzMicsICdieXRlczMyJ10sIFtcbiAgICAgICAgKDAsIGtlY2Nha18xLmtlY2NhazI1NikoKDAsIGFiaV91dGlsc18xLmVuY29kZVBhY2tlZCkoWydzdHJpbmdbXSddLCBbc2NoZW1hXSwgdHJ1ZSkpLFxuICAgICAgICAoMCwga2VjY2FrXzEua2VjY2FrMjU2KSgoMCwgYWJpX3V0aWxzXzEuZW5jb2RlUGFja2VkKSh0eXBlcywgZGF0YSwgdHJ1ZSkpLFxuICAgIF0pKSk7XG59XG4vKipcbiAqIFNpZ24gdHlwZWQgZGF0YSBhY2NvcmRpbmcgdG8gRUlQLTcxMi4gVGhlIHNpZ25pbmcgZGlmZmVycyBiYXNlZCB1cG9uIHRoZSBgdmVyc2lvbmAuXG4gKlxuICogVjEgaXMgYmFzZWQgdXBvbiBbYW4gZWFybHkgdmVyc2lvbiBvZlxuICogRUlQLTcxMl0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL0VJUHMvcHVsbC83MTIvY29tbWl0cy8yMWFiZTI1NGZlMDQ1MmQ4NTgzZDViMTMyYjFkN2JlODdjMDQzOWNhKVxuICogdGhhdCBsYWNrZWQgc29tZSBsYXRlciBzZWN1cml0eSBpbXByb3ZlbWVudHMsIGFuZCBzaG91bGQgZ2VuZXJhbGx5IGJlIG5lZ2xlY3RlZCBpbiBmYXZvciBvZlxuICogbGF0ZXIgdmVyc2lvbnMuXG4gKlxuICogVjMgaXMgYmFzZWQgb24gW0VJUC03MTJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzEyKSwgZXhjZXB0IHRoYXQgYXJyYXlzIGFuZFxuICogcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBWNCBpcyBiYXNlZCBvbiBbRUlQLTcxMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03MTIpLCBhbmQgaW5jbHVkZXMgZnVsbCBzdXBwb3J0IG9mXG4gKiBhcnJheXMgYW5kIHJlY3Vyc2l2ZSBkYXRhIHN0cnVjdHVyZXMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc2lnbmluZyBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMucHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSB0byBzaWduIHdpdGguXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIHR5cGVkIGRhdGEgdG8gc2lnbi5cbiAqIEBwYXJhbSBvcHRpb25zLnZlcnNpb24gLSBUaGUgc2lnbmluZyB2ZXJzaW9uIHRvIHVzZS5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIHNpZ25hdHVyZS5cbiAqL1xuZnVuY3Rpb24gc2lnblR5cGVkRGF0YSh7IHByaXZhdGVLZXksIGRhdGEsIHZlcnNpb24sIH0pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbik7XG4gICAgaWYgKCgwLCB1dGlsc18zLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18zLmlzTnVsbGlzaCkocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByaXZhdGUga2V5IHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYxXG4gICAgICAgID8gX3R5cGVkU2lnbmF0dXJlSGFzaChkYXRhKVxuICAgICAgICA6IGV4cG9ydHMuVHlwZWREYXRhVXRpbHMuZWlwNzEySGFzaChkYXRhLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBzaWcgPSAoMCwgdXRpbF8xLmVjc2lnbikobWVzc2FnZUhhc2gsIHByaXZhdGVLZXkpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMy5jb25jYXRTaWcpKCgwLCB1dGlsXzEuYXJyVG9CdWZBcnIpKCgwLCB1dGlsc18yLmJpZ0ludFRvQnl0ZXMpKHNpZy52KSksIHNpZy5yLCBzaWcucyk7XG59XG5leHBvcnRzLnNpZ25UeXBlZERhdGEgPSBzaWduVHlwZWREYXRhO1xuLyoqXG4gKiBSZWNvdmVyIHRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRoYXQgY3JlYXRlZCB0aGUgZ2l2ZW4gRUlQLTcxMlxuICogc2lnbmF0dXJlLiBUaGUgdmVyc2lvbiBwcm92aWRlZCBtdXN0IG1hdGNoIHRoZSB2ZXJzaW9uIHVzZWQgdG9cbiAqIGNyZWF0ZSB0aGUgc2lnbmF0dXJlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHNpZ25hdHVyZSByZWNvdmVyeSBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSB0eXBlZCBkYXRhIHRoYXQgd2FzIHNpZ25lZC5cbiAqIEBwYXJhbSBvcHRpb25zLnNpZ25hdHVyZSAtIFRoZSAnMHgtcHJlZml4ZWQgaGV4IGVuY29kZWQgbWVzc2FnZSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gb3B0aW9ucy52ZXJzaW9uIC0gVGhlIHNpZ25pbmcgdmVyc2lvbiB0byB1c2UuXG4gKiBAcmV0dXJucyBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggYWRkcmVzcyBvZiB0aGUgc2lnbmVyLlxuICovXG5mdW5jdGlvbiByZWNvdmVyVHlwZWRTaWduYXR1cmUoeyBkYXRhLCBzaWduYXR1cmUsIHZlcnNpb24sIH0pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbik7XG4gICAgaWYgKCgwLCB1dGlsc18zLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18zLmlzTnVsbGlzaCkoc2lnbmF0dXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc2lnbmF0dXJlIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYxXG4gICAgICAgID8gX3R5cGVkU2lnbmF0dXJlSGFzaChkYXRhKVxuICAgICAgICA6IGV4cG9ydHMuVHlwZWREYXRhVXRpbHMuZWlwNzEySGFzaChkYXRhLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSAoMCwgdXRpbHNfMy5yZWNvdmVyUHVibGljS2V5KShtZXNzYWdlSGFzaCwgc2lnbmF0dXJlKTtcbiAgICBjb25zdCBzZW5kZXIgPSAoMCwgdXRpbF8xLnB1YmxpY1RvQWRkcmVzcykocHVibGljS2V5KTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzIuYnl0ZXNUb0hleCkoc2VuZGVyKTtcbn1cbmV4cG9ydHMucmVjb3ZlclR5cGVkU2lnbmF0dXJlID0gcmVjb3ZlclR5cGVkU2lnbmF0dXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbi10eXBlZC1kYXRhLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/eth-sig-util/dist/utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/eth-sig-util/dist/utils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.normalize = exports.recoverPublicKey = exports.concatSig = exports.legacyToBuffer = exports.isNullish = exports.padWithZeroes = void 0;\nconst util_1 = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/./node_modules/@ethereumjs/util/dist/index.js\");\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.cjs\");\n/**\n * Pads the front of the given hex string with zeroes until it reaches the\n * target length. If the input string is already longer than or equal to the\n * target length, it is returned unmodified.\n *\n * If the input string is \"0x\"-prefixed or not a hex string, an error will be\n * thrown.\n *\n * @param hexString - The hexadecimal string to pad with zeroes.\n * @param targetLength - The target length of the hexadecimal string.\n * @returns The input string front-padded with zeroes, or the original string\n * if it was already greater than or equal to to the target length.\n */\nfunction padWithZeroes(hexString, targetLength) {\n    if (hexString !== '' && !/^[a-f0-9]+$/iu.test(hexString)) {\n        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);\n    }\n    if (targetLength < 0) {\n        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);\n    }\n    return String.prototype.padStart.call(hexString, targetLength, '0');\n}\nexports.padWithZeroes = padWithZeroes;\n/**\n * Returns `true` if the given value is nullish.\n *\n * @param value - The value being checked.\n * @returns Whether the value is nullish.\n */\nfunction isNullish(value) {\n    return value === null || value === undefined;\n}\nexports.isNullish = isNullish;\n/**\n * Convert a value to a Buffer. This function should be equivalent to the `toBuffer` function in\n * `ethereumjs-util@5.2.1`.\n *\n * @param value - The value to convert to a Buffer.\n * @returns The given value as a Buffer.\n */\nfunction legacyToBuffer(value) {\n    return typeof value === 'string' && !(0, util_1.isHexString)(value)\n        ? Buffer.from(value)\n        : (0, util_1.toBuffer)(value);\n}\nexports.legacyToBuffer = legacyToBuffer;\n/**\n * Concatenate an extended ECDSA signature into a single '0x'-prefixed hex string.\n *\n * @param v - The 'v' portion of the signature.\n * @param r - The 'r' portion of the signature.\n * @param s - The 's' portion of the signature.\n * @returns The concatenated ECDSA signature as a '0x'-prefixed string.\n */\nfunction concatSig(v, r, s) {\n    const rSig = (0, util_1.fromSigned)(r);\n    const sSig = (0, util_1.fromSigned)(s);\n    const vSig = (0, util_1.bufferToInt)(v);\n    const rStr = padWithZeroes((0, util_1.toUnsigned)(rSig).toString('hex'), 64);\n    const sStr = padWithZeroes((0, util_1.toUnsigned)(sSig).toString('hex'), 64);\n    const vStr = (0, utils_1.remove0x)((0, utils_1.numberToHex)(vSig));\n    return (0, utils_1.add0x)(rStr.concat(sStr, vStr));\n}\nexports.concatSig = concatSig;\n/**\n * Recover the public key from the given signature and message hash.\n *\n * @param messageHash - The hash of the signed message.\n * @param signature - The signature.\n * @returns The public key of the signer.\n */\nfunction recoverPublicKey(messageHash, signature) {\n    const sigParams = (0, util_1.fromRpcSig)(signature);\n    return (0, util_1.ecrecover)(messageHash, sigParams.v, sigParams.r, sigParams.s);\n}\nexports.recoverPublicKey = recoverPublicKey;\n/**\n * Normalize the input to a lower-cased '0x'-prefixed hex string.\n *\n * @param input - The value to normalize.\n * @returns The normalized value.\n */\nfunction normalize(input) {\n    if (isNullish(input)) {\n        return undefined;\n    }\n    if (typeof input === 'number') {\n        if (input < 0) {\n            return '0x';\n        }\n        const buffer = (0, utils_1.numberToBytes)(input);\n        input = (0, utils_1.bytesToHex)(buffer);\n    }\n    if (typeof input !== 'string') {\n        let msg = 'eth-sig-util.normalize() requires hex string or integer input.';\n        msg += ` received ${typeof input}: ${input}`;\n        throw new Error(msg);\n    }\n    return (0, utils_1.add0x)(input.toLowerCase());\n}\nexports.normalize = normalize;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLHdCQUF3QixHQUFHLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLGlCQUFpQixHQUFHLHFCQUFxQjtBQUNySSxlQUFlLG1CQUFPLENBQUMsNkVBQWtCO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLDRFQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsVUFBVTtBQUNsRjtBQUNBO0FBQ0Esb0ZBQW9GLGFBQWE7QUFDakc7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWEsSUFBSSxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC91dGlscy5qcz9mMGM4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBleHBvcnRzLnJlY292ZXJQdWJsaWNLZXkgPSBleHBvcnRzLmNvbmNhdFNpZyA9IGV4cG9ydHMubGVnYWN5VG9CdWZmZXIgPSBleHBvcnRzLmlzTnVsbGlzaCA9IGV4cG9ydHMucGFkV2l0aFplcm9lcyA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG4vKipcbiAqIFBhZHMgdGhlIGZyb250IG9mIHRoZSBnaXZlbiBoZXggc3RyaW5nIHdpdGggemVyb2VzIHVudGlsIGl0IHJlYWNoZXMgdGhlXG4gKiB0YXJnZXQgbGVuZ3RoLiBJZiB0aGUgaW5wdXQgc3RyaW5nIGlzIGFscmVhZHkgbG9uZ2VyIHRoYW4gb3IgZXF1YWwgdG8gdGhlXG4gKiB0YXJnZXQgbGVuZ3RoLCBpdCBpcyByZXR1cm5lZCB1bm1vZGlmaWVkLlxuICpcbiAqIElmIHRoZSBpbnB1dCBzdHJpbmcgaXMgXCIweFwiLXByZWZpeGVkIG9yIG5vdCBhIGhleCBzdHJpbmcsIGFuIGVycm9yIHdpbGwgYmVcbiAqIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gaGV4U3RyaW5nIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBwYWQgd2l0aCB6ZXJvZXMuXG4gKiBAcGFyYW0gdGFyZ2V0TGVuZ3RoIC0gVGhlIHRhcmdldCBsZW5ndGggb2YgdGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBpbnB1dCBzdHJpbmcgZnJvbnQtcGFkZGVkIHdpdGggemVyb2VzLCBvciB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gKiBpZiBpdCB3YXMgYWxyZWFkeSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdG8gdGhlIHRhcmdldCBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHBhZFdpdGhaZXJvZXMoaGV4U3RyaW5nLCB0YXJnZXRMZW5ndGgpIHtcbiAgICBpZiAoaGV4U3RyaW5nICE9PSAnJyAmJiAhL15bYS1mMC05XSskL2l1LnRlc3QoaGV4U3RyaW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFuIHVucHJlZml4ZWQgaGV4IHN0cmluZy4gUmVjZWl2ZWQ6ICR7aGV4U3RyaW5nfWApO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0TGVuZ3RoIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgdGFyZ2V0IGxlbmd0aC4gUmVjZWl2ZWQ6ICR7dGFyZ2V0TGVuZ3RofWApO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5wYWRTdGFydC5jYWxsKGhleFN0cmluZywgdGFyZ2V0TGVuZ3RoLCAnMCcpO1xufVxuZXhwb3J0cy5wYWRXaXRoWmVyb2VzID0gcGFkV2l0aFplcm9lcztcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG51bGxpc2guXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGJlaW5nIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBudWxsaXNoLlxuICovXG5mdW5jdGlvbiBpc051bGxpc2godmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuaXNOdWxsaXNoID0gaXNOdWxsaXNoO1xuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBCdWZmZXIuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGVxdWl2YWxlbnQgdG8gdGhlIGB0b0J1ZmZlcmAgZnVuY3Rpb24gaW5cbiAqIGBldGhlcmV1bWpzLXV0aWxANS4yLjFgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgQnVmZmVyLlxuICogQHJldHVybnMgVGhlIGdpdmVuIHZhbHVlIGFzIGEgQnVmZmVyLlxuICovXG5mdW5jdGlvbiBsZWdhY3lUb0J1ZmZlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICEoMCwgdXRpbF8xLmlzSGV4U3RyaW5nKSh2YWx1ZSlcbiAgICAgICAgPyBCdWZmZXIuZnJvbSh2YWx1ZSlcbiAgICAgICAgOiAoMCwgdXRpbF8xLnRvQnVmZmVyKSh2YWx1ZSk7XG59XG5leHBvcnRzLmxlZ2FjeVRvQnVmZmVyID0gbGVnYWN5VG9CdWZmZXI7XG4vKipcbiAqIENvbmNhdGVuYXRlIGFuIGV4dGVuZGVkIEVDRFNBIHNpZ25hdHVyZSBpbnRvIGEgc2luZ2xlICcweCctcHJlZml4ZWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdiAtIFRoZSAndicgcG9ydGlvbiBvZiB0aGUgc2lnbmF0dXJlLlxuICogQHBhcmFtIHIgLSBUaGUgJ3InIHBvcnRpb24gb2YgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBzIC0gVGhlICdzJyBwb3J0aW9uIG9mIHRoZSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIEVDRFNBIHNpZ25hdHVyZSBhcyBhICcweCctcHJlZml4ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBjb25jYXRTaWcodiwgciwgcykge1xuICAgIGNvbnN0IHJTaWcgPSAoMCwgdXRpbF8xLmZyb21TaWduZWQpKHIpO1xuICAgIGNvbnN0IHNTaWcgPSAoMCwgdXRpbF8xLmZyb21TaWduZWQpKHMpO1xuICAgIGNvbnN0IHZTaWcgPSAoMCwgdXRpbF8xLmJ1ZmZlclRvSW50KSh2KTtcbiAgICBjb25zdCByU3RyID0gcGFkV2l0aFplcm9lcygoMCwgdXRpbF8xLnRvVW5zaWduZWQpKHJTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpO1xuICAgIGNvbnN0IHNTdHIgPSBwYWRXaXRoWmVyb2VzKCgwLCB1dGlsXzEudG9VbnNpZ25lZCkoc1NpZykudG9TdHJpbmcoJ2hleCcpLCA2NCk7XG4gICAgY29uc3QgdlN0ciA9ICgwLCB1dGlsc18xLnJlbW92ZTB4KSgoMCwgdXRpbHNfMS5udW1iZXJUb0hleCkodlNpZykpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5hZGQweCkoclN0ci5jb25jYXQoc1N0ciwgdlN0cikpO1xufVxuZXhwb3J0cy5jb25jYXRTaWcgPSBjb25jYXRTaWc7XG4vKipcbiAqIFJlY292ZXIgdGhlIHB1YmxpYyBrZXkgZnJvbSB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGFuZCBtZXNzYWdlIGhhc2guXG4gKlxuICogQHBhcmFtIG1lc3NhZ2VIYXNoIC0gVGhlIGhhc2ggb2YgdGhlIHNpZ25lZCBtZXNzYWdlLlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgcHVibGljIGtleSBvZiB0aGUgc2lnbmVyLlxuICovXG5mdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KG1lc3NhZ2VIYXNoLCBzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWdQYXJhbXMgPSAoMCwgdXRpbF8xLmZyb21ScGNTaWcpKHNpZ25hdHVyZSk7XG4gICAgcmV0dXJuICgwLCB1dGlsXzEuZWNyZWNvdmVyKShtZXNzYWdlSGFzaCwgc2lnUGFyYW1zLnYsIHNpZ1BhcmFtcy5yLCBzaWdQYXJhbXMucyk7XG59XG5leHBvcnRzLnJlY292ZXJQdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5O1xuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGlucHV0IHRvIGEgbG93ZXItY2FzZWQgJzB4Jy1wcmVmaXhlZCBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSB2YWx1ZSB0byBub3JtYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGlucHV0KSB7XG4gICAgaWYgKGlzTnVsbGlzaChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGlucHV0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuICcweCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyID0gKDAsIHV0aWxzXzEubnVtYmVyVG9CeXRlcykoaW5wdXQpO1xuICAgICAgICBpbnB1dCA9ICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKGJ1ZmZlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxldCBtc2cgPSAnZXRoLXNpZy11dGlsLm5vcm1hbGl6ZSgpIHJlcXVpcmVzIGhleCBzdHJpbmcgb3IgaW50ZWdlciBpbnB1dC4nO1xuICAgICAgICBtc2cgKz0gYCByZWNlaXZlZCAke3R5cGVvZiBpbnB1dH06ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgdXRpbHNfMS5hZGQweCkoaW5wdXQudG9Mb3dlckNhc2UoKSk7XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/eth-sig-util/dist/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/assert.cjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/assert.cjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ./errors.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/errors.cjs\");\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */\nfunction isConstructable(fn) {\n    /* istanbul ignore next */\n    return Boolean(typeof fn?.prototype?.constructor?.name === 'string');\n}\n/**\n * Attempts to obtain the message from a possible error object. If it is\n * possible to do so, any trailing period will be removed from the message;\n * otherwise an empty string is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The message without any trailing period if `error` is an object\n * with a `message` property; the string version of `error` without any trailing\n * period if it is not `undefined` or `null`; otherwise an empty string.\n */\nfunction getErrorMessageWithoutTrailingPeriod(error) {\n    // We'll add our own period.\n    return (0, errors_1.getErrorMessage)(error).replace(/\\.$/u, '');\n}\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper, message) {\n    if (isConstructable(ErrorWrapper)) {\n        return new ErrorWrapper({\n            message,\n        });\n    }\n    return ErrorWrapper({\n        message,\n    });\n}\n/**\n * The default error class that is thrown if an assertion fails.\n */\nclass AssertionError extends Error {\n    constructor(options) {\n        super(options.message);\n        this.code = 'ERR_ASSERTION';\n    }\n}\nexports.AssertionError = AssertionError;\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */\nfunction assert(value, message = 'Assertion failed.', \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    if (!value) {\n        if (message instanceof Error) {\n            throw message;\n        }\n        throw getError(ErrorWrapper, message);\n    }\n}\nexports.assert = assert;\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */\nfunction assertStruct(value, struct, errorPrefix = 'Assertion failed', \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    try {\n        (0, superstruct_1.assert)(value, struct);\n    }\n    catch (error) {\n        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`);\n    }\n}\nexports.assertStruct = assertStruct;\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */\nfunction assertExhaustive(_object) {\n    throw new Error('Invalid branch reached. Should be detected during compilation.');\n}\nexports.assertExhaustive = assertExhaustive;\n//# sourceMappingURL=assert.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYXNzZXJ0LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRyxjQUFjLEdBQUcsc0JBQXNCO0FBQ3pGLHNCQUFzQixtQkFBTyxDQUFDLHdGQUF1QjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQywyR0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQSw2Q0FBNkMsc0JBQXNCO0FBQ25FLElBQUksYUFBYTtBQUNqQjtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZLElBQUksNENBQTRDO0FBQ3BHO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYXNzZXJ0LmNqcz82MGY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRFeGhhdXN0aXZlID0gZXhwb3J0cy5hc3NlcnRTdHJ1Y3QgPSBleHBvcnRzLmFzc2VydCA9IGV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzLmNqc1wiKTtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGNvbnN0cnVjdG9yLCBpLmUuLCBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB3aXRoXG4gKiB0aGUgYG5ld2Aga2V5d29yZC5cbiAqXG4gKiBAcGFyYW0gZm4gLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgY29uc3RydWN0b3IsIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0NvbnN0cnVjdGFibGUoZm4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiBCb29sZWFuKHR5cGVvZiBmbj8ucHJvdG90eXBlPy5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ3N0cmluZycpO1xufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBvYnRhaW4gdGhlIG1lc3NhZ2UgZnJvbSBhIHBvc3NpYmxlIGVycm9yIG9iamVjdC4gSWYgaXQgaXNcbiAqIHBvc3NpYmxlIHRvIGRvIHNvLCBhbnkgdHJhaWxpbmcgcGVyaW9kIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBtZXNzYWdlO1xuICogb3RoZXJ3aXNlIGFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3Igb2JqZWN0IHRvIGdldCB0aGUgbWVzc2FnZSBmcm9tLlxuICogQHJldHVybnMgVGhlIG1lc3NhZ2Ugd2l0aG91dCBhbnkgdHJhaWxpbmcgcGVyaW9kIGlmIGBlcnJvcmAgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIGEgYG1lc3NhZ2VgIHByb3BlcnR5OyB0aGUgc3RyaW5nIHZlcnNpb24gb2YgYGVycm9yYCB3aXRob3V0IGFueSB0cmFpbGluZ1xuICogcGVyaW9kIGlmIGl0IGlzIG5vdCBgdW5kZWZpbmVkYCBvciBgbnVsbGA7IG90aGVyd2lzZSBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZVdpdGhvdXRUcmFpbGluZ1BlcmlvZChlcnJvcikge1xuICAgIC8vIFdlJ2xsIGFkZCBvdXIgb3duIHBlcmlvZC5cbiAgICByZXR1cm4gKDAsIGVycm9yc18xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IpLnJlcGxhY2UoL1xcLiQvdSwgJycpO1xufVxuLyoqXG4gKiBJbml0aWFsaXNlIGFuIHtAbGluayBBc3NlcnRpb25FcnJvckNvbnN0cnVjdG9yfSBlcnJvci5cbiAqXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHVzZS5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBUaGUgZXJyb3Igb2JqZWN0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5mdW5jdGlvbiBnZXRFcnJvcihFcnJvcldyYXBwZXIsIG1lc3NhZ2UpIHtcbiAgICBpZiAoaXNDb25zdHJ1Y3RhYmxlKEVycm9yV3JhcHBlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcldyYXBwZXIoe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBFcnJvcldyYXBwZXIoe1xuICAgICAgICBtZXNzYWdlLFxuICAgIH0pO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBlcnJvciBjbGFzcyB0aGF0IGlzIHRocm93biBpZiBhbiBhc3NlcnRpb24gZmFpbHMuXG4gKi9cbmNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcbi8qKlxuICogU2FtZSBhcyBOb2RlLmpzIGFzc2VydC5cbiAqIElmIHRoZSB2YWx1ZSBpcyBmYWxzeSwgdGhyb3dzIGFuIGVycm9yLCBkb2VzIG5vdGhpbmcgb3RoZXJ3aXNlLlxuICpcbiAqIEB0aHJvd3Mge0BsaW5rIEFzc2VydGlvbkVycm9yfSBJZiB2YWx1ZSBpcyBmYWxzeS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB0ZXN0IHRoYXQgc2hvdWxkIGJlIHRydXRoeSB0byBwYXNzLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBNZXNzYWdlIHRvIGJlIHBhc3NlZCB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9IG9yIGFuXG4gKiB7QGxpbmsgRXJyb3J9IGluc3RhbmNlIHRvIHRocm93LlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS4gSWYgYSBjdXN0b20gZXJyb3IgY2xhc3MgaXMgcHJvdmlkZWQgZm9yXG4gKiB0aGUgYG1lc3NhZ2VgIGFyZ3VtZW50LCB0aGlzIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgbWVzc2FnZSA9ICdBc3NlcnRpb24gZmFpbGVkLicsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbi8qKlxuICogQXNzZXJ0IGEgdmFsdWUgYWdhaW5zdCBhIFN1cGVyc3RydWN0IHN0cnVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBhZ2FpbnN0LlxuICogQHBhcmFtIGVycm9yUHJlZml4IC0gQSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciBtZXNzYWdlLiBEZWZhdWx0cyB0b1xuICogXCJBc3NlcnRpb24gZmFpbGVkXCIuXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRTdHJ1Y3QodmFsdWUsIHN0cnVjdCwgZXJyb3JQcmVmaXggPSAnQXNzZXJ0aW9uIGZhaWxlZCcsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgICAoMCwgc3VwZXJzdHJ1Y3RfMS5hc3NlcnQpKHZhbHVlLCBzdHJ1Y3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBgJHtlcnJvclByZWZpeH06ICR7Z2V0RXJyb3JNZXNzYWdlV2l0aG91dFRyYWlsaW5nUGVyaW9kKGVycm9yKX0uYCk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRTdHJ1Y3QgPSBhc3NlcnRTdHJ1Y3Q7XG4vKipcbiAqIFVzZSBpbiB0aGUgZGVmYXVsdCBjYXNlIG9mIGEgc3dpdGNoIHRoYXQgeW91IHdhbnQgdG8gYmUgZnVsbHkgZXhoYXVzdGl2ZS5cbiAqIFVzaW5nIHRoaXMgZnVuY3Rpb24gZm9yY2VzIHRoZSBjb21waWxlciB0byBlbmZvcmNlIGV4aGF1c3Rpdml0eSBkdXJpbmdcbiAqIGNvbXBpbGUtdGltZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCBudW1iZXIgPSAxO1xuICogc3dpdGNoIChudW1iZXIpIHtcbiAqICAgY2FzZSAwOlxuICogICAgIC4uLlxuICogICBjYXNlIDE6XG4gKiAgICAgLi4uXG4gKiAgIGRlZmF1bHQ6XG4gKiAgICAgYXNzZXJ0RXhoYXVzdGl2ZShzbmFwUHJlZml4KTtcbiAqIH1cbiAqIGBgYFxuICogQHBhcmFtIF9vYmplY3QgLSBUaGUgb2JqZWN0IG9uIHdoaWNoIHRoZSBzd2l0Y2ggaXMgYmVpbmcgb3BlcmF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEV4aGF1c3RpdmUoX29iamVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBicmFuY2ggcmVhY2hlZC4gU2hvdWxkIGJlIGRldGVjdGVkIGR1cmluZyBjb21waWxhdGlvbi4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0RXhoYXVzdGl2ZSA9IGFzc2VydEV4aGF1c3RpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/assert.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/base64.cjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/base64.cjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.base64 = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/assert.cjs\");\n/**\n * Ensure that a provided string-based struct is valid base64.\n *\n * @param struct - The string based struct.\n * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.\n * @returns A superstruct validating base64.\n */\nconst base64 = (struct, options = {}) => {\n    const paddingRequired = options.paddingRequired ?? false;\n    const characterSet = options.characterSet ?? 'base64';\n    let letters;\n    if (characterSet === 'base64') {\n        letters = String.raw `[A-Za-z0-9+\\/]`;\n    }\n    else {\n        (0, assert_1.assert)(characterSet === 'base64url');\n        letters = String.raw `[-_A-Za-z0-9]`;\n    }\n    let re;\n    if (paddingRequired) {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, 'u');\n    }\n    else {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, 'u');\n    }\n    return (0, superstruct_1.pattern)(struct, re);\n};\nexports.base64 = base64;\n//# sourceMappingURL=base64.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYmFzZTY0LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2Qsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQXVCO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLDJHQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHFCQUFxQjtBQUNoRztBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTLEVBQUUsT0FBTyxTQUFTLEVBQUUsSUFBSSxTQUFTLEVBQUU7QUFDM0U7QUFDQTtBQUNBLCtCQUErQixTQUFTLEVBQUUsT0FBTyxTQUFTLElBQUksR0FBRyxTQUFTLEVBQUUsSUFBSSxTQUFTLEVBQUU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Jhc2U2NC5janM/NjdjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFzZTY0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydC5janNcIik7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgcHJvdmlkZWQgc3RyaW5nLWJhc2VkIHN0cnVjdCBpcyB2YWxpZCBiYXNlNjQuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJpbmcgYmFzZWQgc3RydWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIHRvIHNwZWNpYWxpemUgYmFzZTY0IHZhbGlkYXRpb24uIFNlZSB7QGxpbmsgQmFzZTY0T3B0aW9uc30gZG9jdW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIEEgc3VwZXJzdHJ1Y3QgdmFsaWRhdGluZyBiYXNlNjQuXG4gKi9cbmNvbnN0IGJhc2U2NCA9IChzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHBhZGRpbmdSZXF1aXJlZCA9IG9wdGlvbnMucGFkZGluZ1JlcXVpcmVkID8/IGZhbHNlO1xuICAgIGNvbnN0IGNoYXJhY3RlclNldCA9IG9wdGlvbnMuY2hhcmFjdGVyU2V0ID8/ICdiYXNlNjQnO1xuICAgIGxldCBsZXR0ZXJzO1xuICAgIGlmIChjaGFyYWN0ZXJTZXQgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbQS1aYS16MC05K1xcL11gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoY2hhcmFjdGVyU2V0ID09PSAnYmFzZTY0dXJsJyk7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbLV9BLVphLXowLTldYDtcbiAgICB9XG4gICAgbGV0IHJlO1xuICAgIGlmIChwYWRkaW5nUmVxdWlyZWQpIHtcbiAgICAgICAgcmUgPSBuZXcgUmVnRXhwKGBeKD86JHtsZXR0ZXJzfXs0fSkqKD86JHtsZXR0ZXJzfXszfT18JHtsZXR0ZXJzfXsyfT09KT8kYCwgJ3UnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlID0gbmV3IFJlZ0V4cChgXig/OiR7bGV0dGVyc317NH0pKig/OiR7bGV0dGVyc317MiwzfXwke2xldHRlcnN9ezN9PXwke2xldHRlcnN9ezJ9PT0pPyRgLCAndScpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoc3RydWN0LCByZSk7XG59O1xuZXhwb3J0cy5iYXNlNjQgPSBiYXNlNjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/base64.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/bytes.cjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/bytes.cjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createDataView = exports.concatBytes = exports.valueToBytes = exports.base64ToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToBase64 = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;\nconst base_1 = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/index.js\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/assert.cjs\");\nconst hex_1 = __webpack_require__(/*! ./hex.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/hex.cjs\");\n// '0'.charCodeAt(0) === 48\nconst HEX_MINIMUM_NUMBER_CHARACTER = 48;\n// '9'.charCodeAt(0) === 57\nconst HEX_MAXIMUM_NUMBER_CHARACTER = 58;\nconst HEX_CHARACTER_OFFSET = 87;\n/**\n * Memoized function that returns an array to be used as a lookup table for\n * converting bytes to hexadecimal values.\n *\n * The array is created lazily and then cached for future use. The benefit of\n * this approach is that the performance of converting bytes to hex is much\n * better than if we were to call `toString(16)` on each byte.\n *\n * The downside is that the array is created once and then never garbage\n * collected. This is not a problem in practice because the array is only 256\n * elements long.\n *\n * @returns A function that returns the lookup table.\n */\nfunction getPrecomputedHexValuesBuilder() {\n    // To avoid issues with tree shaking, we need to use a function to return the\n    // array. This is because the array is only used in the `bytesToHex` function\n    // and if we were to use a global variable, the array might be removed by the\n    // tree shaker.\n    const lookupTable = [];\n    return () => {\n        if (lookupTable.length === 0) {\n            for (let i = 0; i < 256; i++) {\n                lookupTable.push(i.toString(16).padStart(2, '0'));\n            }\n        }\n        return lookupTable;\n    };\n}\n/**\n * Function implementation of the {@link getPrecomputedHexValuesBuilder}\n * function.\n */\nconst getPrecomputedHexValues = getPrecomputedHexValuesBuilder();\n/**\n * Check if a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @returns Whether the value is a `Uint8Array`.\n */\nfunction isBytes(value) {\n    return value instanceof Uint8Array;\n}\nexports.isBytes = isBytes;\n/**\n * Assert that a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @throws If the value is not a `Uint8Array`.\n */\nfunction assertIsBytes(value) {\n    (0, assert_1.assert)(isBytes(value), 'Value must be a Uint8Array.');\n}\nexports.assertIsBytes = assertIsBytes;\n/**\n * Convert a `Uint8Array` to a hexadecimal string.\n *\n * @param bytes - The bytes to convert to a hexadecimal string.\n * @returns The hexadecimal string.\n */\nfunction bytesToHex(bytes) {\n    assertIsBytes(bytes);\n    if (bytes.length === 0) {\n        return '0x';\n    }\n    const lookupTable = getPrecomputedHexValues();\n    const hexadecimal = new Array(bytes.length);\n    for (let i = 0; i < bytes.length; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        hexadecimal[i] = lookupTable[bytes[i]];\n    }\n    return (0, hex_1.add0x)(hexadecimal.join(''));\n}\nexports.bytesToHex = bytesToHex;\n/**\n * Convert a `Uint8Array` to a `bigint`.\n *\n * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.\n * To convert a two's complement encoded `Uint8Array` to a `bigint`, use\n * {@link bytesToSignedBigInt}.\n *\n * @param bytes - The bytes to convert to a `bigint`.\n * @returns The `bigint`.\n */\nfunction bytesToBigInt(bytes) {\n    assertIsBytes(bytes);\n    const hexadecimal = bytesToHex(bytes);\n    return BigInt(hexadecimal);\n}\nexports.bytesToBigInt = bytesToBigInt;\n/**\n * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are\n * encoded in two's complement.\n *\n * To convert a `Uint8Array` to an unsigned `bigint` instead, use\n * {@link bytesToBigInt}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param bytes - The bytes to convert to a signed `bigint`.\n * @returns The signed `bigint`.\n */\nfunction bytesToSignedBigInt(bytes) {\n    assertIsBytes(bytes);\n    let value = BigInt(0);\n    for (const byte of bytes) {\n        // eslint-disable-next-line no-bitwise\n        value = (value << BigInt(8)) + BigInt(byte);\n    }\n    return BigInt.asIntN(bytes.length * 8, value);\n}\nexports.bytesToSignedBigInt = bytesToSignedBigInt;\n/**\n * Convert a `Uint8Array` to a `number`.\n *\n * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.\n *\n * @param bytes - The bytes to convert to a number.\n * @returns The number.\n * @throws If the resulting number is not a safe integer.\n */\nfunction bytesToNumber(bytes) {\n    assertIsBytes(bytes);\n    const bigint = bytesToBigInt(bytes);\n    (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');\n    return Number(bigint);\n}\nexports.bytesToNumber = bytesToNumber;\n/**\n * Convert a UTF-8 encoded `Uint8Array` to a `string`.\n *\n * @param bytes - The bytes to convert to a string.\n * @returns The string.\n */\nfunction bytesToString(bytes) {\n    assertIsBytes(bytes);\n    return new TextDecoder().decode(bytes);\n}\nexports.bytesToString = bytesToString;\n/**\n * Convert a `Uint8Array` to a base64 encoded string.\n *\n * @param bytes - The bytes to convert to a base64 encoded string.\n * @returns The base64 encoded string.\n */\nfunction bytesToBase64(bytes) {\n    assertIsBytes(bytes);\n    return base_1.base64.encode(bytes);\n}\nexports.bytesToBase64 = bytesToBase64;\n/**\n * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be\n * prefixed with `0x`. It accepts even and odd length strings.\n *\n * If the value is \"0x\", an empty `Uint8Array` is returned.\n *\n * @param value - The hexadecimal string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction hexToBytes(value) {\n    // \"0x\" is often used as empty byte array.\n    if (value?.toLowerCase?.() === '0x') {\n        return new Uint8Array();\n    }\n    (0, hex_1.assertIsHexString)(value);\n    // Remove the `0x` prefix if it exists, and pad the string to have an even\n    // number of characters.\n    const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();\n    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;\n    const bytes = new Uint8Array(normalizedValue.length / 2);\n    for (let i = 0; i < bytes.length; i++) {\n        // While this is not the prettiest way to convert a hexadecimal string to a\n        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each\n        // character.\n        const c1 = normalizedValue.charCodeAt(i * 2);\n        const c2 = normalizedValue.charCodeAt(i * 2 + 1);\n        const n1 = c1 -\n            (c1 < HEX_MAXIMUM_NUMBER_CHARACTER\n                ? HEX_MINIMUM_NUMBER_CHARACTER\n                : HEX_CHARACTER_OFFSET);\n        const n2 = c2 -\n            (c2 < HEX_MAXIMUM_NUMBER_CHARACTER\n                ? HEX_MINIMUM_NUMBER_CHARACTER\n                : HEX_CHARACTER_OFFSET);\n        bytes[i] = n1 * 16 + n2;\n    }\n    return bytes;\n}\nexports.hexToBytes = hexToBytes;\n/**\n * Convert a `bigint` to a `Uint8Array`.\n *\n * This assumes that the `bigint` is an unsigned integer. To convert a signed\n * `bigint` instead, use {@link signedBigIntToBytes}.\n *\n * @param value - The bigint to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction bigIntToBytes(value) {\n    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');\n    (0, assert_1.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nexports.bigIntToBytes = bigIntToBytes;\n/**\n * Check if a `bigint` fits in a certain number of bytes.\n *\n * @param value - The `bigint` to check.\n * @param bytes - The number of bytes.\n * @returns Whether the `bigint` fits in the number of bytes.\n */\nfunction bigIntFits(value, bytes) {\n    (0, assert_1.assert)(bytes > 0);\n    /* eslint-disable no-bitwise */\n    const mask = value >> BigInt(31);\n    return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));\n    /* eslint-enable no-bitwise */\n}\n/**\n * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement\n * encoding to represent negative numbers.\n *\n * To convert an unsigned `bigint` to a `Uint8Array` instead, use\n * {@link bigIntToBytes}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param value - The number to convert to bytes.\n * @param byteLength - The length of the resulting `Uint8Array`. If the number\n * is larger than the maximum value that can be represented by the given length,\n * an error is thrown.\n * @returns The bytes as `Uint8Array`.\n */\nfunction signedBigIntToBytes(value, byteLength) {\n    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');\n    (0, assert_1.assert)(typeof byteLength === 'number', 'Byte length must be a number.');\n    (0, assert_1.assert)(byteLength > 0, 'Byte length must be greater than 0.');\n    (0, assert_1.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');\n    // ESLint doesn't like mutating function parameters, so to avoid having to\n    // disable the rule, we create a new variable.\n    let numberValue = value;\n    const bytes = new Uint8Array(byteLength);\n    for (let i = 0; i < bytes.length; i++) {\n        bytes[i] = Number(BigInt.asUintN(8, numberValue));\n        // eslint-disable-next-line no-bitwise\n        numberValue >>= BigInt(8);\n    }\n    return bytes.reverse();\n}\nexports.signedBigIntToBytes = signedBigIntToBytes;\n/**\n * Convert a `number` to a `Uint8Array`.\n *\n * @param value - The number to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n * @throws If the number is not a safe integer.\n */\nfunction numberToBytes(value) {\n    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');\n    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');\n    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nexports.numberToBytes = numberToBytes;\n/**\n * Convert a `string` to a UTF-8 encoded `Uint8Array`.\n *\n * @param value - The string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction stringToBytes(value) {\n    (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');\n    return new TextEncoder().encode(value);\n}\nexports.stringToBytes = stringToBytes;\n/**\n * Convert a base64 encoded string to a `Uint8Array`.\n *\n * @param value - The base64 encoded string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction base64ToBytes(value) {\n    (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');\n    return base_1.base64.decode(value);\n}\nexports.base64ToBytes = base64ToBytes;\n/**\n * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,\n * a `bigint`, a `number`, or a `string`.\n *\n * This will attempt to guess the type of the value based on its type and\n * contents. For more control over the conversion, use the more specific\n * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.\n *\n * If the value is a `string`, and it is prefixed with `0x`, it will be\n * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a\n * UTF-8 string. To convert a hexadecimal string to bytes without interpreting\n * it as a UTF-8 string, use {@link hexToBytes} instead.\n *\n * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed\n * `bigint` to bytes, use {@link signedBigIntToBytes} instead.\n *\n * If the value is a `Uint8Array`, it will be returned as-is.\n *\n * @param value - The value to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction valueToBytes(value) {\n    if (typeof value === 'bigint') {\n        return bigIntToBytes(value);\n    }\n    if (typeof value === 'number') {\n        return numberToBytes(value);\n    }\n    if (typeof value === 'string') {\n        if (value.startsWith('0x')) {\n            return hexToBytes(value);\n        }\n        return stringToBytes(value);\n    }\n    if (isBytes(value)) {\n        return value;\n    }\n    throw new TypeError(`Unsupported value type: \"${typeof value}\".`);\n}\nexports.valueToBytes = valueToBytes;\n/**\n * Concatenate multiple byte-like values into a single `Uint8Array`. The values\n * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses\n * {@link valueToBytes} under the hood to convert each value to bytes. Refer to\n * the documentation of that function for more information.\n *\n * @param values - The values to concatenate.\n * @returns The concatenated bytes as `Uint8Array`.\n */\nfunction concatBytes(values) {\n    const normalizedValues = new Array(values.length);\n    let byteLength = 0;\n    for (let i = 0; i < values.length; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const value = valueToBytes(values[i]);\n        normalizedValues[i] = value;\n        byteLength += value.length;\n    }\n    const bytes = new Uint8Array(byteLength);\n    for (let i = 0, offset = 0; i < normalizedValues.length; i++) {\n        // While we could simply spread the values into an array and use\n        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.\n        bytes.set(normalizedValues[i], offset);\n        offset += normalizedValues[i].length;\n    }\n    return bytes;\n}\nexports.concatBytes = concatBytes;\n/**\n * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience\n * function that avoids having to create a {@link DataView} manually, which\n * requires passing the `byteOffset` and `byteLength` parameters every time.\n *\n * Not passing the `byteOffset` and `byteLength` parameters can result in\n * unexpected behavior when the {@link Uint8Array} is a view of a larger\n * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.\n *\n * This function also supports Node.js {@link Buffer}s.\n *\n * @example\n * ```typescript\n * const bytes = new Uint8Array([1, 2, 3]);\n *\n * // This is equivalent to:\n * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n * const dataView = createDataView(bytes);\n * ```\n * @param bytes - The bytes to create the {@link DataView} from.\n * @returns The {@link DataView}.\n */\nfunction createDataView(bytes) {\n    // To maintain compatibility with Node.js, we need to check if the bytes are\n    // a Buffer. If so, we need to slice the buffer to get the underlying\n    // ArrayBuffer.\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {\n        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);\n        return new DataView(buffer);\n    }\n    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n}\nexports.createDataView = createDataView;\n//# sourceMappingURL=bytes.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYnl0ZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLDJCQUEyQixHQUFHLHFCQUFxQixHQUFHLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLDJCQUEyQixHQUFHLHFCQUFxQixHQUFHLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHLGVBQWU7QUFDblosZUFBZSxtQkFBTyxDQUFDLGtFQUFhO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLDJHQUFjO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxxR0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxvQkFBb0I7QUFDN0U7QUFDQSxJQUFJLDBCQUEwQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EseURBQXlELG9CQUFvQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixjQUFjO0FBQy9GO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0IsSUFBSSxvQkFBb0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakU7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvQkFBb0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZCQUE2QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGFBQWEsZ0JBQWdCLFFBQVEsaUJBQWlCO0FBQ3RELDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRCxJQUFJLGtCQUFrQixvQkFBb0IsMEJBQTBCO0FBQ3BFO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRCxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYnl0ZXMuY2pzP2NjYmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZURhdGFWaWV3ID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudmFsdWVUb0J5dGVzID0gZXhwb3J0cy5iYXNlNjRUb0J5dGVzID0gZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gZXhwb3J0cy5udW1iZXJUb0J5dGVzID0gZXhwb3J0cy5zaWduZWRCaWdJbnRUb0J5dGVzID0gZXhwb3J0cy5iaWdJbnRUb0J5dGVzID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5ieXRlc1RvQmFzZTY0ID0gZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gZXhwb3J0cy5ieXRlc1RvTnVtYmVyID0gZXhwb3J0cy5ieXRlc1RvU2lnbmVkQmlnSW50ID0gZXhwb3J0cy5ieXRlc1RvQmlnSW50ID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5hc3NlcnRJc0J5dGVzID0gZXhwb3J0cy5pc0J5dGVzID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIkBzY3VyZS9iYXNlXCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnQuY2pzXCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXguY2pzXCIpO1xuLy8gJzAnLmNoYXJDb2RlQXQoMCkgPT09IDQ4XG5jb25zdCBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSID0gNDg7XG4vLyAnOScuY2hhckNvZGVBdCgwKSA9PT0gNTdcbmNvbnN0IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVIgPSA1ODtcbmNvbnN0IEhFWF9DSEFSQUNURVJfT0ZGU0VUID0gODc7XG4vKipcbiAqIE1lbW9pemVkIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheSB0byBiZSB1c2VkIGFzIGEgbG9va3VwIHRhYmxlIGZvclxuICogY29udmVydGluZyBieXRlcyB0byBoZXhhZGVjaW1hbCB2YWx1ZXMuXG4gKlxuICogVGhlIGFycmF5IGlzIGNyZWF0ZWQgbGF6aWx5IGFuZCB0aGVuIGNhY2hlZCBmb3IgZnV0dXJlIHVzZS4gVGhlIGJlbmVmaXQgb2ZcbiAqIHRoaXMgYXBwcm9hY2ggaXMgdGhhdCB0aGUgcGVyZm9ybWFuY2Ugb2YgY29udmVydGluZyBieXRlcyB0byBoZXggaXMgbXVjaFxuICogYmV0dGVyIHRoYW4gaWYgd2Ugd2VyZSB0byBjYWxsIGB0b1N0cmluZygxNilgIG9uIGVhY2ggYnl0ZS5cbiAqXG4gKiBUaGUgZG93bnNpZGUgaXMgdGhhdCB0aGUgYXJyYXkgaXMgY3JlYXRlZCBvbmNlIGFuZCB0aGVuIG5ldmVyIGdhcmJhZ2VcbiAqIGNvbGxlY3RlZC4gVGhpcyBpcyBub3QgYSBwcm9ibGVtIGluIHByYWN0aWNlIGJlY2F1c2UgdGhlIGFycmF5IGlzIG9ubHkgMjU2XG4gKiBlbGVtZW50cyBsb25nLlxuICpcbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBsb29rdXAgdGFibGUuXG4gKi9cbmZ1bmN0aW9uIGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpIHtcbiAgICAvLyBUbyBhdm9pZCBpc3N1ZXMgd2l0aCB0cmVlIHNoYWtpbmcsIHdlIG5lZWQgdG8gdXNlIGEgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZVxuICAgIC8vIGFycmF5LiBUaGlzIGlzIGJlY2F1c2UgdGhlIGFycmF5IGlzIG9ubHkgdXNlZCBpbiB0aGUgYGJ5dGVzVG9IZXhgIGZ1bmN0aW9uXG4gICAgLy8gYW5kIGlmIHdlIHdlcmUgdG8gdXNlIGEgZ2xvYmFsIHZhcmlhYmxlLCB0aGUgYXJyYXkgbWlnaHQgYmUgcmVtb3ZlZCBieSB0aGVcbiAgICAvLyB0cmVlIHNoYWtlci5cbiAgICBjb25zdCBsb29rdXBUYWJsZSA9IFtdO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChsb29rdXBUYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsb29rdXBUYWJsZS5wdXNoKGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb29rdXBUYWJsZTtcbiAgICB9O1xufVxuLyoqXG4gKiBGdW5jdGlvbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUge0BsaW5rIGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcn1cbiAqIGZ1bmN0aW9uLlxuICovXG5jb25zdCBnZXRQcmVjb21wdXRlZEhleFZhbHVlcyA9IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpO1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBpc0J5dGVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheTtcbn1cbmV4cG9ydHMuaXNCeXRlcyA9IGlzQnl0ZXM7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoaXNCeXRlcyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgVWludDhBcnJheS4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNCeXRlcyA9IGFzc2VydElzQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJzB4JztcbiAgICB9XG4gICAgY29uc3QgbG9va3VwVGFibGUgPSBnZXRQcmVjb21wdXRlZEhleFZhbHVlcygpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gbmV3IEFycmF5KGJ5dGVzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBoZXhhZGVjaW1hbFtpXSA9IGxvb2t1cFRhYmxlW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkoaGV4YWRlY2ltYWwuam9pbignJykpO1xufVxuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgbnVtYmVyYCBpbnN0ZWFkLCB1c2Uge0BsaW5rIGJ5dGVzVG9OdW1iZXJ9LlxuICogVG8gY29udmVydCBhIHR3bydzIGNvbXBsZW1lbnQgZW5jb2RlZCBgVWludDhBcnJheWAgdG8gYSBgYmlnaW50YCwgdXNlXG4gKiB7QGxpbmsgYnl0ZXNUb1NpZ25lZEJpZ0ludH0uXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBgYmlnaW50YC5cbiAqIEByZXR1cm5zIFRoZSBgYmlnaW50YC5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0JpZ0ludChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gYnl0ZXNUb0hleChieXRlcyk7XG4gICAgcmV0dXJuIEJpZ0ludChoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLmJ5dGVzVG9CaWdJbnQgPSBieXRlc1RvQmlnSW50O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgc2lnbmVkIGBiaWdpbnRgLiBUaGlzIGFzc3VtZXMgdGhhdCB0aGUgYnl0ZXMgYXJlXG4gKiBlbmNvZGVkIGluIHR3bydzIGNvbXBsZW1lbnQuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhbiB1bnNpZ25lZCBgYmlnaW50YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBieXRlc1RvQmlnSW50fS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1R3byUyN3NfY29tcGxlbWVudFxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBzaWduZWQgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgc2lnbmVkIGBiaWdpbnRgLlxuICovXG5mdW5jdGlvbiBieXRlc1RvU2lnbmVkQmlnSW50KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgbGV0IHZhbHVlID0gQmlnSW50KDApO1xuICAgIGZvciAoY29uc3QgYnl0ZSBvZiBieXRlcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA8PCBCaWdJbnQoOCkpICsgQmlnSW50KGJ5dGUpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50LmFzSW50TihieXRlcy5sZW5ndGggKiA4LCB2YWx1ZSk7XG59XG5leHBvcnRzLmJ5dGVzVG9TaWduZWRCaWdJbnQgPSBieXRlc1RvU2lnbmVkQmlnSW50O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYG51bWJlcmAuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgIGluc3RlYWQsIHVzZSB7QGxpbmsgYnl0ZXNUb0JpZ0ludH0uXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgcmVzdWx0aW5nIG51bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXIoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBjb25zdCBiaWdpbnQgPSBieXRlc1RvQmlnSW50KGJ5dGVzKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShiaWdpbnQgPD0gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSwgJ051bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYnl0ZXNUb0JpZ0ludGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gTnVtYmVyKGJpZ2ludCk7XG59XG5leHBvcnRzLmJ5dGVzVG9OdW1iZXIgPSBieXRlc1RvTnVtYmVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgVVRGLTggZW5jb2RlZCBgVWludDhBcnJheWAgdG8gYSBgc3RyaW5nYC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGJ5dGVzVG9TdHJpbmc7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBieXRlc1RvQmFzZTY0KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIGJhc2VfMS5iYXNlNjQuZW5jb2RlKGJ5dGVzKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb0Jhc2U2NCA9IGJ5dGVzVG9CYXNlNjQ7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgVWludDhBcnJheWAuIFRoZSBzdHJpbmcgY2FuIG9wdGlvbmFsbHkgYmVcbiAqIHByZWZpeGVkIHdpdGggYDB4YC4gSXQgYWNjZXB0cyBldmVuIGFuZCBvZGQgbGVuZ3RoIHN0cmluZ3MuXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIFwiMHhcIiwgYW4gZW1wdHkgYFVpbnQ4QXJyYXlgIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXModmFsdWUpIHtcbiAgICAvLyBcIjB4XCIgaXMgb2Z0ZW4gdXNlZCBhcyBlbXB0eSBieXRlIGFycmF5LlxuICAgIGlmICh2YWx1ZT8udG9Mb3dlckNhc2U/LigpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICAoMCwgaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmcpKHZhbHVlKTtcbiAgICAvLyBSZW1vdmUgdGhlIGAweGAgcHJlZml4IGlmIGl0IGV4aXN0cywgYW5kIHBhZCB0aGUgc3RyaW5nIHRvIGhhdmUgYW4gZXZlblxuICAgIC8vIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICAgIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSAoMCwgaGV4XzEucmVtb3ZlMHgpKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IHN0cmlwcGVkVmFsdWUubGVuZ3RoICUgMiA9PT0gMCA/IHN0cmlwcGVkVmFsdWUgOiBgMCR7c3RyaXBwZWRWYWx1ZX1gO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobm9ybWFsaXplZFZhbHVlLmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gV2hpbGUgdGhpcyBpcyBub3QgdGhlIHByZXR0aWVzdCB3YXkgdG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhXG4gICAgICAgIC8vIGBVaW50OEFycmF5YCwgaXQgaXMgYSBsb3QgZmFzdGVyIHRoYW4gdXNpbmcgYHBhcnNlSW50YCB0byBjb252ZXJ0IGVhY2hcbiAgICAgICAgLy8gY2hhcmFjdGVyLlxuICAgICAgICBjb25zdCBjMSA9IG5vcm1hbGl6ZWRWYWx1ZS5jaGFyQ29kZUF0KGkgKiAyKTtcbiAgICAgICAgY29uc3QgYzIgPSBub3JtYWxpemVkVmFsdWUuY2hhckNvZGVBdChpICogMiArIDEpO1xuICAgICAgICBjb25zdCBuMSA9IGMxIC1cbiAgICAgICAgICAgIChjMSA8IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA/IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA6IEhFWF9DSEFSQUNURVJfT0ZGU0VUKTtcbiAgICAgICAgY29uc3QgbjIgPSBjMiAtXG4gICAgICAgICAgICAoYzIgPCBIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgPyBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgOiBIRVhfQ0hBUkFDVEVSX09GRlNFVCk7XG4gICAgICAgIGJ5dGVzW2ldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAuXG4gKlxuICogVGhpcyBhc3N1bWVzIHRoYXQgdGhlIGBiaWdpbnRgIGlzIGFuIHVuc2lnbmVkIGludGVnZXIuIFRvIGNvbnZlcnQgYSBzaWduZWRcbiAqIGBiaWdpbnRgIGluc3RlYWQsIHVzZSB7QGxpbmsgc2lnbmVkQmlnSW50VG9CeXRlc30uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGJpZ2ludCB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmlnSW50VG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcsICdWYWx1ZSBtdXN0IGJlIGEgYmlnaW50LicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IEJpZ0ludCgwKSwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgYmlnaW50LicpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXhUb0J5dGVzKGhleGFkZWNpbWFsKTtcbn1cbmV4cG9ydHMuYmlnSW50VG9CeXRlcyA9IGJpZ0ludFRvQnl0ZXM7XG4vKipcbiAqIENoZWNrIGlmIGEgYGJpZ2ludGAgZml0cyBpbiBhIGNlcnRhaW4gbnVtYmVyIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBgYmlnaW50YCB0byBjaGVjay5cbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBgYmlnaW50YCBmaXRzIGluIHRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGJpZ0ludEZpdHModmFsdWUsIGJ5dGVzKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYnl0ZXMgPiAwKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgY29uc3QgbWFzayA9IHZhbHVlID4+IEJpZ0ludCgzMSk7XG4gICAgcmV0dXJuICEoKCh+dmFsdWUgJiBtYXNrKSArICh2YWx1ZSAmIH5tYXNrKSkgPj4gQmlnSW50KGJ5dGVzICogOCArIH4wKSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG59XG4vKipcbiAqIENvbnZlcnQgYSBzaWduZWQgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAuIFRoaXMgdXNlcyB0d28ncyBjb21wbGVtZW50XG4gKiBlbmNvZGluZyB0byByZXByZXNlbnQgbmVnYXRpdmUgbnVtYmVycy5cbiAqXG4gKiBUbyBjb252ZXJ0IGFuIHVuc2lnbmVkIGBiaWdpbnRgIHRvIGEgYFVpbnQ4QXJyYXlgIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGJpZ0ludFRvQnl0ZXN9LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdvJTI3c19jb21wbGVtZW50XG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcGFyYW0gYnl0ZUxlbmd0aCAtIFRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyBgVWludDhBcnJheWAuIElmIHRoZSBudW1iZXJcbiAqIGlzIGxhcmdlciB0aGFuIHRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBsZW5ndGgsXG4gKiBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBzaWduZWRCaWdJbnRUb0J5dGVzKHZhbHVlLCBieXRlTGVuZ3RoKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIGJ5dGVMZW5ndGggPT09ICdudW1iZXInLCAnQnl0ZSBsZW5ndGggbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShieXRlTGVuZ3RoID4gMCwgJ0J5dGUgbGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYmlnSW50Rml0cyh2YWx1ZSwgYnl0ZUxlbmd0aCksICdCeXRlIGxlbmd0aCBpcyB0b28gc21hbGwgdG8gcmVwcmVzZW50IHRoZSBnaXZlbiB2YWx1ZS4nKTtcbiAgICAvLyBFU0xpbnQgZG9lc24ndCBsaWtlIG11dGF0aW5nIGZ1bmN0aW9uIHBhcmFtZXRlcnMsIHNvIHRvIGF2b2lkIGhhdmluZyB0b1xuICAgIC8vIGRpc2FibGUgdGhlIHJ1bGUsIHdlIGNyZWF0ZSBhIG5ldyB2YXJpYWJsZS5cbiAgICBsZXQgbnVtYmVyVmFsdWUgPSB2YWx1ZTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBOdW1iZXIoQmlnSW50LmFzVWludE4oOCwgbnVtYmVyVmFsdWUpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgbnVtYmVyVmFsdWUgPj49IEJpZ0ludCg4KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzLnJldmVyc2UoKTtcbn1cbmV4cG9ydHMuc2lnbmVkQmlnSW50VG9CeXRlcyA9IHNpZ25lZEJpZ0ludFRvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgbnVtYmVyYCB0byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICogQHRocm93cyBJZiB0aGUgbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdWYWx1ZSBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IDAsICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYmlnSW50VG9CeXRlc2AgaW5zdGVhZC4nKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLm51bWJlclRvQnl0ZXMgPSBudW1iZXJUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYHN0cmluZ2AgdG8gYSBVVEYtOCBlbmNvZGVkIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJywgJ1ZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG59XG5leHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLCAnVmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICByZXR1cm4gYmFzZV8xLmJhc2U2NC5kZWNvZGUodmFsdWUpO1xufVxuZXhwb3J0cy5iYXNlNjRUb0J5dGVzID0gYmFzZTY0VG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGJ5dGUtbGlrZSB2YWx1ZSB0byBhIGBVaW50OEFycmF5YC4gVGhlIHZhbHVlIGNhbiBiZSBhIGBVaW50OEFycmF5YCxcbiAqIGEgYGJpZ2ludGAsIGEgYG51bWJlcmAsIG9yIGEgYHN0cmluZ2AuXG4gKlxuICogVGhpcyB3aWxsIGF0dGVtcHQgdG8gZ3Vlc3MgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIGJhc2VkIG9uIGl0cyB0eXBlIGFuZFxuICogY29udGVudHMuIEZvciBtb3JlIGNvbnRyb2wgb3ZlciB0aGUgY29udmVyc2lvbiwgdXNlIHRoZSBtb3JlIHNwZWNpZmljXG4gKiBjb252ZXJzaW9uIGZ1bmN0aW9ucywgc3VjaCBhcyB7QGxpbmsgaGV4VG9CeXRlc30gb3Ige0BsaW5rIHN0cmluZ1RvQnl0ZXN9LlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGBzdHJpbmdgLCBhbmQgaXQgaXMgcHJlZml4ZWQgd2l0aCBgMHhgLCBpdCB3aWxsIGJlXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIHN0cmluZy4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGludGVycHJldGVkIGFzIGFcbiAqIFVURi04IHN0cmluZy4gVG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBieXRlcyB3aXRob3V0IGludGVycHJldGluZ1xuICogaXQgYXMgYSBVVEYtOCBzdHJpbmcsIHVzZSB7QGxpbmsgaGV4VG9CeXRlc30gaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgYXNzdW1lZCB0byBiZSB1bnNpZ25lZC4gVG8gY29udmVydCBhIHNpZ25lZFxuICogYGJpZ2ludGAgdG8gYnl0ZXMsIHVzZSB7QGxpbmsgc2lnbmVkQmlnSW50VG9CeXRlc30gaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgVWludDhBcnJheWAsIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiB2YWx1ZVRvQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICByZXR1cm4gYmlnSW50VG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBudW1iZXJUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHZhbHVlIHR5cGU6IFwiJHt0eXBlb2YgdmFsdWV9XCIuYCk7XG59XG5leHBvcnRzLnZhbHVlVG9CeXRlcyA9IHZhbHVlVG9CeXRlcztcbi8qKlxuICogQ29uY2F0ZW5hdGUgbXVsdGlwbGUgYnl0ZS1saWtlIHZhbHVlcyBpbnRvIGEgc2luZ2xlIGBVaW50OEFycmF5YC4gVGhlIHZhbHVlc1xuICogY2FuIGJlIGBVaW50OEFycmF5YCwgYGJpZ2ludGAsIGBudW1iZXJgLCBvciBgc3RyaW5nYC4gVGhpcyB1c2VzXG4gKiB7QGxpbmsgdmFsdWVUb0J5dGVzfSB1bmRlciB0aGUgaG9vZCB0byBjb252ZXJ0IGVhY2ggdmFsdWUgdG8gYnl0ZXMuIFJlZmVyIHRvXG4gKiB0aGUgZG9jdW1lbnRhdGlvbiBvZiB0aGF0IGZ1bmN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKHZhbHVlcykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZXMgPSBuZXcgQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgbGV0IGJ5dGVMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVUb0J5dGVzKHZhbHVlc1tpXSk7XG4gICAgICAgIG5vcm1hbGl6ZWRWYWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgYnl0ZUxlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCBub3JtYWxpemVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFdoaWxlIHdlIGNvdWxkIHNpbXBseSBzcHJlYWQgdGhlIHZhbHVlcyBpbnRvIGFuIGFycmF5IGFuZCB1c2VcbiAgICAgICAgLy8gYFVpbnQ4QXJyYXkuZnJvbWAsIHRoYXQgaXMgYSBsb3Qgc2xvd2VyIHRoYW4gdXNpbmcgYFVpbnQ4QXJyYXkuc2V0YC5cbiAgICAgICAgYnl0ZXMuc2V0KG5vcm1hbGl6ZWRWYWx1ZXNbaV0sIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBub3JtYWxpemVkVmFsdWVzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuLyoqXG4gKiBDcmVhdGUgYSB7QGxpbmsgRGF0YVZpZXd9IGZyb20gYSB7QGxpbmsgVWludDhBcnJheX0uIFRoaXMgaXMgYSBjb252ZW5pZW5jZVxuICogZnVuY3Rpb24gdGhhdCBhdm9pZHMgaGF2aW5nIHRvIGNyZWF0ZSBhIHtAbGluayBEYXRhVmlld30gbWFudWFsbHksIHdoaWNoXG4gKiByZXF1aXJlcyBwYXNzaW5nIHRoZSBgYnl0ZU9mZnNldGAgYW5kIGBieXRlTGVuZ3RoYCBwYXJhbWV0ZXJzIGV2ZXJ5IHRpbWUuXG4gKlxuICogTm90IHBhc3NpbmcgdGhlIGBieXRlT2Zmc2V0YCBhbmQgYGJ5dGVMZW5ndGhgIHBhcmFtZXRlcnMgY2FuIHJlc3VsdCBpblxuICogdW5leHBlY3RlZCBiZWhhdmlvciB3aGVuIHRoZSB7QGxpbmsgVWludDhBcnJheX0gaXMgYSB2aWV3IG9mIGEgbGFyZ2VyXG4gKiB7QGxpbmsgQXJyYXlCdWZmZXJ9LCBlLmcuLCB3aGVuIHVzaW5nIHtAbGluayBVaW50OEFycmF5LnN1YmFycmF5fS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsc28gc3VwcG9ydHMgTm9kZS5qcyB7QGxpbmsgQnVmZmVyfXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKTtcbiAqXG4gKiAvLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG86XG4gKiAvLyBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICogY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVEYXRhVmlldyhieXRlcyk7XG4gKiBgYGBcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjcmVhdGUgdGhlIHtAbGluayBEYXRhVmlld30gZnJvbS5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgRGF0YVZpZXd9LlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYXRhVmlldyhieXRlcykge1xuICAgIC8vIFRvIG1haW50YWluIGNvbXBhdGliaWxpdHkgd2l0aCBOb2RlLmpzLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBieXRlcyBhcmVcbiAgICAvLyBhIEJ1ZmZlci4gSWYgc28sIHdlIG5lZWQgdG8gc2xpY2UgdGhlIGJ1ZmZlciB0byBnZXQgdGhlIHVuZGVybHlpbmdcbiAgICAvLyBBcnJheUJ1ZmZlci5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGJ5dGVzIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ5dGVzLmJ1ZmZlci5zbGljZShieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlT2Zmc2V0ICsgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xufVxuZXhwb3J0cy5jcmVhdGVEYXRhVmlldyA9IGNyZWF0ZURhdGFWaWV3O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/bytes.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/caip-types.cjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/caip-types.cjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toCaipChainId = exports.parseCaipAccountId = exports.parseCaipChainId = exports.isCaipAccountAddress = exports.isCaipAccountId = exports.isCaipReference = exports.isCaipNamespace = exports.isCaipChainId = exports.KnownCaipNamespace = exports.CaipAccountAddressStruct = exports.CaipAccountIdStruct = exports.CaipReferenceStruct = exports.CaipNamespaceStruct = exports.CaipChainIdStruct = exports.CAIP_ACCOUNT_ADDRESS_REGEX = exports.CAIP_ACCOUNT_ID_REGEX = exports.CAIP_REFERENCE_REGEX = exports.CAIP_NAMESPACE_REGEX = exports.CAIP_CHAIN_ID_REGEX = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nexports.CAIP_CHAIN_ID_REGEX = /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})$/u;\nexports.CAIP_NAMESPACE_REGEX = /^[-a-z0-9]{3,8}$/u;\nexports.CAIP_REFERENCE_REGEX = /^[-_a-zA-Z0-9]{1,32}$/u;\nexports.CAIP_ACCOUNT_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})):(?<accountAddress>[-.%a-zA-Z0-9]{1,128})$/u;\nexports.CAIP_ACCOUNT_ADDRESS_REGEX = /^[-.%a-zA-Z0-9]{1,128}$/u;\n/**\n * A CAIP-2 chain ID, i.e., a human-readable namespace and reference.\n */\nexports.CaipChainIdStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), exports.CAIP_CHAIN_ID_REGEX);\n/**\n * A CAIP-2 namespace, i.e., the first part of a CAIP chain ID.\n */\nexports.CaipNamespaceStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), exports.CAIP_NAMESPACE_REGEX);\n/**\n * A CAIP-2 reference, i.e., the second part of a CAIP chain ID.\n */\nexports.CaipReferenceStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), exports.CAIP_REFERENCE_REGEX);\n/**\n * A CAIP-10 account ID, i.e., a human-readable namespace, reference, and account address.\n */\nexports.CaipAccountIdStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), exports.CAIP_ACCOUNT_ID_REGEX);\n/**\n * A CAIP-10 account address, i.e., the third part of the CAIP account ID.\n */\nexports.CaipAccountAddressStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), exports.CAIP_ACCOUNT_ADDRESS_REGEX);\n/** Known CAIP namespaces. */\nvar KnownCaipNamespace;\n(function (KnownCaipNamespace) {\n    /** EIP-155 compatible chains. */\n    KnownCaipNamespace[\"Eip155\"] = \"eip155\";\n})(KnownCaipNamespace = exports.KnownCaipNamespace || (exports.KnownCaipNamespace = {}));\n/**\n * Check if the given value is a {@link CaipChainId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipChainId}.\n */\nfunction isCaipChainId(value) {\n    return (0, superstruct_1.is)(value, exports.CaipChainIdStruct);\n}\nexports.isCaipChainId = isCaipChainId;\n/**\n * Check if the given value is a {@link CaipNamespace}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipNamespace}.\n */\nfunction isCaipNamespace(value) {\n    return (0, superstruct_1.is)(value, exports.CaipNamespaceStruct);\n}\nexports.isCaipNamespace = isCaipNamespace;\n/**\n * Check if the given value is a {@link CaipReference}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipReference}.\n */\nfunction isCaipReference(value) {\n    return (0, superstruct_1.is)(value, exports.CaipReferenceStruct);\n}\nexports.isCaipReference = isCaipReference;\n/**\n * Check if the given value is a {@link CaipAccountId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAccountId}.\n */\nfunction isCaipAccountId(value) {\n    return (0, superstruct_1.is)(value, exports.CaipAccountIdStruct);\n}\nexports.isCaipAccountId = isCaipAccountId;\n/**\n * Check if a value is a {@link CaipAccountAddress}.\n *\n * @param value - The value to validate.\n * @returns True if the value is a valid {@link CaipAccountAddress}.\n */\nfunction isCaipAccountAddress(value) {\n    return (0, superstruct_1.is)(value, exports.CaipAccountAddressStruct);\n}\nexports.isCaipAccountAddress = isCaipAccountAddress;\n/**\n * Parse a CAIP-2 chain ID to an object containing the namespace and reference.\n * This validates the CAIP-2 chain ID before parsing it.\n *\n * @param caipChainId - The CAIP-2 chain ID to validate and parse.\n * @returns The parsed CAIP-2 chain ID.\n */\nfunction parseCaipChainId(caipChainId) {\n    const match = exports.CAIP_CHAIN_ID_REGEX.exec(caipChainId);\n    if (!match?.groups) {\n        throw new Error('Invalid CAIP chain ID.');\n    }\n    return {\n        namespace: match.groups.namespace,\n        reference: match.groups.reference,\n    };\n}\nexports.parseCaipChainId = parseCaipChainId;\n/**\n * Parse an CAIP-10 account ID to an object containing the chain ID, parsed chain ID, and account address.\n * This validates the CAIP-10 account ID before parsing it.\n *\n * @param caipAccountId - The CAIP-10 account ID to validate and parse.\n * @returns The parsed CAIP-10 account ID.\n */\nfunction parseCaipAccountId(caipAccountId) {\n    const match = exports.CAIP_ACCOUNT_ID_REGEX.exec(caipAccountId);\n    if (!match?.groups) {\n        throw new Error('Invalid CAIP account ID.');\n    }\n    return {\n        address: match.groups.accountAddress,\n        chainId: match.groups.chainId,\n        chain: {\n            namespace: match.groups.namespace,\n            reference: match.groups.reference,\n        },\n    };\n}\nexports.parseCaipAccountId = parseCaipAccountId;\n/**\n * Chain ID as defined per the CAIP-2\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md}.\n *\n * It defines a way to uniquely identify any blockchain in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identify of a blockchain within a given namespace.\n * @throws {@link Error}\n * This exception is thrown if the inputs does not comply with the CAIP-2\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md#syntax}.\n * @returns A CAIP chain ID.\n */\nfunction toCaipChainId(namespace, reference) {\n    if (!isCaipNamespace(namespace)) {\n        throw new Error(`Invalid \"namespace\", must match: ${exports.CAIP_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipReference(reference)) {\n        throw new Error(`Invalid \"reference\", must match: ${exports.CAIP_REFERENCE_REGEX.toString()}`);\n    }\n    return `${namespace}:${reference}`;\n}\nexports.toCaipChainId = toCaipChainId;\n//# sourceMappingURL=caip-types.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2FpcC10eXBlcy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsMEJBQTBCLEdBQUcsd0JBQXdCLEdBQUcsNEJBQTRCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcscUJBQXFCLEdBQUcsMEJBQTBCLEdBQUcsZ0NBQWdDLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcseUJBQXlCLEdBQUcsa0NBQWtDLEdBQUcsNkJBQTZCLEdBQUcsNEJBQTRCLEdBQUcsNEJBQTRCLEdBQUcsMkJBQTJCO0FBQ3ppQixzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBdUI7QUFDckQsMkJBQTJCLDRCQUE0QixJQUFJLDZCQUE2QixLQUFLO0FBQzdGLDRCQUE0QixlQUFlLElBQUk7QUFDL0MsNEJBQTRCLG1CQUFtQixLQUFLO0FBQ3BELDZCQUE2Qix1Q0FBdUMsSUFBSSw2QkFBNkIsS0FBSyxvQ0FBb0MsTUFBTTtBQUNwSixrQ0FBa0Msb0JBQW9CLE1BQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0QsMEJBQTBCLEtBQUs7QUFDdEY7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0EsMENBQTBDLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxJQUFJLHVFQUF1RTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLElBQUksOEVBQThFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHdDQUF3QztBQUNwRztBQUNBO0FBQ0EsNERBQTRELHdDQUF3QztBQUNwRztBQUNBLGNBQWMsVUFBVSxHQUFHLFVBQVU7QUFDckM7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2FpcC10eXBlcy5janM/OTYzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9DYWlwQ2hhaW5JZCA9IGV4cG9ydHMucGFyc2VDYWlwQWNjb3VudElkID0gZXhwb3J0cy5wYXJzZUNhaXBDaGFpbklkID0gZXhwb3J0cy5pc0NhaXBBY2NvdW50QWRkcmVzcyA9IGV4cG9ydHMuaXNDYWlwQWNjb3VudElkID0gZXhwb3J0cy5pc0NhaXBSZWZlcmVuY2UgPSBleHBvcnRzLmlzQ2FpcE5hbWVzcGFjZSA9IGV4cG9ydHMuaXNDYWlwQ2hhaW5JZCA9IGV4cG9ydHMuS25vd25DYWlwTmFtZXNwYWNlID0gZXhwb3J0cy5DYWlwQWNjb3VudEFkZHJlc3NTdHJ1Y3QgPSBleHBvcnRzLkNhaXBBY2NvdW50SWRTdHJ1Y3QgPSBleHBvcnRzLkNhaXBSZWZlcmVuY2VTdHJ1Y3QgPSBleHBvcnRzLkNhaXBOYW1lc3BhY2VTdHJ1Y3QgPSBleHBvcnRzLkNhaXBDaGFpbklkU3RydWN0ID0gZXhwb3J0cy5DQUlQX0FDQ09VTlRfQUREUkVTU19SRUdFWCA9IGV4cG9ydHMuQ0FJUF9BQ0NPVU5UX0lEX1JFR0VYID0gZXhwb3J0cy5DQUlQX1JFRkVSRU5DRV9SRUdFWCA9IGV4cG9ydHMuQ0FJUF9OQU1FU1BBQ0VfUkVHRVggPSBleHBvcnRzLkNBSVBfQ0hBSU5fSURfUkVHRVggPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zdXBlcnN0cnVjdFwiKTtcbmV4cG9ydHMuQ0FJUF9DSEFJTl9JRF9SRUdFWCA9IC9eKD88bmFtZXNwYWNlPlstYS16MC05XXszLDh9KTooPzxyZWZlcmVuY2U+Wy1fYS16QS1aMC05XXsxLDMyfSkkL3U7XG5leHBvcnRzLkNBSVBfTkFNRVNQQUNFX1JFR0VYID0gL15bLWEtejAtOV17Myw4fSQvdTtcbmV4cG9ydHMuQ0FJUF9SRUZFUkVOQ0VfUkVHRVggPSAvXlstX2EtekEtWjAtOV17MSwzMn0kL3U7XG5leHBvcnRzLkNBSVBfQUNDT1VOVF9JRF9SRUdFWCA9IC9eKD88Y2hhaW5JZD4oPzxuYW1lc3BhY2U+Wy1hLXowLTldezMsOH0pOig/PHJlZmVyZW5jZT5bLV9hLXpBLVowLTldezEsMzJ9KSk6KD88YWNjb3VudEFkZHJlc3M+Wy0uJWEtekEtWjAtOV17MSwxMjh9KSQvdTtcbmV4cG9ydHMuQ0FJUF9BQ0NPVU5UX0FERFJFU1NfUkVHRVggPSAvXlstLiVhLXpBLVowLTldezEsMTI4fSQvdTtcbi8qKlxuICogQSBDQUlQLTIgY2hhaW4gSUQsIGkuZS4sIGEgaHVtYW4tcmVhZGFibGUgbmFtZXNwYWNlIGFuZCByZWZlcmVuY2UuXG4gKi9cbmV4cG9ydHMuQ2FpcENoYWluSWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGV4cG9ydHMuQ0FJUF9DSEFJTl9JRF9SRUdFWCk7XG4vKipcbiAqIEEgQ0FJUC0yIG5hbWVzcGFjZSwgaS5lLiwgdGhlIGZpcnN0IHBhcnQgb2YgYSBDQUlQIGNoYWluIElELlxuICovXG5leHBvcnRzLkNhaXBOYW1lc3BhY2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGV4cG9ydHMuQ0FJUF9OQU1FU1BBQ0VfUkVHRVgpO1xuLyoqXG4gKiBBIENBSVAtMiByZWZlcmVuY2UsIGkuZS4sIHRoZSBzZWNvbmQgcGFydCBvZiBhIENBSVAgY2hhaW4gSUQuXG4gKi9cbmV4cG9ydHMuQ2FpcFJlZmVyZW5jZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgZXhwb3J0cy5DQUlQX1JFRkVSRU5DRV9SRUdFWCk7XG4vKipcbiAqIEEgQ0FJUC0xMCBhY2NvdW50IElELCBpLmUuLCBhIGh1bWFuLXJlYWRhYmxlIG5hbWVzcGFjZSwgcmVmZXJlbmNlLCBhbmQgYWNjb3VudCBhZGRyZXNzLlxuICovXG5leHBvcnRzLkNhaXBBY2NvdW50SWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGV4cG9ydHMuQ0FJUF9BQ0NPVU5UX0lEX1JFR0VYKTtcbi8qKlxuICogQSBDQUlQLTEwIGFjY291bnQgYWRkcmVzcywgaS5lLiwgdGhlIHRoaXJkIHBhcnQgb2YgdGhlIENBSVAgYWNjb3VudCBJRC5cbiAqL1xuZXhwb3J0cy5DYWlwQWNjb3VudEFkZHJlc3NTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGV4cG9ydHMuQ0FJUF9BQ0NPVU5UX0FERFJFU1NfUkVHRVgpO1xuLyoqIEtub3duIENBSVAgbmFtZXNwYWNlcy4gKi9cbnZhciBLbm93bkNhaXBOYW1lc3BhY2U7XG4oZnVuY3Rpb24gKEtub3duQ2FpcE5hbWVzcGFjZSkge1xuICAgIC8qKiBFSVAtMTU1IGNvbXBhdGlibGUgY2hhaW5zLiAqL1xuICAgIEtub3duQ2FpcE5hbWVzcGFjZVtcIkVpcDE1NVwiXSA9IFwiZWlwMTU1XCI7XG59KShLbm93bkNhaXBOYW1lc3BhY2UgPSBleHBvcnRzLktub3duQ2FpcE5hbWVzcGFjZSB8fCAoZXhwb3J0cy5Lbm93bkNhaXBOYW1lc3BhY2UgPSB7fSkpO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcENoYWluSWR9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEge0BsaW5rIENhaXBDaGFpbklkfS5cbiAqL1xuZnVuY3Rpb24gaXNDYWlwQ2hhaW5JZCh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuQ2FpcENoYWluSWRTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0NhaXBDaGFpbklkID0gaXNDYWlwQ2hhaW5JZDtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEge0BsaW5rIENhaXBOYW1lc3BhY2V9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEge0BsaW5rIENhaXBOYW1lc3BhY2V9LlxuICovXG5mdW5jdGlvbiBpc0NhaXBOYW1lc3BhY2UodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkNhaXBOYW1lc3BhY2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0NhaXBOYW1lc3BhY2UgPSBpc0NhaXBOYW1lc3BhY2U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHtAbGluayBDYWlwUmVmZXJlbmNlfS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHtAbGluayBDYWlwUmVmZXJlbmNlfS5cbiAqL1xuZnVuY3Rpb24gaXNDYWlwUmVmZXJlbmNlKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5DYWlwUmVmZXJlbmNlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNDYWlwUmVmZXJlbmNlID0gaXNDYWlwUmVmZXJlbmNlO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcEFjY291bnRJZH0uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcEFjY291bnRJZH0uXG4gKi9cbmZ1bmN0aW9uIGlzQ2FpcEFjY291bnRJZCh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuQ2FpcEFjY291bnRJZFN0cnVjdCk7XG59XG5leHBvcnRzLmlzQ2FpcEFjY291bnRJZCA9IGlzQ2FpcEFjY291bnRJZDtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHtAbGluayBDYWlwQWNjb3VudEFkZHJlc3N9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIENhaXBBY2NvdW50QWRkcmVzc30uXG4gKi9cbmZ1bmN0aW9uIGlzQ2FpcEFjY291bnRBZGRyZXNzKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5DYWlwQWNjb3VudEFkZHJlc3NTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0NhaXBBY2NvdW50QWRkcmVzcyA9IGlzQ2FpcEFjY291bnRBZGRyZXNzO1xuLyoqXG4gKiBQYXJzZSBhIENBSVAtMiBjaGFpbiBJRCB0byBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXNwYWNlIGFuZCByZWZlcmVuY2UuXG4gKiBUaGlzIHZhbGlkYXRlcyB0aGUgQ0FJUC0yIGNoYWluIElEIGJlZm9yZSBwYXJzaW5nIGl0LlxuICpcbiAqIEBwYXJhbSBjYWlwQ2hhaW5JZCAtIFRoZSBDQUlQLTIgY2hhaW4gSUQgdG8gdmFsaWRhdGUgYW5kIHBhcnNlLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBDQUlQLTIgY2hhaW4gSUQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ2FpcENoYWluSWQoY2FpcENoYWluSWQpIHtcbiAgICBjb25zdCBtYXRjaCA9IGV4cG9ydHMuQ0FJUF9DSEFJTl9JRF9SRUdFWC5leGVjKGNhaXBDaGFpbklkKTtcbiAgICBpZiAoIW1hdGNoPy5ncm91cHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENBSVAgY2hhaW4gSUQuJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWVzcGFjZTogbWF0Y2guZ3JvdXBzLm5hbWVzcGFjZSxcbiAgICAgICAgcmVmZXJlbmNlOiBtYXRjaC5ncm91cHMucmVmZXJlbmNlLFxuICAgIH07XG59XG5leHBvcnRzLnBhcnNlQ2FpcENoYWluSWQgPSBwYXJzZUNhaXBDaGFpbklkO1xuLyoqXG4gKiBQYXJzZSBhbiBDQUlQLTEwIGFjY291bnQgSUQgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNoYWluIElELCBwYXJzZWQgY2hhaW4gSUQsIGFuZCBhY2NvdW50IGFkZHJlc3MuXG4gKiBUaGlzIHZhbGlkYXRlcyB0aGUgQ0FJUC0xMCBhY2NvdW50IElEIGJlZm9yZSBwYXJzaW5nIGl0LlxuICpcbiAqIEBwYXJhbSBjYWlwQWNjb3VudElkIC0gVGhlIENBSVAtMTAgYWNjb3VudCBJRCB0byB2YWxpZGF0ZSBhbmQgcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIENBSVAtMTAgYWNjb3VudCBJRC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VDYWlwQWNjb3VudElkKGNhaXBBY2NvdW50SWQpIHtcbiAgICBjb25zdCBtYXRjaCA9IGV4cG9ydHMuQ0FJUF9BQ0NPVU5UX0lEX1JFR0VYLmV4ZWMoY2FpcEFjY291bnRJZCk7XG4gICAgaWYgKCFtYXRjaD8uZ3JvdXBzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBDQUlQIGFjY291bnQgSUQuJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IG1hdGNoLmdyb3Vwcy5hY2NvdW50QWRkcmVzcyxcbiAgICAgICAgY2hhaW5JZDogbWF0Y2guZ3JvdXBzLmNoYWluSWQsXG4gICAgICAgIGNoYWluOiB7XG4gICAgICAgICAgICBuYW1lc3BhY2U6IG1hdGNoLmdyb3Vwcy5uYW1lc3BhY2UsXG4gICAgICAgICAgICByZWZlcmVuY2U6IG1hdGNoLmdyb3Vwcy5yZWZlcmVuY2UsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyc2VDYWlwQWNjb3VudElkID0gcGFyc2VDYWlwQWNjb3VudElkO1xuLyoqXG4gKiBDaGFpbiBJRCBhcyBkZWZpbmVkIHBlciB0aGUgQ0FJUC0yXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0NoYWluQWdub3N0aWMvQ0FJUHMvYmxvYi9tYWluL0NBSVBzL2NhaXAtMi5tZH0uXG4gKlxuICogSXQgZGVmaW5lcyBhIHdheSB0byB1bmlxdWVseSBpZGVudGlmeSBhbnkgYmxvY2tjaGFpbiBpbiBhIGh1bWFuLXJlYWRhYmxlXG4gKiB3YXkuXG4gKlxuICogQHBhcmFtIG5hbWVzcGFjZSAtIFRoZSBzdGFuZGFyZCAoZWNvc3lzdGVtKSBvZiBzaW1pbGFyIGJsb2NrY2hhaW5zLlxuICogQHBhcmFtIHJlZmVyZW5jZSAtIElkZW50aWZ5IG9mIGEgYmxvY2tjaGFpbiB3aXRoaW4gYSBnaXZlbiBuYW1lc3BhY2UuXG4gKiBAdGhyb3dzIHtAbGluayBFcnJvcn1cbiAqIFRoaXMgZXhjZXB0aW9uIGlzIHRocm93biBpZiB0aGUgaW5wdXRzIGRvZXMgbm90IGNvbXBseSB3aXRoIHRoZSBDQUlQLTJcbiAqIHN5bnRheCBzcGVjaWZpY2F0aW9uXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0NoYWluQWdub3N0aWMvQ0FJUHMvYmxvYi9tYWluL0NBSVBzL2NhaXAtMi5tZCNzeW50YXh9LlxuICogQHJldHVybnMgQSBDQUlQIGNoYWluIElELlxuICovXG5mdW5jdGlvbiB0b0NhaXBDaGFpbklkKG5hbWVzcGFjZSwgcmVmZXJlbmNlKSB7XG4gICAgaWYgKCFpc0NhaXBOYW1lc3BhY2UobmFtZXNwYWNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJuYW1lc3BhY2VcIiwgbXVzdCBtYXRjaDogJHtleHBvcnRzLkNBSVBfTkFNRVNQQUNFX1JFR0VYLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuICAgIGlmICghaXNDYWlwUmVmZXJlbmNlKHJlZmVyZW5jZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwicmVmZXJlbmNlXCIsIG11c3QgbWF0Y2g6ICR7ZXhwb3J0cy5DQUlQX1JFRkVSRU5DRV9SRUdFWC50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bmFtZXNwYWNlfToke3JlZmVyZW5jZX1gO1xufVxuZXhwb3J0cy50b0NhaXBDaGFpbklkID0gdG9DYWlwQ2hhaW5JZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhaXAtdHlwZXMuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/caip-types.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/checksum.cjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/checksum.cjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChecksumStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nconst base64_1 = __webpack_require__(/*! ./base64.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/base64.cjs\");\nexports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), { paddingRequired: true }), 44, 44);\n//# sourceMappingURL=checksum.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2hlY2tzdW0uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0QixzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBdUI7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsMkdBQWM7QUFDdkMsc0JBQXNCLCtFQUErRSx1QkFBdUI7QUFDNUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2hlY2tzdW0uY2pzPzJjYjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoZWNrc3VtU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBiYXNlNjRfMSA9IHJlcXVpcmUoXCIuL2Jhc2U2NC5janNcIik7XG5leHBvcnRzLkNoZWNrc3VtU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEuc2l6ZSkoKDAsIGJhc2U2NF8xLmJhc2U2NCkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCB7IHBhZGRpbmdSZXF1aXJlZDogdHJ1ZSB9KSwgNDQsIDQ0KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrc3VtLmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/checksum.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/coercers.cjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/coercers.cjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/assert.cjs\");\nconst bytes_1 = __webpack_require__(/*! ./bytes.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/bytes.cjs\");\nconst hex_1 = __webpack_require__(/*! ./hex.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/hex.cjs\");\nconst NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1.StrictHexStruct]);\nconst NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);\nconst BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);\nconst BytesLikeStruct = (0, superstruct_1.union)([hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);\nconst BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1.StrictHexStruct]), bytes_1.hexToBytes);\nconst HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);\n/**\n * Create a number from a number-like value.\n *\n * - If the value is a number, it is returned as-is.\n * - If the value is a `bigint`, it is converted to a number.\n * - If the value is a string, it is interpreted as a decimal number.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number.\n *\n * This validates that the value is a number-like value, and that the resulting\n * number is not `NaN` or `Infinity`.\n *\n * @example\n * ```typescript\n * const value = createNumber('0x010203');\n * console.log(value); // 66051\n *\n * const otherValue = createNumber(123n);\n * console.log(otherValue); // 123\n * ```\n * @param value - The value to create the number from.\n * @returns The created number.\n * @throws If the value is not a number-like value, or if the resulting number\n * is `NaN` or `Infinity`.\n */\nfunction createNumber(value) {\n    try {\n        const result = (0, superstruct_1.create)(value, NumberCoercer);\n        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got \"${value}\".`);\n        return result;\n    }\n    catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a number-like value, got \"${value}\".`);\n        }\n        /* istanbul ignore next */\n        throw error;\n    }\n}\nexports.createNumber = createNumber;\n/**\n * Create a `bigint` from a number-like value.\n *\n * - If the value is a number, it is converted to a `bigint`.\n * - If the value is a `bigint`, it is returned as-is.\n * - If the value is a string, it is interpreted as a decimal number and\n * converted to a `bigint`.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number and converted to a `bigint`.\n *\n * @example\n * ```typescript\n * const value = createBigInt('0x010203');\n * console.log(value); // 16909060n\n *\n * const otherValue = createBigInt(123);\n * console.log(otherValue); // 123n\n * ```\n * @param value - The value to create the bigint from.\n * @returns The created bigint.\n * @throws If the value is not a number-like value.\n */\nfunction createBigInt(value) {\n    try {\n        // The `BigInt` constructor throws if the value is not a number-like value.\n        // There is no need to validate the value manually.\n        return (0, superstruct_1.create)(value, BigIntCoercer);\n    }\n    catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a number-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */\n        throw error;\n    }\n}\nexports.createBigInt = createBigInt;\n/**\n * Create a byte array from a bytes-like value.\n *\n * - If the value is a byte array, it is returned as-is.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is interpreted\n * as a hexadecimal number and converted to a byte array.\n *\n * @example\n * ```typescript\n * const value = createBytes('0x010203');\n * console.log(value); // Uint8Array [ 1, 2, 3 ]\n *\n * const otherValue = createBytes('0x010203');\n * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]\n * ```\n * @param value - The value to create the byte array from.\n * @returns The created byte array.\n * @throws If the value is not a bytes-like value.\n */\nfunction createBytes(value) {\n    if (typeof value === 'string' && value.toLowerCase() === '0x') {\n        return new Uint8Array();\n    }\n    try {\n        return (0, superstruct_1.create)(value, BytesCoercer);\n    }\n    catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */\n        throw error;\n    }\n}\nexports.createBytes = createBytes;\n/**\n * Create a hexadecimal string from a bytes-like value.\n *\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is returned\n * as-is.\n * - If the value is a `Uint8Array`, it is converted to a hex string.\n *\n * @example\n * ```typescript\n * const value = createHex(new Uint8Array([1, 2, 3]));\n * console.log(value); // '0x010203'\n *\n * const otherValue = createHex('0x010203');\n * console.log(otherValue); // '0x010203'\n * ```\n * @param value - The value to create the hex string from.\n * @returns The created hex string.\n * @throws If the value is not a bytes-like value.\n */\nfunction createHex(value) {\n    if ((value instanceof Uint8Array && value.length === 0) ||\n        (typeof value === 'string' && value.toLowerCase() === '0x')) {\n        return '0x';\n    }\n    try {\n        return (0, superstruct_1.create)(value, HexCoercer);\n    }\n    catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */\n        throw error;\n    }\n}\nexports.createHex = createHex;\n//# sourceMappingURL=coercers.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY29lcmNlcnMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLG9CQUFvQjtBQUNyRixzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBdUI7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsMkdBQWM7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMseUdBQWE7QUFDckMsY0FBYyxtQkFBTyxDQUFDLHFHQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixNQUFNO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLE1BQU07QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG9CQUFvQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxvQkFBb0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxvQkFBb0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jb2VyY2Vycy5janM/Yjg0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSGV4ID0gZXhwb3J0cy5jcmVhdGVCeXRlcyA9IGV4cG9ydHMuY3JlYXRlQmlnSW50ID0gZXhwb3J0cy5jcmVhdGVOdW1iZXIgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0LmNqc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlcy5janNcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleC5janNcIik7XG5jb25zdCBOdW1iZXJMaWtlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksICgwLCBzdXBlcnN0cnVjdF8xLmJpZ2ludCkoKSwgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCBoZXhfMS5TdHJpY3RIZXhTdHJ1Y3RdKTtcbmNvbnN0IE51bWJlckNvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSwgTnVtYmVyTGlrZVN0cnVjdCwgTnVtYmVyKTtcbmNvbnN0IEJpZ0ludENvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLmJpZ2ludCkoKSwgTnVtYmVyTGlrZVN0cnVjdCwgQmlnSW50KTtcbmNvbnN0IEJ5dGVzTGlrZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbaGV4XzEuU3RyaWN0SGV4U3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSldKTtcbmNvbnN0IEJ5dGVzQ29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpLCAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW2hleF8xLlN0cmljdEhleFN0cnVjdF0pLCBieXRlc18xLmhleFRvQnl0ZXMpO1xuY29uc3QgSGV4Q29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoaGV4XzEuU3RyaWN0SGV4U3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSksIGJ5dGVzXzEuYnl0ZXNUb0hleCk7XG4vKipcbiAqIENyZWF0ZSBhIG51bWJlciBmcm9tIGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgY29udmVydGVkIHRvIGEgbnVtYmVyLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IGlzIGludGVycHJldGVkIGFzIGEgZGVjaW1hbCBudW1iZXIuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIG51bWJlci5cbiAqXG4gKiBUaGlzIHZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBhIG51bWJlci1saWtlIHZhbHVlLCBhbmQgdGhhdCB0aGUgcmVzdWx0aW5nXG4gKiBudW1iZXIgaXMgbm90IGBOYU5gIG9yIGBJbmZpbml0eWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlTnVtYmVyKCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyA2NjA1MVxuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVOdW1iZXIoMTIzbik7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gMTIzXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIG51bWJlciBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUsIG9yIGlmIHRoZSByZXN1bHRpbmcgbnVtYmVyXG4gKiBpcyBgTmFOYCBvciBgSW5maW5pdHlgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOdW1iZXIodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBOdW1iZXJDb2VyY2VyKTtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzRmluaXRlKHJlc3VsdCksIGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlTnVtYmVyID0gY3JlYXRlTnVtYmVyO1xuLyoqXG4gKiBDcmVhdGUgYSBgYmlnaW50YCBmcm9tIGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0IGlzIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBkZWNpbWFsIG51bWJlciBhbmRcbiAqIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpc1xuICogaW50ZXJwcmV0ZWQgYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIgYW5kIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZUJpZ0ludCgnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gMTY5MDkwNjBuXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZUJpZ0ludCgxMjMpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vIDEyM25cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgYmlnaW50IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBiaWdpbnQuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmlnSW50KHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVGhlIGBCaWdJbnRgIGNvbnN0cnVjdG9yIHRocm93cyBpZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gdmFsaWRhdGUgdGhlIHZhbHVlIG1hbnVhbGx5LlxuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgQmlnSW50Q29lcmNlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUJpZ0ludCA9IGNyZWF0ZUJpZ0ludDtcbi8qKlxuICogQ3JlYXRlIGEgYnl0ZSBhcnJheSBmcm9tIGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGJ5dGUgYXJyYXksIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpcyBpbnRlcnByZXRlZFxuICogYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIgYW5kIGNvbnZlcnRlZCB0byBhIGJ5dGUgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlQnl0ZXMoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIFVpbnQ4QXJyYXkgWyAxLCAyLCAzIF1cbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlQnl0ZXMoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gVWludDhBcnJheSBbIDEsIDIsIDMgXVxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBieXRlIGFycmF5IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBieXRlIGFycmF5LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgQnl0ZXNDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBieXRlcy1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVCeXRlcyA9IGNyZWF0ZUJ5dGVzO1xuLyoqXG4gKiBDcmVhdGUgYSBoZXhhZGVjaW1hbCBzdHJpbmcgZnJvbSBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpcyByZXR1cm5lZFxuICogYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YCwgaXQgaXMgY29udmVydGVkIHRvIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVIZXgobmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKSk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vICcweDAxMDIwMydcbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlSGV4KCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vICcweDAxMDIwMydcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgaGV4IHN0cmluZyBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgaGV4IHN0cmluZy5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhleCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJzB4JykpIHtcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBIZXhDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBieXRlcy1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVIZXggPSBjcmVhdGVIZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2VyY2Vycy5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/coercers.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/collections.cjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/collections.cjs ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _FrozenMap_map, _FrozenSet_set;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FrozenSet = exports.FrozenMap = void 0;\n/**\n * A {@link ReadonlyMap} that cannot be modified after instantiation.\n * The implementation uses an inner map hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this map.\n */\nclass FrozenMap {\n    get size() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").size;\n    }\n    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\")[Symbol.iterator]();\n    }\n    constructor(entries) {\n        _FrozenMap_map.set(this, void 0);\n        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), \"f\");\n        Object.freeze(this);\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").entries();\n    }\n    forEach(callbackfn, thisArg) {\n        // We have to wrap the specified callback in order to prevent it from\n        // receiving a reference to the inner map.\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));\n    }\n    get(key) {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").get(key);\n    }\n    has(key) {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").has(key);\n    }\n    keys() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").keys();\n    }\n    values() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").values();\n    }\n    toString() {\n        return `FrozenMap(${this.size}) {${this.size > 0\n            ? ` ${[...this.entries()]\n                .map(([key, value]) => `${String(key)} => ${String(value)}`)\n                .join(', ')} `\n            : ''}}`;\n    }\n}\nexports.FrozenMap = FrozenMap;\n/**\n * A {@link ReadonlySet} that cannot be modified after instantiation.\n * The implementation uses an inner set hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this set.\n */\nclass FrozenSet {\n    get size() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").size;\n    }\n    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\")[Symbol.iterator]();\n    }\n    constructor(values) {\n        _FrozenSet_set.set(this, void 0);\n        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), \"f\");\n        Object.freeze(this);\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").entries();\n    }\n    forEach(callbackfn, thisArg) {\n        // We have to wrap the specified callback in order to prevent it from\n        // receiving a reference to the inner set.\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));\n    }\n    has(value) {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").has(value);\n    }\n    keys() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").keys();\n    }\n    values() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").values();\n    }\n    toString() {\n        return `FrozenSet(${this.size}) {${this.size > 0\n            ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `\n            : ''}}`;\n    }\n}\nexports.FrozenSet = FrozenSet;\nObject.freeze(FrozenMap);\nObject.freeze(FrozenMap.prototype);\nObject.freeze(FrozenSet);\nObject.freeze(FrozenSet.prototype);\n//# sourceMappingURL=collections.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY29sbGVjdGlvbnMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLGlCQUFpQjtBQUNyQztBQUNBLE1BQU0sbUJBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUsR0FBRyxFQUFFO0FBQzNDLGtCQUFrQjtBQUNsQiwwQ0FBMEMsYUFBYSxLQUFLLGNBQWM7QUFDMUUsNkJBQTZCO0FBQzdCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsTUFBTSxtQkFBbUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSxHQUFHLEVBQUU7QUFDM0Msa0JBQWtCLCtEQUErRDtBQUNqRixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvbGxlY3Rpb25zLmNqcz82NGZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9Gcm96ZW5NYXBfbWFwLCBfRnJvemVuU2V0X3NldDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRnJvemVuU2V0ID0gZXhwb3J0cy5Gcm96ZW5NYXAgPSB2b2lkIDA7XG4vKipcbiAqIEEge0BsaW5rIFJlYWRvbmx5TWFwfSB0aGF0IGNhbm5vdCBiZSBtb2RpZmllZCBhZnRlciBpbnN0YW50aWF0aW9uLlxuICogVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgYW4gaW5uZXIgbWFwIGhpZGRlbiB2aWEgYSBwcml2YXRlIGZpZWxkLCBhbmQgdGhlXG4gKiBpbW11dGFiaWxpdHkgZ3VhcmFudGVlIHJlbGllcyBvbiBpdCBiZWluZyBpbXBvc3NpYmxlIHRvIGdldCBhIHJlZmVyZW5jZVxuICogdG8gdGhpcyBtYXAuXG4gKi9cbmNsYXNzIEZyb3plbk1hcCB7XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuc2l6ZTtcbiAgICB9XG4gICAgWyhfRnJvemVuTWFwX21hcCA9IG5ldyBXZWFrTWFwKCksIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZW50cmllcykge1xuICAgICAgICBfRnJvemVuTWFwX21hcC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgbmV3IE1hcChlbnRyaWVzKSwgXCJmXCIpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmVudHJpZXMoKTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGluIG9yZGVyIHRvIHByZXZlbnQgaXQgZnJvbVxuICAgICAgICAvLyByZWNlaXZpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGlubmVyIG1hcC5cbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5mb3JFYWNoKCh2YWx1ZSwga2V5LCBfbWFwKSA9PiBjYWxsYmFja2ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIGtleSwgdGhpcykpO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuZ2V0KGtleSk7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5oYXMoa2V5KTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5rZXlzKCk7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS52YWx1ZXMoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgRnJvemVuTWFwKCR7dGhpcy5zaXplfSkgeyR7dGhpcy5zaXplID4gMFxuICAgICAgICAgICAgPyBgICR7Wy4uLnRoaXMuZW50cmllcygpXVxuICAgICAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7U3RyaW5nKGtleSl9ID0+ICR7U3RyaW5nKHZhbHVlKX1gKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfSBgXG4gICAgICAgICAgICA6ICcnfX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuRnJvemVuTWFwID0gRnJvemVuTWFwO1xuLyoqXG4gKiBBIHtAbGluayBSZWFkb25seVNldH0gdGhhdCBjYW5ub3QgYmUgbW9kaWZpZWQgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIGFuIGlubmVyIHNldCBoaWRkZW4gdmlhIGEgcHJpdmF0ZSBmaWVsZCwgYW5kIHRoZVxuICogaW1tdXRhYmlsaXR5IGd1YXJhbnRlZSByZWxpZXMgb24gaXQgYmVpbmcgaW1wb3NzaWJsZSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIHRvIHRoaXMgc2V0LlxuICovXG5jbGFzcyBGcm96ZW5TZXQge1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLnNpemU7XG4gICAgfVxuICAgIFsoX0Zyb3plblNldF9zZXQgPSBuZXcgV2Vha01hcCgpLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgICAgICBfRnJvemVuU2V0X3NldC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgbmV3IFNldCh2YWx1ZXMpLCBcImZcIik7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikuZW50cmllcygpO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2sgaW4gb3JkZXIgdG8gcHJldmVudCBpdCBmcm9tXG4gICAgICAgIC8vIHJlY2VpdmluZyBhIHJlZmVyZW5jZSB0byB0aGUgaW5uZXIgc2V0LlxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmZvckVhY2goKHZhbHVlLCB2YWx1ZTIsIF9zZXQpID0+IGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwgdmFsdWUyLCB0aGlzKSk7XG4gICAgfVxuICAgIGhhcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmhhcyh2YWx1ZSk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikua2V5cygpO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikudmFsdWVzKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYEZyb3plblNldCgke3RoaXMuc2l6ZX0pIHske3RoaXMuc2l6ZSA+IDBcbiAgICAgICAgICAgID8gYCAke1suLi50aGlzLnZhbHVlcygpXS5tYXAoKG1lbWJlcikgPT4gU3RyaW5nKG1lbWJlcikpLmpvaW4oJywgJyl9IGBcbiAgICAgICAgICAgIDogJyd9fWA7XG4gICAgfVxufVxuZXhwb3J0cy5Gcm96ZW5TZXQgPSBGcm96ZW5TZXQ7XG5PYmplY3QuZnJlZXplKEZyb3plbk1hcCk7XG5PYmplY3QuZnJlZXplKEZyb3plbk1hcC5wcm90b3R5cGUpO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5TZXQpO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5TZXQucHJvdG90eXBlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbGxlY3Rpb25zLmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/collections.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/encryption-types.cjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/encryption-types.cjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=encryption-types.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvZW5jcnlwdGlvbi10eXBlcy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvZW5jcnlwdGlvbi10eXBlcy5janM/MTIwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuY3J5cHRpb24tdHlwZXMuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/encryption-types.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/errors.cjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/errors.cjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wrapError = exports.getErrorMessage = exports.isErrorWithStack = exports.isErrorWithMessage = exports.isErrorWithCode = void 0;\nconst pony_cause_1 = __webpack_require__(/*! pony-cause */ \"(ssr)/./node_modules/pony-cause/index.js\");\nconst misc_1 = __webpack_require__(/*! ./misc.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/misc.cjs\");\n/**\n * Type guard for determining whether the given value is an instance of Error.\n * For errors generated via `fs.promises`, `error instanceof Error` won't work,\n * so we have to come up with another way of testing.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isError(error) {\n    return (error instanceof Error ||\n        ((0, misc_1.isObject)(error) && error.constructor.name === 'Error'));\n}\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property such as the type of error that Node throws for filesystem\n * operations, etc.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithCode(error) {\n    return typeof error === 'object' && error !== null && 'code' in error;\n}\nexports.isErrorWithCode = isErrorWithCode;\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithMessage(error) {\n    return typeof error === 'object' && error !== null && 'message' in error;\n}\nexports.isErrorWithMessage = isErrorWithMessage;\n/**\n * Type guard for determining whether the given value is an error object with a\n * `stack` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithStack(error) {\n    return typeof error === 'object' && error !== null && 'stack' in error;\n}\nexports.isErrorWithStack = isErrorWithStack;\n/**\n * Attempts to obtain the message from a possible error object, defaulting to an\n * empty string if it is impossible to do so.\n *\n * @param error - The possible error to get the message from.\n * @returns The message if `error` is an object with a `message` property;\n * the string version of `error` if it is not `undefined` or `null`; otherwise\n * an empty string.\n */\nfunction getErrorMessage(error) {\n    if (isErrorWithMessage(error) && typeof error.message === 'string') {\n        return error.message;\n    }\n    if ((0, misc_1.isNullOrUndefined)(error)) {\n        return '';\n    }\n    return String(error);\n}\nexports.getErrorMessage = getErrorMessage;\n/**\n * Builds a new error object, linking it to the original error via the `cause`\n * property if it is an Error.\n *\n * This function is useful to reframe error messages in general, but is\n * _critical_ when interacting with any of Node's filesystem functions as\n * provided via `fs.promises`, because these do not produce stack traces in the\n * case of an I/O error (see <https://github.com/nodejs/node/issues/30944>).\n *\n * @param originalError - The error to be wrapped (something throwable).\n * @param message - The desired message of the new error.\n * @returns A new error object.\n */\nfunction wrapError(originalError, message) {\n    if (isError(originalError)) {\n        let error;\n        if (Error.length === 2) {\n            // for some reason `tsserver` is not complaining that the\n            // Error constructor doesn't support a second argument in the editor,\n            // but `tsc` does. Error causes are not supported by our current tsc target (ES2020, we need ES2022 to make this work)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            error = new Error(message, { cause: originalError });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            error = new pony_cause_1.ErrorWithCause(message, { cause: originalError });\n        }\n        if (isErrorWithCode(originalError)) {\n            error.code = originalError.code;\n        }\n        return error;\n    }\n    if (message.length > 0) {\n        return new Error(`${String(originalError)}: ${message}`);\n    }\n    return new Error(String(originalError));\n}\nexports.wrapError = wrapError;\n//# sourceMappingURL=errors.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvZXJyb3JzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyx1QkFBdUIsR0FBRyx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRyx1QkFBdUI7QUFDN0gscUJBQXFCLG1CQUFPLENBQUMsNERBQVk7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHVHQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHNCQUFzQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0IsSUFBSSxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9lcnJvcnMuY2pzPzdiMDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndyYXBFcnJvciA9IGV4cG9ydHMuZ2V0RXJyb3JNZXNzYWdlID0gZXhwb3J0cy5pc0Vycm9yV2l0aFN0YWNrID0gZXhwb3J0cy5pc0Vycm9yV2l0aE1lc3NhZ2UgPSBleHBvcnRzLmlzRXJyb3JXaXRoQ29kZSA9IHZvaWQgMDtcbmNvbnN0IHBvbnlfY2F1c2VfMSA9IHJlcXVpcmUoXCJwb255LWNhdXNlXCIpO1xuY29uc3QgbWlzY18xID0gcmVxdWlyZShcIi4vbWlzYy5janNcIik7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIEVycm9yLlxuICogRm9yIGVycm9ycyBnZW5lcmF0ZWQgdmlhIGBmcy5wcm9taXNlc2AsIGBlcnJvciBpbnN0YW5jZW9mIEVycm9yYCB3b24ndCB3b3JrLFxuICogc28gd2UgaGF2ZSB0byBjb21lIHVwIHdpdGggYW5vdGhlciB3YXkgb2YgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIChlcnJvciBpbnN0YW5jZW9mIEVycm9yIHx8XG4gICAgICAgICgoMCwgbWlzY18xLmlzT2JqZWN0KShlcnJvcikgJiYgZXJyb3IuY29uc3RydWN0b3IubmFtZSA9PT0gJ0Vycm9yJykpO1xufVxuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBlcnJvciBvYmplY3Qgd2l0aCBhXG4gKiBgY29kZWAgcHJvcGVydHkgc3VjaCBhcyB0aGUgdHlwZSBvZiBlcnJvciB0aGF0IE5vZGUgdGhyb3dzIGZvciBmaWxlc3lzdGVtXG4gKiBvcGVyYXRpb25zLCBldGMuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbi5cbiAqL1xuZnVuY3Rpb24gaXNFcnJvcldpdGhDb2RlKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ2NvZGUnIGluIGVycm9yO1xufVxuZXhwb3J0cy5pc0Vycm9yV2l0aENvZGUgPSBpc0Vycm9yV2l0aENvZGU7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGVycm9yIG9iamVjdCB3aXRoIGFcbiAqIGBtZXNzYWdlYCBwcm9wZXJ0eSwgc3VjaCBhcyBhbiBpbnN0YW5jZSBvZiBFcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnbWVzc2FnZScgaW4gZXJyb3I7XG59XG5leHBvcnRzLmlzRXJyb3JXaXRoTWVzc2FnZSA9IGlzRXJyb3JXaXRoTWVzc2FnZTtcbi8qKlxuICogVHlwZSBndWFyZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gZXJyb3Igb2JqZWN0IHdpdGggYVxuICogYHN0YWNrYCBwcm9wZXJ0eSwgc3VjaCBhcyBhbiBpbnN0YW5jZSBvZiBFcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Vycm9yV2l0aFN0YWNrKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ3N0YWNrJyBpbiBlcnJvcjtcbn1cbmV4cG9ydHMuaXNFcnJvcldpdGhTdGFjayA9IGlzRXJyb3JXaXRoU3RhY2s7XG4vKipcbiAqIEF0dGVtcHRzIHRvIG9idGFpbiB0aGUgbWVzc2FnZSBmcm9tIGEgcG9zc2libGUgZXJyb3Igb2JqZWN0LCBkZWZhdWx0aW5nIHRvIGFuXG4gKiBlbXB0eSBzdHJpbmcgaWYgaXQgaXMgaW1wb3NzaWJsZSB0byBkbyBzby5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgcG9zc2libGUgZXJyb3IgdG8gZ2V0IHRoZSBtZXNzYWdlIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgbWVzc2FnZSBpZiBgZXJyb3JgIGlzIGFuIG9iamVjdCB3aXRoIGEgYG1lc3NhZ2VgIHByb3BlcnR5O1xuICogdGhlIHN0cmluZyB2ZXJzaW9uIG9mIGBlcnJvcmAgaWYgaXQgaXMgbm90IGB1bmRlZmluZWRgIG9yIGBudWxsYDsgb3RoZXJ3aXNlXG4gKiBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICAgIGlmIChpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgaWYgKCgwLCBtaXNjXzEuaXNOdWxsT3JVbmRlZmluZWQpKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoZXJyb3IpO1xufVxuZXhwb3J0cy5nZXRFcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2U7XG4vKipcbiAqIEJ1aWxkcyBhIG5ldyBlcnJvciBvYmplY3QsIGxpbmtpbmcgaXQgdG8gdGhlIG9yaWdpbmFsIGVycm9yIHZpYSB0aGUgYGNhdXNlYFxuICogcHJvcGVydHkgaWYgaXQgaXMgYW4gRXJyb3IuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgdG8gcmVmcmFtZSBlcnJvciBtZXNzYWdlcyBpbiBnZW5lcmFsLCBidXQgaXNcbiAqIF9jcml0aWNhbF8gd2hlbiBpbnRlcmFjdGluZyB3aXRoIGFueSBvZiBOb2RlJ3MgZmlsZXN5c3RlbSBmdW5jdGlvbnMgYXNcbiAqIHByb3ZpZGVkIHZpYSBgZnMucHJvbWlzZXNgLCBiZWNhdXNlIHRoZXNlIGRvIG5vdCBwcm9kdWNlIHN0YWNrIHRyYWNlcyBpbiB0aGVcbiAqIGNhc2Ugb2YgYW4gSS9PIGVycm9yIChzZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzA5NDQ+KS5cbiAqXG4gKiBAcGFyYW0gb3JpZ2luYWxFcnJvciAtIFRoZSBlcnJvciB0byBiZSB3cmFwcGVkIChzb21ldGhpbmcgdGhyb3dhYmxlKS5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGRlc2lyZWQgbWVzc2FnZSBvZiB0aGUgbmV3IGVycm9yLlxuICogQHJldHVybnMgQSBuZXcgZXJyb3Igb2JqZWN0LlxuICovXG5mdW5jdGlvbiB3cmFwRXJyb3Iob3JpZ2luYWxFcnJvciwgbWVzc2FnZSkge1xuICAgIGlmIChpc0Vycm9yKG9yaWdpbmFsRXJyb3IpKSB7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgaWYgKEVycm9yLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIGB0c3NlcnZlcmAgaXMgbm90IGNvbXBsYWluaW5nIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBFcnJvciBjb25zdHJ1Y3RvciBkb2Vzbid0IHN1cHBvcnQgYSBzZWNvbmQgYXJndW1lbnQgaW4gdGhlIGVkaXRvcixcbiAgICAgICAgICAgIC8vIGJ1dCBgdHNjYCBkb2VzLiBFcnJvciBjYXVzZXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgb3VyIGN1cnJlbnQgdHNjIHRhcmdldCAoRVMyMDIwLCB3ZSBuZWVkIEVTMjAyMiB0byBtYWtlIHRoaXMgd29yaylcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UsIHsgY2F1c2U6IG9yaWdpbmFsRXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBwb255X2NhdXNlXzEuRXJyb3JXaXRoQ2F1c2UobWVzc2FnZSwgeyBjYXVzZTogb3JpZ2luYWxFcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFcnJvcldpdGhDb2RlKG9yaWdpbmFsRXJyb3IpKSB7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gb3JpZ2luYWxFcnJvci5jb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGAke1N0cmluZyhvcmlnaW5hbEVycm9yKX06ICR7bWVzc2FnZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcihTdHJpbmcob3JpZ2luYWxFcnJvcikpO1xufVxuZXhwb3J0cy53cmFwRXJyb3IgPSB3cmFwRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/errors.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/hex.cjs":
/*!************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/hex.cjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.remove0x = exports.add0x = exports.isValidChecksumAddress = exports.getChecksumAddress = exports.isValidHexAddress = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.HexChecksumAddressStruct = exports.HexAddressStruct = exports.StrictHexStruct = exports.HexStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/sha3.js\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/assert.cjs\");\nconst bytes_1 = __webpack_require__(/*! ./bytes.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/bytes.cjs\");\nexports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);\nexports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);\nexports.HexAddressStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]{40}$/u);\nexports.HexChecksumAddressStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-fA-F]{40}$/u);\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nfunction isHexString(value) {\n    return (0, superstruct_1.is)(value, exports.HexStruct);\n}\nexports.isHexString = isHexString;\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nfunction isStrictHexString(value) {\n    return (0, superstruct_1.is)(value, exports.StrictHexStruct);\n}\nexports.isStrictHexString = isStrictHexString;\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nfunction assertIsHexString(value) {\n    (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');\n}\nexports.assertIsHexString = assertIsHexString;\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nfunction assertIsStrictHexString(value) {\n    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with \"0x\".');\n}\nexports.assertIsStrictHexString = assertIsStrictHexString;\n/**\n * Validate that the passed prefixed hex string is an all-lowercase\n * hex address, or a valid mixed-case checksum address.\n *\n * @param possibleAddress - Input parameter to check against.\n * @returns Whether or not the input is a valid hex address.\n */\nfunction isValidHexAddress(possibleAddress) {\n    return ((0, superstruct_1.is)(possibleAddress, exports.HexAddressStruct) ||\n        isValidChecksumAddress(possibleAddress));\n}\nexports.isValidHexAddress = isValidHexAddress;\n/**\n * Encode a passed hex string as an ERC-55 mixed-case checksum address.\n *\n * @param address - The hex address to encode.\n * @returns The address encoded according to ERC-55.\n * @see https://eips.ethereum.org/EIPS/eip-55\n */\nfunction getChecksumAddress(address) {\n    (0, assert_1.assert)((0, superstruct_1.is)(address, exports.HexChecksumAddressStruct), 'Invalid hex address.');\n    const unPrefixed = remove0x(address.toLowerCase());\n    const unPrefixedHash = remove0x((0, bytes_1.bytesToHex)((0, sha3_1.keccak_256)(unPrefixed)));\n    return `0x${unPrefixed\n        .split('')\n        .map((character, nibbleIndex) => {\n        const hashCharacter = unPrefixedHash[nibbleIndex];\n        (0, assert_1.assert)((0, superstruct_1.is)(hashCharacter, (0, superstruct_1.string)()), 'Hash shorter than address.');\n        return parseInt(hashCharacter, 16) > 7\n            ? character.toUpperCase()\n            : character;\n    })\n        .join('')}`;\n}\nexports.getChecksumAddress = getChecksumAddress;\n/**\n * Validate that the passed hex string is a valid ERC-55 mixed-case\n * checksum address.\n *\n * @param possibleChecksum - The hex address to check.\n * @returns True if the address is a checksum address.\n */\nfunction isValidChecksumAddress(possibleChecksum) {\n    if (!(0, superstruct_1.is)(possibleChecksum, exports.HexChecksumAddressStruct)) {\n        return false;\n    }\n    return getChecksumAddress(possibleChecksum) === possibleChecksum;\n}\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */\nfunction add0x(hexadecimal) {\n    if (hexadecimal.startsWith('0x')) {\n        return hexadecimal;\n    }\n    if (hexadecimal.startsWith('0X')) {\n        return `0x${hexadecimal.substring(2)}`;\n    }\n    return `0x${hexadecimal}`;\n}\nexports.add0x = add0x;\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */\nfunction remove0x(hexadecimal) {\n    if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {\n        return hexadecimal.substring(2);\n    }\n    return hexadecimal;\n}\nexports.remove0x = remove0x;\n//# sourceMappingURL=hex.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvaGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxhQUFhLEdBQUcsOEJBQThCLEdBQUcsMEJBQTBCLEdBQUcseUJBQXlCLEdBQUcsK0JBQStCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcsbUJBQW1CLEdBQUcsZ0NBQWdDLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsaUJBQWlCO0FBQ3RWLHNCQUFzQixtQkFBTyxDQUFDLHdGQUF1QjtBQUNyRCxlQUFlLG1CQUFPLENBQUMsc0VBQW9CO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLDJHQUFjO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLHlHQUFhO0FBQ3JDLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIsd0JBQXdCLHdFQUF3RSxHQUFHO0FBQ25HLGdDQUFnQywyRUFBMkUsR0FBRztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0I7QUFDbEI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2hleC5janM/NjVhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVtb3ZlMHggPSBleHBvcnRzLmFkZDB4ID0gZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gZXhwb3J0cy5nZXRDaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRIZXhBZGRyZXNzID0gZXhwb3J0cy5hc3NlcnRJc1N0cmljdEhleFN0cmluZyA9IGV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSBleHBvcnRzLmlzU3RyaWN0SGV4U3RyaW5nID0gZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuSGV4Q2hlY2tzdW1BZGRyZXNzU3RydWN0ID0gZXhwb3J0cy5IZXhBZGRyZXNzU3RydWN0ID0gZXhwb3J0cy5TdHJpY3RIZXhTdHJ1Y3QgPSBleHBvcnRzLkhleFN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3N1cGVyc3RydWN0XCIpO1xuY29uc3Qgc2hhM18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhM1wiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0LmNqc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlcy5janNcIik7XG5leHBvcnRzLkhleFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgL14oPzoweCk/WzAtOWEtZl0rJC9pdSk7XG5leHBvcnRzLlN0cmljdEhleFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgL14weFswLTlhLWZdKyQvaXUpO1xuZXhwb3J0cy5IZXhBZGRyZXNzU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAvXjB4WzAtOWEtZl17NDB9JC91KTtcbmV4cG9ydHMuSGV4Q2hlY2tzdW1BZGRyZXNzU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAvXjB4WzAtOWEtZkEtRl17NDB9JC91KTtcbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkhleFN0cnVjdCk7XG59XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gaXNIZXhTdHJpbmc7XG4vKipcbiAqIFN0cmljdGx5IGNoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgaGV4IHN0cmluZy4gQSB2YWxpZCBoZXggc3RyaW5nIG11c3RcbiAqIHN0YXJ0IHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdEhleFN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuU3RyaWN0SGV4U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNTdHJpY3RIZXhTdHJpbmcgPSBpc1N0cmljdEhleFN0cmluZztcbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNIZXhTdHJpbmcodmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShpc0hleFN0cmluZyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgaGV4YWRlY2ltYWwgc3RyaW5nLicpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IGFzc2VydElzSGV4U3RyaW5nO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy4gQSB2YWxpZCBoZXggc3RyaW5nIG11c3Qgc3RhcnQgd2l0aFxuICogdGhlIFwiMHhcIi1wcmVmaXguXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmcodmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShpc1N0cmljdEhleFN0cmluZyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgaGV4YWRlY2ltYWwgc3RyaW5nLCBzdGFydGluZyB3aXRoIFwiMHhcIi4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmcgPSBhc3NlcnRJc1N0cmljdEhleFN0cmluZztcbi8qKlxuICogVmFsaWRhdGUgdGhhdCB0aGUgcGFzc2VkIHByZWZpeGVkIGhleCBzdHJpbmcgaXMgYW4gYWxsLWxvd2VyY2FzZVxuICogaGV4IGFkZHJlc3MsIG9yIGEgdmFsaWQgbWl4ZWQtY2FzZSBjaGVja3N1bSBhZGRyZXNzLlxuICpcbiAqIEBwYXJhbSBwb3NzaWJsZUFkZHJlc3MgLSBJbnB1dCBwYXJhbWV0ZXIgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHZhbGlkIGhleCBhZGRyZXNzLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSGV4QWRkcmVzcyhwb3NzaWJsZUFkZHJlc3MpIHtcbiAgICByZXR1cm4gKCgwLCBzdXBlcnN0cnVjdF8xLmlzKShwb3NzaWJsZUFkZHJlc3MsIGV4cG9ydHMuSGV4QWRkcmVzc1N0cnVjdCkgfHxcbiAgICAgICAgaXNWYWxpZENoZWNrc3VtQWRkcmVzcyhwb3NzaWJsZUFkZHJlc3MpKTtcbn1cbmV4cG9ydHMuaXNWYWxpZEhleEFkZHJlc3MgPSBpc1ZhbGlkSGV4QWRkcmVzcztcbi8qKlxuICogRW5jb2RlIGEgcGFzc2VkIGhleCBzdHJpbmcgYXMgYW4gRVJDLTU1IG1peGVkLWNhc2UgY2hlY2tzdW0gYWRkcmVzcy5cbiAqXG4gKiBAcGFyYW0gYWRkcmVzcyAtIFRoZSBoZXggYWRkcmVzcyB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBUaGUgYWRkcmVzcyBlbmNvZGVkIGFjY29yZGluZyB0byBFUkMtNTUuXG4gKiBAc2VlIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNTVcbiAqL1xuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSgoMCwgc3VwZXJzdHJ1Y3RfMS5pcykoYWRkcmVzcywgZXhwb3J0cy5IZXhDaGVja3N1bUFkZHJlc3NTdHJ1Y3QpLCAnSW52YWxpZCBoZXggYWRkcmVzcy4nKTtcbiAgICBjb25zdCB1blByZWZpeGVkID0gcmVtb3ZlMHgoYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgICBjb25zdCB1blByZWZpeGVkSGFzaCA9IHJlbW92ZTB4KCgwLCBieXRlc18xLmJ5dGVzVG9IZXgpKCgwLCBzaGEzXzEua2VjY2FrXzI1NikodW5QcmVmaXhlZCkpKTtcbiAgICByZXR1cm4gYDB4JHt1blByZWZpeGVkXG4gICAgICAgIC5zcGxpdCgnJylcbiAgICAgICAgLm1hcCgoY2hhcmFjdGVyLCBuaWJibGVJbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBoYXNoQ2hhcmFjdGVyID0gdW5QcmVmaXhlZEhhc2hbbmliYmxlSW5kZXhdO1xuICAgICAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSgoMCwgc3VwZXJzdHJ1Y3RfMS5pcykoaGFzaENoYXJhY3RlciwgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpKSwgJ0hhc2ggc2hvcnRlciB0aGFuIGFkZHJlc3MuJyk7XG4gICAgICAgIHJldHVybiBwYXJzZUludChoYXNoQ2hhcmFjdGVyLCAxNikgPiA3XG4gICAgICAgICAgICA/IGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICA6IGNoYXJhY3RlcjtcbiAgICB9KVxuICAgICAgICAuam9pbignJyl9YDtcbn1cbmV4cG9ydHMuZ2V0Q2hlY2tzdW1BZGRyZXNzID0gZ2V0Q2hlY2tzdW1BZGRyZXNzO1xuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IHRoZSBwYXNzZWQgaGV4IHN0cmluZyBpcyBhIHZhbGlkIEVSQy01NSBtaXhlZC1jYXNlXG4gKiBjaGVja3N1bSBhZGRyZXNzLlxuICpcbiAqIEBwYXJhbSBwb3NzaWJsZUNoZWNrc3VtIC0gVGhlIGhleCBhZGRyZXNzIHRvIGNoZWNrLlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgYWRkcmVzcyBpcyBhIGNoZWNrc3VtIGFkZHJlc3MuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDaGVja3N1bUFkZHJlc3MocG9zc2libGVDaGVja3N1bSkge1xuICAgIGlmICghKDAsIHN1cGVyc3RydWN0XzEuaXMpKHBvc3NpYmxlQ2hlY2tzdW0sIGV4cG9ydHMuSGV4Q2hlY2tzdW1BZGRyZXNzU3RydWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBnZXRDaGVja3N1bUFkZHJlc3MocG9zc2libGVDaGVja3N1bSkgPT09IHBvc3NpYmxlQ2hlY2tzdW07XG59XG5leHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBpc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzO1xuLyoqXG4gKiBBZGQgdGhlIGAweGAtcHJlZml4IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBJZiB0aGUgc3RyaW5nIGFscmVhZHkgaGFzIHRoZVxuICogcHJlZml4LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gaGV4YWRlY2ltYWwgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGFkZCB0aGUgcHJlZml4IHRvLlxuICogQHJldHVybnMgVGhlIHByZWZpeGVkIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYWRkMHgoaGV4YWRlY2ltYWwpIHtcbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICByZXR1cm4gaGV4YWRlY2ltYWw7XG4gICAgfVxuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcwWCcpKSB7XG4gICAgICAgIHJldHVybiBgMHgke2hleGFkZWNpbWFsLnN1YnN0cmluZygyKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYDB4JHtoZXhhZGVjaW1hbH1gO1xufVxuZXhwb3J0cy5hZGQweCA9IGFkZDB4O1xuLyoqXG4gKiBSZW1vdmUgdGhlIGAweGAtcHJlZml4IGZyb20gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIElmIHRoZSBzdHJpbmcgZG9lc24ndCBoYXZlXG4gKiB0aGUgcHJlZml4LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gaGV4YWRlY2ltYWwgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIHJlbW92ZSB0aGUgcHJlZml4IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgdW4tcHJlZml4ZWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiByZW1vdmUweChoZXhhZGVjaW1hbCkge1xuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcweCcpIHx8IGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzBYJykpIHtcbiAgICAgICAgcmV0dXJuIGhleGFkZWNpbWFsLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGFkZWNpbWFsO1xufVxuZXhwb3J0cy5yZW1vdmUweCA9IHJlbW92ZTB4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/hex.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./assert.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/assert.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./base64.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/base64.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./bytes.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/bytes.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./caip-types.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/caip-types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./checksum.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/checksum.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./coercers.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/coercers.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./collections.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/collections.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./encryption-types.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/encryption-types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./errors.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/errors.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./hex.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/hex.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./json.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/json.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./keyring.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/keyring.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./logging.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/logging.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./misc.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/misc.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./number.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/number.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./opaque.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/opaque.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./promise.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/promise.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./time.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/time.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./transaction-types.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/transaction-types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./versions.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/versions.cjs\"), exports);\n//# sourceMappingURL=index.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQywyR0FBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsMkdBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLHlHQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxtSEFBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLCtHQUFnQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsK0dBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxxSEFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLCtIQUF3QjtBQUM3QyxhQUFhLG1CQUFPLENBQUMsMkdBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLHFHQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyx1R0FBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsNkdBQWU7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLDZHQUFlO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQyx1R0FBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsMkdBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLDJHQUFjO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyw2R0FBZTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsdUdBQVk7QUFDakMsYUFBYSxtQkFBTyxDQUFDLGlJQUF5QjtBQUM5QyxhQUFhLG1CQUFPLENBQUMsK0dBQWdCO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2luZGV4LmNqcz8xYjk3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXJ0LmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZTY0LmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYnl0ZXMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jYWlwLXR5cGVzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2hlY2tzdW0uY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2VyY2Vycy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbGxlY3Rpb25zLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZW5jcnlwdGlvbi10eXBlcy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Vycm9ycy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hleC5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2pzb24uY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9rZXlyaW5nLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbG9nZ2luZy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21pc2MuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9udW1iZXIuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vcGFxdWUuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcm9taXNlLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdGltZS5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uLXR5cGVzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmVyc2lvbnMuY2pzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/json.cjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/json.cjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.getJsonSize = exports.getSafeJson = exports.isValidJson = exports.JsonStruct = exports.UnsafeJsonStruct = exports.exactOptional = exports.object = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/assert.cjs\");\nconst misc_1 = __webpack_require__(/*! ./misc.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/misc.cjs\");\n/**\n * A struct to check if the given value is a valid object, with support for\n * {@link exactOptional} types.\n *\n * @param schema - The schema of the object.\n * @returns A struct to check if the given value is an object.\n */\nconst object = (schema) => \n// The type is slightly different from a regular object struct, because we\n// want to make properties with `undefined` in their type optional, but not\n// `undefined` itself. This means that we need a type cast.\n(0, superstruct_1.object)(schema);\nexports.object = object;\n/**\n * Check the last field of a path is present.\n *\n * @param context - The context to check.\n * @param context.path - The path to check.\n * @param context.branch - The branch to check.\n * @returns Whether the last field of a path is present.\n */\nfunction hasOptional({ path, branch }) {\n    const field = path[path.length - 1];\n    return (0, misc_1.hasProperty)(branch[branch.length - 2], field);\n}\n/**\n * A struct which allows the property of an object to be absent, or to be present\n * as long as it's valid and not set to `undefined`.\n *\n * This struct should be used in conjunction with the {@link object} from this\n * library, to get proper type inference.\n *\n * @param struct - The struct to check the value against, if present.\n * @returns A struct to check if the given value is valid, or not present.\n * @example\n * ```ts\n * const struct = object({\n *   foo: exactOptional(string()),\n *   bar: exactOptional(number()),\n *   baz: optional(boolean()),\n *   qux: unknown(),\n * });\n *\n * type Type = Infer<typeof struct>;\n * // Type is equivalent to:\n * // {\n * //   foo?: string;\n * //   bar?: number;\n * //   baz?: boolean | undefined;\n * //   qux: unknown;\n * // }\n * ```\n */\nfunction exactOptional(struct) {\n    return new superstruct_1.Struct({\n        ...struct,\n        type: `optional ${struct.type}`,\n        validator: (value, context) => !hasOptional(context) || struct.validator(value, context),\n        refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context),\n    });\n}\nexports.exactOptional = exactOptional;\n/**\n * A struct to check if the given value is finite number. Superstruct's\n * `number()` struct does not check if the value is finite.\n *\n * @returns A struct to check if the given value is finite number.\n */\nconst finiteNumber = () => (0, superstruct_1.define)('finite number', (value) => {\n    return (0, superstruct_1.is)(value, (0, superstruct_1.number)()) && Number.isFinite(value);\n});\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */\n// We cannot infer the type of the struct, because it is recursive.\nexports.UnsafeJsonStruct = (0, superstruct_1.union)([\n    (0, superstruct_1.literal)(null),\n    (0, superstruct_1.boolean)(),\n    finiteNumber(),\n    (0, superstruct_1.string)(),\n    (0, superstruct_1.array)((0, superstruct_1.lazy)(() => exports.UnsafeJsonStruct)),\n    (0, superstruct_1.record)((0, superstruct_1.string)(), (0, superstruct_1.lazy)(() => exports.UnsafeJsonStruct)),\n]);\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */\nexports.JsonStruct = (0, superstruct_1.coerce)(exports.UnsafeJsonStruct, (0, superstruct_1.any)(), (value) => {\n    (0, assert_1.assertStruct)(value, exports.UnsafeJsonStruct);\n    return JSON.parse(JSON.stringify(value, (propKey, propValue) => {\n        // Strip __proto__ and constructor properties to prevent prototype pollution.\n        if (propKey === '__proto__' || propKey === 'constructor') {\n            return undefined;\n        }\n        return propValue;\n    }));\n});\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */\nfunction isValidJson(value) {\n    try {\n        getSafeJson(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nexports.isValidJson = isValidJson;\n/**\n * Validate and return sanitized JSON.\n *\n * Note:\n * This function uses sanitized JsonStruct for validation\n * that applies stringify and then parse of a value provided\n * to ensure that there are no getters which can have side effects\n * that can cause security issues.\n *\n * @param value - JSON structure to be processed.\n * @returns Sanitized JSON structure.\n */\nfunction getSafeJson(value) {\n    return (0, superstruct_1.create)(value, exports.JsonStruct);\n}\nexports.getSafeJson = getSafeJson;\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */\nfunction getJsonSize(value) {\n    (0, assert_1.assertStruct)(value, exports.JsonStruct, 'Invalid JSON value');\n    const json = JSON.stringify(value);\n    return new TextEncoder().encode(json).byteLength;\n}\nexports.getJsonSize = getJsonSize;\n/**\n * The string '2.0'.\n */\nexports.jsonrpc2 = '2.0';\nexports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);\nexports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));\nexports.JsonRpcErrorStruct = (0, exports.object)({\n    code: (0, superstruct_1.integer)(),\n    message: (0, superstruct_1.string)(),\n    data: exactOptional(exports.JsonStruct),\n    stack: exactOptional((0, superstruct_1.string)()),\n});\nexports.JsonRpcParamsStruct = (0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]);\nexports.JsonRpcRequestStruct = (0, exports.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    method: (0, superstruct_1.string)(),\n    params: exactOptional(exports.JsonRpcParamsStruct),\n});\nexports.JsonRpcNotificationStruct = (0, exports.object)({\n    jsonrpc: exports.JsonRpcVersionStruct,\n    method: (0, superstruct_1.string)(),\n    params: exactOptional(exports.JsonRpcParamsStruct),\n});\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */\nfunction isJsonRpcNotification(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);\n}\nexports.isJsonRpcNotification = isJsonRpcNotification;\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */\nfunction assertIsJsonRpcNotification(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);\n}\nexports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */\nfunction isJsonRpcRequest(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);\n}\nexports.isJsonRpcRequest = isJsonRpcRequest;\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */\nfunction assertIsJsonRpcRequest(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);\n}\nexports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;\nexports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),\n    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct),\n});\nexports.JsonRpcSuccessStruct = (0, exports.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    result: exports.JsonStruct,\n});\nexports.JsonRpcFailureStruct = (0, exports.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    error: exports.JsonRpcErrorStruct,\n});\nexports.JsonRpcResponseStruct = (0, superstruct_1.union)([\n    exports.JsonRpcSuccessStruct,\n    exports.JsonRpcFailureStruct,\n]);\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */\nfunction isPendingJsonRpcResponse(response) {\n    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);\n}\nexports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */\nfunction assertIsPendingJsonRpcResponse(response, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);\n}\nexports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */\nfunction isJsonRpcResponse(response) {\n    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);\n}\nexports.isJsonRpcResponse = isJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */\nfunction assertIsJsonRpcResponse(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);\n}\nexports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */\nfunction isJsonRpcSuccess(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);\n}\nexports.isJsonRpcSuccess = isJsonRpcSuccess;\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */\nfunction assertIsJsonRpcSuccess(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);\n}\nexports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */\nfunction isJsonRpcFailure(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);\n}\nexports.isJsonRpcFailure = isJsonRpcFailure;\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */\nfunction assertIsJsonRpcFailure(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);\n}\nexports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */\nfunction isJsonRpcError(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);\n}\nexports.isJsonRpcError = isJsonRpcError;\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */\nfunction assertIsJsonRpcError(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);\n}\nexports.assertIsJsonRpcError = assertIsJsonRpcError;\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */\nfunction getJsonRpcIdValidator(options) {\n    const { permitEmptyString, permitFractions, permitNull } = {\n        permitEmptyString: true,\n        permitFractions: false,\n        permitNull: true,\n        ...options,\n    };\n    /**\n     * Type guard for {@link JsonRpcId}.\n     *\n     * @param id - The JSON-RPC ID value to check.\n     * @returns Whether the given ID is valid per the options given to the\n     * factory.\n     */\n    const isValidJsonRpcId = (id) => {\n        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||\n            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||\n            (permitNull && id === null));\n    };\n    return isValidJsonRpcId;\n}\nexports.getJsonRpcIdValidator = getJsonRpcIdValidator;\n//# sourceMappingURL=json.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvanNvbi5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsNEJBQTRCLEdBQUcsc0JBQXNCLEdBQUcsOEJBQThCLEdBQUcsd0JBQXdCLEdBQUcsOEJBQThCLEdBQUcsd0JBQXdCLEdBQUcsK0JBQStCLEdBQUcseUJBQXlCLEdBQUcsc0NBQXNDLEdBQUcsZ0NBQWdDLEdBQUcsNkJBQTZCLEdBQUcsNEJBQTRCLEdBQUcsNEJBQTRCLEdBQUcsb0NBQW9DLEdBQUcsOEJBQThCLEdBQUcsd0JBQXdCLEdBQUcsbUNBQW1DLEdBQUcsNkJBQTZCLEdBQUcsaUNBQWlDLEdBQUcsNEJBQTRCLEdBQUcsMkJBQTJCLEdBQUcsMEJBQTBCLEdBQUcsdUJBQXVCLEdBQUcsNEJBQTRCLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsd0JBQXdCLEdBQUcscUJBQXFCLEdBQUcsY0FBYztBQUNuOEIsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQXVCO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLDJHQUFjO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyx1R0FBWTtBQUNuQztBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsaUJBQWlCO0FBQy9FO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLDRCQUE0QjtBQUM1Qix1QkFBdUI7QUFDdkIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHdDQUF3QywyQkFBMkI7QUFDbkU7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsMkNBQTJDLDJCQUEyQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLDhDQUE4QywyQkFBMkI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0EsZ0RBQWdELHNCQUFzQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLDJDQUEyQyxzQkFBc0I7QUFDakU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2QkFBNkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSwyQ0FBMkMsOEJBQThCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLDJDQUEyQyx1QkFBdUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyw4Q0FBOEMsdUJBQXVCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBLGdEQUFnRCxzQkFBc0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSwyQ0FBMkMsc0JBQXNCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsOENBQThDLHNCQUFzQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQSxnREFBZ0Qsc0JBQXNCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLDhDQUE4QyxzQkFBc0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0Esd0NBQXdDLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0EsZ0RBQWdELG9CQUFvQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLDJDQUEyQyxvQkFBb0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyw4Q0FBOEMsb0JBQW9CO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlEQUFpRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9qc29uLmNqcz9lZTk2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRKc29uUnBjSWRWYWxpZGF0b3IgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY0Vycm9yID0gZXhwb3J0cy5pc0pzb25ScGNFcnJvciA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSA9IGV4cG9ydHMuaXNKc29uUnBjRmFpbHVyZSA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjU3VjY2VzcyA9IGV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmlzSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5hc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmlzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QgPSBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBleHBvcnRzLmlzSnNvblJwY1JlcXVlc3QgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuaXNKc29uUnBjTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCA9IGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0ID0gZXhwb3J0cy5qc29ucnBjMiA9IGV4cG9ydHMuZ2V0SnNvblNpemUgPSBleHBvcnRzLmdldFNhZmVKc29uID0gZXhwb3J0cy5pc1ZhbGlkSnNvbiA9IGV4cG9ydHMuSnNvblN0cnVjdCA9IGV4cG9ydHMuVW5zYWZlSnNvblN0cnVjdCA9IGV4cG9ydHMuZXhhY3RPcHRpb25hbCA9IGV4cG9ydHMub2JqZWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydC5janNcIik7XG5jb25zdCBtaXNjXzEgPSByZXF1aXJlKFwiLi9taXNjLmNqc1wiKTtcbi8qKlxuICogQSBzdHJ1Y3QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgb2JqZWN0LCB3aXRoIHN1cHBvcnQgZm9yXG4gKiB7QGxpbmsgZXhhY3RPcHRpb25hbH0gdHlwZXMuXG4gKlxuICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgb2YgdGhlIG9iamVjdC5cbiAqIEByZXR1cm5zIEEgc3RydWN0IHRvIGNoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3QuXG4gKi9cbmNvbnN0IG9iamVjdCA9IChzY2hlbWEpID0+IFxuLy8gVGhlIHR5cGUgaXMgc2xpZ2h0bHkgZGlmZmVyZW50IGZyb20gYSByZWd1bGFyIG9iamVjdCBzdHJ1Y3QsIGJlY2F1c2Ugd2Vcbi8vIHdhbnQgdG8gbWFrZSBwcm9wZXJ0aWVzIHdpdGggYHVuZGVmaW5lZGAgaW4gdGhlaXIgdHlwZSBvcHRpb25hbCwgYnV0IG5vdFxuLy8gYHVuZGVmaW5lZGAgaXRzZWxmLiBUaGlzIG1lYW5zIHRoYXQgd2UgbmVlZCBhIHR5cGUgY2FzdC5cbigwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoc2NoZW1hKTtcbmV4cG9ydHMub2JqZWN0ID0gb2JqZWN0O1xuLyoqXG4gKiBDaGVjayB0aGUgbGFzdCBmaWVsZCBvZiBhIHBhdGggaXMgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHRvIGNoZWNrLlxuICogQHBhcmFtIGNvbnRleHQucGF0aCAtIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIGNvbnRleHQuYnJhbmNoIC0gVGhlIGJyYW5jaCB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGxhc3QgZmllbGQgb2YgYSBwYXRoIGlzIHByZXNlbnQuXG4gKi9cbmZ1bmN0aW9uIGhhc09wdGlvbmFsKHsgcGF0aCwgYnJhbmNoIH0pIHtcbiAgICBjb25zdCBmaWVsZCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gKDAsIG1pc2NfMS5oYXNQcm9wZXJ0eSkoYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAyXSwgZmllbGQpO1xufVxuLyoqXG4gKiBBIHN0cnVjdCB3aGljaCBhbGxvd3MgdGhlIHByb3BlcnR5IG9mIGFuIG9iamVjdCB0byBiZSBhYnNlbnQsIG9yIHRvIGJlIHByZXNlbnRcbiAqIGFzIGxvbmcgYXMgaXQncyB2YWxpZCBhbmQgbm90IHNldCB0byBgdW5kZWZpbmVkYC5cbiAqXG4gKiBUaGlzIHN0cnVjdCBzaG91bGQgYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSB7QGxpbmsgb2JqZWN0fSBmcm9tIHRoaXNcbiAqIGxpYnJhcnksIHRvIGdldCBwcm9wZXIgdHlwZSBpbmZlcmVuY2UuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gY2hlY2sgdGhlIHZhbHVlIGFnYWluc3QsIGlmIHByZXNlbnQuXG4gKiBAcmV0dXJucyBBIHN0cnVjdCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdmFsaWQsIG9yIG5vdCBwcmVzZW50LlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBzdHJ1Y3QgPSBvYmplY3Qoe1xuICogICBmb286IGV4YWN0T3B0aW9uYWwoc3RyaW5nKCkpLFxuICogICBiYXI6IGV4YWN0T3B0aW9uYWwobnVtYmVyKCkpLFxuICogICBiYXo6IG9wdGlvbmFsKGJvb2xlYW4oKSksXG4gKiAgIHF1eDogdW5rbm93bigpLFxuICogfSk7XG4gKlxuICogdHlwZSBUeXBlID0gSW5mZXI8dHlwZW9mIHN0cnVjdD47XG4gKiAvLyBUeXBlIGlzIGVxdWl2YWxlbnQgdG86XG4gKiAvLyB7XG4gKiAvLyAgIGZvbz86IHN0cmluZztcbiAqIC8vICAgYmFyPzogbnVtYmVyO1xuICogLy8gICBiYXo/OiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICogLy8gICBxdXg6IHVua25vd247XG4gKiAvLyB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZXhhY3RPcHRpb25hbChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gbmV3IHN1cGVyc3RydWN0XzEuU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICB0eXBlOiBgb3B0aW9uYWwgJHtzdHJ1Y3QudHlwZX1gLFxuICAgICAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY29udGV4dCkgPT4gIWhhc09wdGlvbmFsKGNvbnRleHQpIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpLFxuICAgICAgICByZWZpbmVyOiAodmFsdWUsIGNvbnRleHQpID0+ICFoYXNPcHRpb25hbChjb250ZXh0KSB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY29udGV4dCksXG4gICAgfSk7XG59XG5leHBvcnRzLmV4YWN0T3B0aW9uYWwgPSBleGFjdE9wdGlvbmFsO1xuLyoqXG4gKiBBIHN0cnVjdCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgZmluaXRlIG51bWJlci4gU3VwZXJzdHJ1Y3Qnc1xuICogYG51bWJlcigpYCBzdHJ1Y3QgZG9lcyBub3QgY2hlY2sgaWYgdGhlIHZhbHVlIGlzIGZpbml0ZS5cbiAqXG4gKiBAcmV0dXJucyBBIHN0cnVjdCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgZmluaXRlIG51bWJlci5cbiAqL1xuY29uc3QgZmluaXRlTnVtYmVyID0gKCkgPT4gKDAsIHN1cGVyc3RydWN0XzEuZGVmaW5lKSgnZmluaXRlIG51bWJlcicsICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsICgwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSkgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlKTtcbn0pO1xuLyoqXG4gKiBBIHN0cnVjdCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCBKU09OLXNlcmlhbGl6YWJsZSB2YWx1ZS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBzdHJ1Y3QgaXMgdW5zYWZlLiBGb3Igc2FmZSB2YWxpZGF0aW9uLCB1c2Uge0BsaW5rIEpzb25TdHJ1Y3R9LlxuICovXG4vLyBXZSBjYW5ub3QgaW5mZXIgdGhlIHR5cGUgb2YgdGhlIHN0cnVjdCwgYmVjYXVzZSBpdCBpcyByZWN1cnNpdmUuXG5leHBvcnRzLlVuc2FmZUpzb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW1xuICAgICgwLCBzdXBlcnN0cnVjdF8xLmxpdGVyYWwpKG51bGwpLFxuICAgICgwLCBzdXBlcnN0cnVjdF8xLmJvb2xlYW4pKCksXG4gICAgZmluaXRlTnVtYmVyKCksXG4gICAgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLFxuICAgICgwLCBzdXBlcnN0cnVjdF8xLmFycmF5KSgoMCwgc3VwZXJzdHJ1Y3RfMS5sYXp5KSgoKSA9PiBleHBvcnRzLlVuc2FmZUpzb25TdHJ1Y3QpKSxcbiAgICAoMCwgc3VwZXJzdHJ1Y3RfMS5yZWNvcmQpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgKDAsIHN1cGVyc3RydWN0XzEubGF6eSkoKCkgPT4gZXhwb3J0cy5VbnNhZmVKc29uU3RydWN0KSksXG5dKTtcbi8qKlxuICogQSBzdHJ1Y3QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgSlNPTi1zZXJpYWxpemFibGUgdmFsdWUuXG4gKlxuICogVGhpcyBzdHJ1Y3Qgc2FuaXRpemVzIHRoZSB2YWx1ZSBiZWZvcmUgdmFsaWRhdGluZyBpdCwgc28gdGhhdCBpdCBpcyBzYWZlIHRvXG4gKiB1c2Ugd2l0aCB1bnRydXN0ZWQgaW5wdXQuXG4gKi9cbmV4cG9ydHMuSnNvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoZXhwb3J0cy5VbnNhZmVKc29uU3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5hbnkpKCksICh2YWx1ZSkgPT4ge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLlVuc2FmZUpzb25TdHJ1Y3QpO1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlLCAocHJvcEtleSwgcHJvcFZhbHVlKSA9PiB7XG4gICAgICAgIC8vIFN0cmlwIF9fcHJvdG9fXyBhbmQgY29uc3RydWN0b3IgcHJvcGVydGllcyB0byBwcmV2ZW50IHByb3RvdHlwZSBwb2xsdXRpb24uXG4gICAgICAgIGlmIChwcm9wS2V5ID09PSAnX19wcm90b19fJyB8fCBwcm9wS2V5ID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wVmFsdWU7XG4gICAgfSkpO1xufSk7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29ufSB2YWx1ZSwgaS5lLiwgYSB2YWx1ZSB0aGF0IGlzXG4gKiBzZXJpYWxpemFibGUgdG8gSlNPTi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29ufSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEpzb24odmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBnZXRTYWZlSnNvbih2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmlzVmFsaWRKc29uID0gaXNWYWxpZEpzb247XG4vKipcbiAqIFZhbGlkYXRlIGFuZCByZXR1cm4gc2FuaXRpemVkIEpTT04uXG4gKlxuICogTm90ZTpcbiAqIFRoaXMgZnVuY3Rpb24gdXNlcyBzYW5pdGl6ZWQgSnNvblN0cnVjdCBmb3IgdmFsaWRhdGlvblxuICogdGhhdCBhcHBsaWVzIHN0cmluZ2lmeSBhbmQgdGhlbiBwYXJzZSBvZiBhIHZhbHVlIHByb3ZpZGVkXG4gKiB0byBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgbm8gZ2V0dGVycyB3aGljaCBjYW4gaGF2ZSBzaWRlIGVmZmVjdHNcbiAqIHRoYXQgY2FuIGNhdXNlIHNlY3VyaXR5IGlzc3Vlcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBKU09OIHN0cnVjdHVyZSB0byBiZSBwcm9jZXNzZWQuXG4gKiBAcmV0dXJucyBTYW5pdGl6ZWQgSlNPTiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIGdldFNhZmVKc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIGV4cG9ydHMuSnNvblN0cnVjdCk7XG59XG5leHBvcnRzLmdldFNhZmVKc29uID0gZ2V0U2FmZUpzb247XG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiBhIEpTT04gdmFsdWUgaW4gYnl0ZXMuIFRoaXMgYWxzbyB2YWxpZGF0ZXMgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBKU09OIHZhbHVlIHRvIGdldCB0aGUgc2l6ZSBvZi5cbiAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSBKU09OIHZhbHVlIGluIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBnZXRKc29uU2l6ZSh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25TdHJ1Y3QsICdJbnZhbGlkIEpTT04gdmFsdWUnKTtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoanNvbikuYnl0ZUxlbmd0aDtcbn1cbmV4cG9ydHMuZ2V0SnNvblNpemUgPSBnZXRKc29uU2l6ZTtcbi8qKlxuICogVGhlIHN0cmluZyAnMi4wJy5cbiAqL1xuZXhwb3J0cy5qc29ucnBjMiA9ICcyLjAnO1xuZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmxpdGVyYWwpKGV4cG9ydHMuanNvbnJwYzIpO1xuZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5udWxsYWJsZSkoKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKV0pKTtcbmV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0ID0gKDAsIGV4cG9ydHMub2JqZWN0KSh7XG4gICAgY29kZTogKDAsIHN1cGVyc3RydWN0XzEuaW50ZWdlcikoKSxcbiAgICBtZXNzYWdlOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgZGF0YTogZXhhY3RPcHRpb25hbChleHBvcnRzLkpzb25TdHJ1Y3QpLFxuICAgIHN0YWNrOiBleGFjdE9wdGlvbmFsKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSksXG59KTtcbmV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEucmVjb3JkKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGV4cG9ydHMuSnNvblN0cnVjdCksICgwLCBzdXBlcnN0cnVjdF8xLmFycmF5KShleHBvcnRzLkpzb25TdHJ1Y3QpXSk7XG5leHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0ID0gKDAsIGV4cG9ydHMub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgbWV0aG9kOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgcGFyYW1zOiBleGFjdE9wdGlvbmFsKGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCksXG59KTtcbmV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCA9ICgwLCBleHBvcnRzLm9iamVjdCkoe1xuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgbWV0aG9kOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgcGFyYW1zOiBleGFjdE9wdGlvbmFsKGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCksXG59KTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufVxuICogb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNOb3RpZmljYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNOb3RpZmljYXRpb24gPSBpc0pzb25ScGNOb3RpZmljYXRpb247XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbih2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBub3RpZmljYXRpb24nLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24gPSBhc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb247XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1JlcXVlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjUmVxdWVzdCA9IGlzSnNvblJwY1JlcXVlc3Q7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBKU09OLVJQQyByZXF1ZXN0IG9yIG5vdGlmaWNhdGlvbiB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgcmVxdWVzdCcsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBhc3NlcnRJc0pzb25ScGNSZXF1ZXN0O1xuZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgcmVzdWx0OiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoKDAsIHN1cGVyc3RydWN0XzEudW5rbm93bikoKSksXG4gICAgZXJyb3I6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKShleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCksXG59KTtcbmV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QgPSAoMCwgZXhwb3J0cy5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICByZXN1bHQ6IGV4cG9ydHMuSnNvblN0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCA9ICgwLCBleHBvcnRzLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIGVycm9yOiBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW1xuICAgIGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QsXG4gICAgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCxcbl0pO1xuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIHdoZXRoZXIgc3BlY2lmaWVkIEpTT04tUlBDIHJlc3BvbnNlIGlzIGFcbiAqIHtAbGluayBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlfS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgSlNPTi1SUEMgcmVzcG9uc2UgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgSlNPTi1SUEMgcmVzcG9uc2UgaXMgcGVuZGluZy5cbiAqL1xuZnVuY3Rpb24gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKShyZXNwb25zZSwgZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBKU09OLVJQQyByZXNwb25zZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX1cbiAqIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHJlc3BvbnNlLCBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QsICdJbnZhbGlkIHBlbmRpbmcgSlNPTi1SUEMgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHtAbGluayBKc29uUnBjUmVzcG9uc2V9LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBvYmplY3QgaXMgYSBKc29uUnBjUmVzcG9uc2UuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKShyZXNwb25zZSwgZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNSZXNwb25zZSA9IGlzSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1Jlc3BvbnNlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVzcG9uc2V9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1Jlc3BvbnNlID0gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1N1Y2Nlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IGlzSnNvblJwY1N1Y2Nlc3M7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjU3VjY2Vzcyh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgc3VjY2VzcyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1N1Y2Nlc3MgPSBhc3NlcnRJc0pzb25ScGNTdWNjZXNzO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNGYWlsdXJlKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY0ZhaWx1cmUgPSBpc0pzb25ScGNGYWlsdXJlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY0ZhaWx1cmUodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIGZhaWx1cmUgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNGYWlsdXJlID0gYXNzZXJ0SXNKc29uUnBjRmFpbHVyZTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNFcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjRXJyb3IgPSBpc0pzb25ScGNFcnJvcjtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY0Vycm9yKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgZXJyb3InLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNFcnJvciA9IGFzc2VydElzSnNvblJwY0Vycm9yO1xuLyoqXG4gKiBHZXRzIGEgZnVuY3Rpb24gZm9yIHZhbGlkYXRpbmcgSlNPTi1SUEMgcmVxdWVzdCAvIHJlc3BvbnNlIGBpZGAgdmFsdWVzLlxuICpcbiAqIEJ5IG1hbmlwdWxhdGluZyB0aGUgb3B0aW9ucyBvZiB0aGlzIGZhY3RvcnksIHlvdSBjYW4gY29udHJvbCB0aGUgYmVoYXZpb3JcbiAqIG9mIHRoZSByZXN1bHRpbmcgdmFsaWRhdG9yIGZvciBzb21lIGVkZ2UgY2FzZXMuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgZS5nLlxuICogYG51bGxgIHNob3VsZCBzb21ldGltZXMgYnV0IG5vdCBhbHdheXMgYmUgcGVybWl0dGVkLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgZW1wdHkgc3RyaW5nIChgJydgKSBpcyBhbHdheXMgcGVybWl0dGVkIGJ5IHRoZSBKU09OLVJQQ1xuICogc3BlY2lmaWNhdGlvbiwgYnV0IHRoYXQga2luZCBvZiBzdWNrcyBhbmQgeW91IG1heSB3YW50IHRvIGZvcmJpZCBpdCBpbiBzb21lXG4gKiBpbnN0YW5jZXMgYW55d2F5LlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGVcbiAqIFtKU09OLVJQQyBTcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy5qc29ucnBjLm9yZy9zcGVjaWZpY2F0aW9uKS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0RW1wdHlTdHJpbmcgLSBXaGV0aGVyIHRoZSBlbXB0eSBzdHJpbmcgKGkuZS4gYCcnYClcbiAqIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgdmFsaWQgSUQuIERlZmF1bHQ6IGB0cnVlYFxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0RnJhY3Rpb25zIC0gV2hldGhlciBmcmFjdGlvbmFsIG51bWJlcnMgKGUuZy4gYDEuMmApXG4gKiBzaG91bGQgYmUgdHJlYXRlZCBhcyB2YWxpZCBJRHMuIERlZmF1bHQ6IGBmYWxzZWBcbiAqIEBwYXJhbSBvcHRpb25zLnBlcm1pdE51bGwgLSBXaGV0aGVyIGBudWxsYCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHZhbGlkIElELlxuICogRGVmYXVsdDogYHRydWVgXG4gKiBAcmV0dXJucyBUaGUgSlNPTi1SUEMgSUQgdmFsaWRhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRKc29uUnBjSWRWYWxpZGF0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGVybWl0RW1wdHlTdHJpbmcsIHBlcm1pdEZyYWN0aW9ucywgcGVybWl0TnVsbCB9ID0ge1xuICAgICAgICBwZXJtaXRFbXB0eVN0cmluZzogdHJ1ZSxcbiAgICAgICAgcGVybWl0RnJhY3Rpb25zOiBmYWxzZSxcbiAgICAgICAgcGVybWl0TnVsbDogdHJ1ZSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmQgZm9yIHtAbGluayBKc29uUnBjSWR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIEpTT04tUlBDIElEIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIElEIGlzIHZhbGlkIHBlciB0aGUgb3B0aW9ucyBnaXZlbiB0byB0aGVcbiAgICAgKiBmYWN0b3J5LlxuICAgICAqL1xuICAgIGNvbnN0IGlzVmFsaWRKc29uUnBjSWQgPSAoaWQpID0+IHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKHR5cGVvZiBpZCA9PT0gJ251bWJlcicgJiYgKHBlcm1pdEZyYWN0aW9ucyB8fCBOdW1iZXIuaXNJbnRlZ2VyKGlkKSkpIHx8XG4gICAgICAgICAgICAodHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiAocGVybWl0RW1wdHlTdHJpbmcgfHwgaWQubGVuZ3RoID4gMCkpIHx8XG4gICAgICAgICAgICAocGVybWl0TnVsbCAmJiBpZCA9PT0gbnVsbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIGlzVmFsaWRKc29uUnBjSWQ7XG59XG5leHBvcnRzLmdldEpzb25ScGNJZFZhbGlkYXRvciA9IGdldEpzb25ScGNJZFZhbGlkYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24uY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/json.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/keyring.cjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/keyring.cjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=keyring.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3Qva2V5cmluZy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3Qva2V5cmluZy5janM/ZWE3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXJpbmcuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/keyring.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/logging.cjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/logging.cjs ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createModuleLogger = exports.createProjectLogger = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\"));\nconst globalLogger = (0, debug_1.default)('metamask');\n/**\n * Creates a logger via the `debug` library whose log messages will be tagged\n * using the name of your project. By default, such messages will be\n * suppressed, but you can reveal them by setting the `DEBUG` environment\n * variable to `metamask:<projectName>`. You can also set this variable to\n * `metamask:*` if you want to see log messages from all MetaMask projects that\n * are also using this function to create their loggers.\n *\n * @param projectName - The name of your project. This should be the name of\n * your NPM package if you're developing one.\n * @returns An instance of `debug`.\n */\nfunction createProjectLogger(projectName) {\n    return globalLogger.extend(projectName);\n}\nexports.createProjectLogger = createProjectLogger;\n/**\n * Creates a logger via the `debug` library which is derived from the logger for\n * the whole project whose log messages will be tagged using the name of your\n * module. By default, such messages will be suppressed, but you can reveal them\n * by setting the `DEBUG` environment variable to\n * `metamask:<projectName>:<moduleName>`. You can also set this variable to\n * `metamask:<projectName>:*` if you want to see log messages from the project,\n * or `metamask:*` if you want to see log messages from all MetaMask projects.\n *\n * @param projectLogger - The logger created via {@link createProjectLogger}.\n * @param moduleName - The name of your module. You could use the name of the\n * file where you're using this logger or some other name.\n * @returns An instance of `debug`.\n */\nfunction createModuleLogger(projectLogger, moduleName) {\n    return projectLogger.extend(moduleName);\n}\nexports.createModuleLogger = createModuleLogger;\n//# sourceMappingURL=logging.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbG9nZ2luZy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRywyQkFBMkI7QUFDeEQsZ0NBQWdDLG1CQUFPLENBQUMsc0RBQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDBCQUEwQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9sb2dnaW5nLmNqcz84NThlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBleHBvcnRzLmNyZWF0ZVByb2plY3RMb2dnZXIgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBnbG9iYWxMb2dnZXIgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbWV0YW1hc2snKTtcbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2dlciB2aWEgdGhlIGBkZWJ1Z2AgbGlicmFyeSB3aG9zZSBsb2cgbWVzc2FnZXMgd2lsbCBiZSB0YWdnZWRcbiAqIHVzaW5nIHRoZSBuYW1lIG9mIHlvdXIgcHJvamVjdC4gQnkgZGVmYXVsdCwgc3VjaCBtZXNzYWdlcyB3aWxsIGJlXG4gKiBzdXBwcmVzc2VkLCBidXQgeW91IGNhbiByZXZlYWwgdGhlbSBieSBzZXR0aW5nIHRoZSBgREVCVUdgIGVudmlyb25tZW50XG4gKiB2YXJpYWJsZSB0byBgbWV0YW1hc2s6PHByb2plY3ROYW1lPmAuIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB2YXJpYWJsZSB0b1xuICogYG1ldGFtYXNrOipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSBhbGwgTWV0YU1hc2sgcHJvamVjdHMgdGhhdFxuICogYXJlIGFsc28gdXNpbmcgdGhpcyBmdW5jdGlvbiB0byBjcmVhdGUgdGhlaXIgbG9nZ2Vycy5cbiAqXG4gKiBAcGFyYW0gcHJvamVjdE5hbWUgLSBUaGUgbmFtZSBvZiB5b3VyIHByb2plY3QuIFRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mXG4gKiB5b3VyIE5QTSBwYWNrYWdlIGlmIHlvdSdyZSBkZXZlbG9waW5nIG9uZS5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIGBkZWJ1Z2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb2plY3RMb2dnZXIocHJvamVjdE5hbWUpIHtcbiAgICByZXR1cm4gZ2xvYmFsTG9nZ2VyLmV4dGVuZChwcm9qZWN0TmFtZSk7XG59XG5leHBvcnRzLmNyZWF0ZVByb2plY3RMb2dnZXIgPSBjcmVhdGVQcm9qZWN0TG9nZ2VyO1xuLyoqXG4gKiBDcmVhdGVzIGEgbG9nZ2VyIHZpYSB0aGUgYGRlYnVnYCBsaWJyYXJ5IHdoaWNoIGlzIGRlcml2ZWQgZnJvbSB0aGUgbG9nZ2VyIGZvclxuICogdGhlIHdob2xlIHByb2plY3Qgd2hvc2UgbG9nIG1lc3NhZ2VzIHdpbGwgYmUgdGFnZ2VkIHVzaW5nIHRoZSBuYW1lIG9mIHlvdXJcbiAqIG1vZHVsZS4gQnkgZGVmYXVsdCwgc3VjaCBtZXNzYWdlcyB3aWxsIGJlIHN1cHByZXNzZWQsIGJ1dCB5b3UgY2FuIHJldmVhbCB0aGVtXG4gKiBieSBzZXR0aW5nIHRoZSBgREVCVUdgIGVudmlyb25tZW50IHZhcmlhYmxlIHRvXG4gKiBgbWV0YW1hc2s6PHByb2plY3ROYW1lPjo8bW9kdWxlTmFtZT5gLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdmFyaWFibGUgdG9cbiAqIGBtZXRhbWFzazo8cHJvamVjdE5hbWU+OipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSB0aGUgcHJvamVjdCxcbiAqIG9yIGBtZXRhbWFzazoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gYWxsIE1ldGFNYXNrIHByb2plY3RzLlxuICpcbiAqIEBwYXJhbSBwcm9qZWN0TG9nZ2VyIC0gVGhlIGxvZ2dlciBjcmVhdGVkIHZpYSB7QGxpbmsgY3JlYXRlUHJvamVjdExvZ2dlcn0uXG4gKiBAcGFyYW0gbW9kdWxlTmFtZSAtIFRoZSBuYW1lIG9mIHlvdXIgbW9kdWxlLiBZb3UgY291bGQgdXNlIHRoZSBuYW1lIG9mIHRoZVxuICogZmlsZSB3aGVyZSB5b3UncmUgdXNpbmcgdGhpcyBsb2dnZXIgb3Igc29tZSBvdGhlciBuYW1lLlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYGRlYnVnYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9kdWxlTG9nZ2VyKHByb2plY3RMb2dnZXIsIG1vZHVsZU5hbWUpIHtcbiAgICByZXR1cm4gcHJvamVjdExvZ2dlci5leHRlbmQobW9kdWxlTmFtZSk7XG59XG5leHBvcnRzLmNyZWF0ZU1vZHVsZUxvZ2dlciA9IGNyZWF0ZU1vZHVsZUxvZ2dlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmcuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/logging.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/misc.cjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/misc.cjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n//\n// Types\n//\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.getKnownPropertyNames = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;\n//\n// Type Guards\n//\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */\nfunction isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\nexports.isNonEmptyArray = isNonEmptyArray;\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */\nfunction isObject(value) {\n    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);\n}\nexports.isObject = isObject;\n//\n// Other utility functions\n//\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */\nconst hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);\nexports.hasProperty = hasProperty;\n/**\n * `Object.getOwnPropertyNames()` is intentionally generic: it returns the\n * immediate property names of an object, but it cannot make guarantees about\n * the contents of that object, so the type of the property names is merely\n * `string[]`. While this is technically accurate, it is also unnecessary if we\n * have an object with a type that we own (such as an enum).\n *\n * @param object - The plain object.\n * @returns The own property names of the object which are assigned a type\n * derived from the object itself.\n */\nfunction getKnownPropertyNames(object) {\n    return Object.getOwnPropertyNames(object);\n}\nexports.getKnownPropertyNames = getKnownPropertyNames;\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */\nvar JsonSize;\n(function (JsonSize) {\n    JsonSize[JsonSize[\"Null\"] = 4] = \"Null\";\n    JsonSize[JsonSize[\"Comma\"] = 1] = \"Comma\";\n    JsonSize[JsonSize[\"Wrapper\"] = 1] = \"Wrapper\";\n    JsonSize[JsonSize[\"True\"] = 4] = \"True\";\n    JsonSize[JsonSize[\"False\"] = 5] = \"False\";\n    JsonSize[JsonSize[\"Quote\"] = 1] = \"Quote\";\n    JsonSize[JsonSize[\"Colon\"] = 1] = \"Colon\";\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    JsonSize[JsonSize[\"Date\"] = 24] = \"Date\";\n})(JsonSize = exports.JsonSize || (exports.JsonSize = {}));\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */\nexports.ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */\nfunction isPlainObject(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while (Object.getPrototypeOf(proto) !== null) {\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    }\n    catch (_) {\n        return false;\n    }\n}\nexports.isPlainObject = isPlainObject;\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */\nfunction isASCII(character) {\n    return character.charCodeAt(0) <= 127;\n}\nexports.isASCII = isASCII;\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */\nfunction calculateStringSize(value) {\n    const size = value.split('').reduce((total, character) => {\n        if (isASCII(character)) {\n            return total + 1;\n        }\n        return total + 2;\n    }, 0);\n    // Also detect characters that need backslash escape\n    return size + (value.match(exports.ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\nexports.calculateStringSize = calculateStringSize;\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */\nfunction calculateNumberSize(value) {\n    return value.toString().length;\n}\nexports.calculateNumberSize = calculateNumberSize;\n//# sourceMappingURL=misc.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbWlzYy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsZUFBZSxHQUFHLHFCQUFxQixHQUFHLGdDQUFnQyxHQUFHLGdCQUFnQixHQUFHLDZCQUE2QixHQUFHLG1CQUFtQixHQUFHLGdCQUFnQixHQUFHLHlCQUF5QixHQUFHLHVCQUF1QjtBQUN4UjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0scUJBQXFCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQyxnQkFBZ0IsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L21pc2MuY2pzPzU2M2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vL1xuLy8gVHlwZXNcbi8vXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbGN1bGF0ZU51bWJlclNpemUgPSBleHBvcnRzLmNhbGN1bGF0ZVN0cmluZ1NpemUgPSBleHBvcnRzLmlzQVNDSUkgPSBleHBvcnRzLmlzUGxhaW5PYmplY3QgPSBleHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCA9IGV4cG9ydHMuSnNvblNpemUgPSBleHBvcnRzLmdldEtub3duUHJvcGVydHlOYW1lcyA9IGV4cG9ydHMuaGFzUHJvcGVydHkgPSBleHBvcnRzLmlzT2JqZWN0ID0gZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gdm9pZCAwO1xuLy9cbi8vIFR5cGUgR3VhcmRzXG4vL1xuLyoqXG4gKiBBIHtAbGluayBOb25FbXB0eUFycmF5fSB0eXBlIGd1YXJkLlxuICpcbiAqIEB0ZW1wbGF0ZSBFbGVtZW50IC0gVGhlIG5vbi1lbXB0eSBhcnJheSBtZW1iZXIgdHlwZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgbm9uLWVtcHR5IGFycmF5LlxuICovXG5mdW5jdGlvbiBpc05vbkVtcHR5QXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMDtcbn1cbmV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gaXNOb25FbXB0eUFycmF5O1xuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBcIm51bGxpc2huZXNzXCIuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gQW55IHZhbHVlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3Ige0BsaW5rIFJ1bnRpbWVPYmplY3R9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBoYXMgYSBydW50aW1lIHR5cGUgb2YgYG9iamVjdGAgYW5kIGlzXG4gKiBuZWl0aGVyIGBudWxsYCBub3IgYW4gYEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vL1xuLy8gT3RoZXIgdXRpbGl0eSBmdW5jdGlvbnNcbi8vXG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3IgZW5zdXJpbmcgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBvYmplY3RUb0NoZWNrIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIHByb3BlcnR5IG5hbWUgdG8gY2hlY2sgZm9yLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZFxuICogbmFtZSwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0IGlzIGVudW1lcmFibGUgb3Igbm90LlxuICovXG5jb25zdCBoYXNQcm9wZXJ0eSA9IChvYmplY3RUb0NoZWNrLCBuYW1lKSA9PiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3RUb0NoZWNrLCBuYW1lKTtcbmV4cG9ydHMuaGFzUHJvcGVydHkgPSBoYXNQcm9wZXJ0eTtcbi8qKlxuICogYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKClgIGlzIGludGVudGlvbmFsbHkgZ2VuZXJpYzogaXQgcmV0dXJucyB0aGVcbiAqIGltbWVkaWF0ZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QsIGJ1dCBpdCBjYW5ub3QgbWFrZSBndWFyYW50ZWVzIGFib3V0XG4gKiB0aGUgY29udGVudHMgb2YgdGhhdCBvYmplY3QsIHNvIHRoZSB0eXBlIG9mIHRoZSBwcm9wZXJ0eSBuYW1lcyBpcyBtZXJlbHlcbiAqIGBzdHJpbmdbXWAuIFdoaWxlIHRoaXMgaXMgdGVjaG5pY2FsbHkgYWNjdXJhdGUsIGl0IGlzIGFsc28gdW5uZWNlc3NhcnkgaWYgd2VcbiAqIGhhdmUgYW4gb2JqZWN0IHdpdGggYSB0eXBlIHRoYXQgd2Ugb3duIChzdWNoIGFzIGFuIGVudW0pLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgcGxhaW4gb2JqZWN0LlxuICogQHJldHVybnMgVGhlIG93biBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgb2JqZWN0IHdoaWNoIGFyZSBhc3NpZ25lZCBhIHR5cGVcbiAqIGRlcml2ZWQgZnJvbSB0aGUgb2JqZWN0IGl0c2VsZi5cbiAqL1xuZnVuY3Rpb24gZ2V0S25vd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpO1xufVxuZXhwb3J0cy5nZXRLbm93blByb3BlcnR5TmFtZXMgPSBnZXRLbm93blByb3BlcnR5TmFtZXM7XG4vKipcbiAqIFByZWRlZmluZWQgc2l6ZXMgKGluIEJ5dGVzKSBvZiBzcGVjaWZpYyBwYXJ0cyBvZiBKU09OIHN0cnVjdHVyZS5cbiAqL1xudmFyIEpzb25TaXplO1xuKGZ1bmN0aW9uIChKc29uU2l6ZSkge1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiTnVsbFwiXSA9IDRdID0gXCJOdWxsXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJDb21tYVwiXSA9IDFdID0gXCJDb21tYVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiV3JhcHBlclwiXSA9IDFdID0gXCJXcmFwcGVyXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJUcnVlXCJdID0gNF0gPSBcIlRydWVcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkZhbHNlXCJdID0gNV0gPSBcIkZhbHNlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJRdW90ZVwiXSA9IDFdID0gXCJRdW90ZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiQ29sb25cIl0gPSAxXSA9IFwiQ29sb25cIjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiRGF0ZVwiXSA9IDI0XSA9IFwiRGF0ZVwiO1xufSkoSnNvblNpemUgPSBleHBvcnRzLkpzb25TaXplIHx8IChleHBvcnRzLkpzb25TaXplID0ge30pKTtcbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHdpdGggcGF0dGVybiBtYXRjaGluZyBmb3IgKHNwZWNpYWwpIGVzY2FwZWQgY2hhcmFjdGVycy5cbiAqL1xuZXhwb3J0cy5FU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFAgPSAvXCJ8XFxcXHxcXG58XFxyfFxcdC9ndTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVHJ1ZSBpZiBhbiBvYmplY3QgaXMgdGhlIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LFxuICogZmFsc2UgaWYgdGhlIG9iamVjdCBpcyBub3QgcGxhaW4gKGUuZy4gZnVuY3Rpb24pLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBsZXQgcHJvdG8gPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gcHJvdG87XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuLyoqXG4gKiBDaGVjayBpZiBjaGFyYWN0ZXIgaXMgQVNDSUkuXG4gKlxuICogQHBhcmFtIGNoYXJhY3RlciAtIENoYXJhY3Rlci5cbiAqIEByZXR1cm5zIFRydWUgaWYgYSBjaGFyYWN0ZXIgY29kZSBpcyBBU0NJSSwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBpc0FTQ0lJKGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSA8PSAxMjc7XG59XG5leHBvcnRzLmlzQVNDSUkgPSBpc0FTQ0lJO1xuLyoqXG4gKiBDYWxjdWxhdGUgc3RyaW5nIHNpemUuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gU3RyaW5nIHZhbHVlIHRvIGNhbGN1bGF0ZSBzaXplLlxuICogQHJldHVybnMgTnVtYmVyIG9mIGJ5dGVzIHVzZWQgdG8gc3RvcmUgd2hvbGUgc3RyaW5nIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTdHJpbmdTaXplKHZhbHVlKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHZhbHVlLnNwbGl0KCcnKS5yZWR1Y2UoKHRvdGFsLCBjaGFyYWN0ZXIpID0+IHtcbiAgICAgICAgaWYgKGlzQVNDSUkoY2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWwgKyAyO1xuICAgIH0sIDApO1xuICAgIC8vIEFsc28gZGV0ZWN0IGNoYXJhY3RlcnMgdGhhdCBuZWVkIGJhY2tzbGFzaCBlc2NhcGVcbiAgICByZXR1cm4gc2l6ZSArICh2YWx1ZS5tYXRjaChleHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCkgPz8gW10pLmxlbmd0aDtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlU3RyaW5nU2l6ZSA9IGNhbGN1bGF0ZVN0cmluZ1NpemU7XG4vKipcbiAqIENhbGN1bGF0ZSBzaXplIG9mIGEgbnVtYmVyIG9mdGVyIEpTT04gc2VyaWFsaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBOdW1iZXIgdmFsdWUgdG8gY2FsY3VsYXRlIHNpemUuXG4gKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgdXNlZCB0byBzdG9yZSB3aG9sZSBudW1iZXIgaW4gSlNPTi5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlTnVtYmVyU2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aDtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlTnVtYmVyU2l6ZSA9IGNhbGN1bGF0ZU51bWJlclNpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taXNjLmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/misc.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/number.cjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/number.cjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/assert.cjs\");\nconst hex_1 = __webpack_require__(/*! ./hex.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/hex.cjs\");\n/**\n * Convert a number to a hexadecimal string. This verifies that the number is a\n * non-negative safe integer.\n *\n * To convert a `bigint` to a hexadecimal string instead, use\n * {@link bigIntToHex}.\n *\n * @example\n * ```typescript\n * numberToHex(0); // '0x0'\n * numberToHex(1); // '0x1'\n * numberToHex(16); // '0x10'\n * ```\n * @param value - The number to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the number is not a non-negative safe integer.\n */\nconst numberToHex = (value) => {\n    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');\n    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');\n    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToHex` instead.');\n    return (0, hex_1.add0x)(value.toString(16));\n};\nexports.numberToHex = numberToHex;\n/**\n * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`\n * is a non-negative integer.\n *\n * To convert a number to a hexadecimal string instead, use {@link numberToHex}.\n *\n * @example\n * ```typescript\n * bigIntToHex(0n); // '0x0'\n * bigIntToHex(1n); // '0x1'\n * bigIntToHex(16n); // '0x10'\n * ```\n * @param value - The `bigint` to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the `bigint` is not a non-negative integer.\n */\nconst bigIntToHex = (value) => {\n    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');\n    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative bigint.');\n    return (0, hex_1.add0x)(value.toString(16));\n};\nexports.bigIntToHex = bigIntToHex;\n/**\n * Convert a hexadecimal string to a number. This verifies that the string is a\n * valid hex string, and that the resulting number is a safe integer. Both\n * \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a `bigint` instead, use\n * {@link hexToBigInt}.\n *\n * @example\n * ```typescript\n * hexToNumber('0x0'); // 0\n * hexToNumber('0x1'); // 1\n * hexToNumber('0x10'); // 16\n * ```\n * @param value - The hexadecimal string to convert to a number.\n * @returns The number.\n * @throws If the value is not a valid hexadecimal string, or if the resulting\n * number is not a safe integer.\n */\nconst hexToNumber = (value) => {\n    (0, hex_1.assertIsHexString)(value);\n    // `parseInt` accepts values without the \"0x\"-prefix, whereas `Number` does\n    // not. Using this is slightly faster than `Number(add0x(value))`.\n    const numberValue = parseInt(value, 16);\n    (0, assert_1.assert)(Number.isSafeInteger(numberValue), 'Value is not a safe integer. Use `hexToBigInt` instead.');\n    return numberValue;\n};\nexports.hexToNumber = hexToNumber;\n/**\n * Convert a hexadecimal string to a `bigint`. This verifies that the string is\n * a valid hex string. Both \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.\n *\n * @example\n * ```typescript\n * hexToBigInt('0x0'); // 0n\n * hexToBigInt('0x1'); // 1n\n * hexToBigInt('0x10'); // 16n\n * ```\n * @param value - The hexadecimal string to convert to a `bigint`.\n * @returns The `bigint`.\n * @throws If the value is not a valid hexadecimal string.\n */\nconst hexToBigInt = (value) => {\n    (0, hex_1.assertIsHexString)(value);\n    // The `BigInt` constructor requires the \"0x\"-prefix to parse a hex string.\n    return BigInt((0, hex_1.add0x)(value));\n};\nexports.hexToBigInt = hexToBigInt;\n//# sourceMappingURL=number.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbnVtYmVyLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUI7QUFDckYsaUJBQWlCLG1CQUFPLENBQUMsMkdBQWM7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLHFHQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtCQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGtCQUFrQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtCQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGtCQUFrQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9udW1iZXIuY2pzP2ExOGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhleFRvQmlnSW50ID0gZXhwb3J0cy5oZXhUb051bWJlciA9IGV4cG9ydHMuYmlnSW50VG9IZXggPSBleHBvcnRzLm51bWJlclRvSGV4ID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnQuY2pzXCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXguY2pzXCIpO1xuLyoqXG4gKiBDb252ZXJ0IGEgbnVtYmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIG51bWJlciBpcyBhXG4gKiBub24tbmVnYXRpdmUgc2FmZSBpbnRlZ2VyLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgYmlnaW50YCB0byBhIGhleGFkZWNpbWFsIHN0cmluZyBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBiaWdJbnRUb0hleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIG51bWJlclRvSGV4KDApOyAvLyAnMHgwJ1xuICogbnVtYmVyVG9IZXgoMSk7IC8vICcweDEnXG4gKiBudW1iZXJUb0hleCgxNik7IC8vICcweDEwJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLCB3aXRoIHRoZSBcIjB4XCItcHJlZml4LlxuICogQHRocm93cyBJZiB0aGUgbnVtYmVyIGlzIG5vdCBhIG5vbi1uZWdhdGl2ZSBzYWZlIGludGVnZXIuXG4gKi9cbmNvbnN0IG51bWJlclRvSGV4ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ1ZhbHVlIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBiaWdJbnRUb0hleGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gKDAsIGhleF8xLmFkZDB4KSh2YWx1ZS50b1N0cmluZygxNikpO1xufTtcbmV4cG9ydHMubnVtYmVyVG9IZXggPSBudW1iZXJUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGBiaWdpbnRgIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIGBiaWdpbnRgXG4gKiBpcyBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBudW1iZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcgaW5zdGVhZCwgdXNlIHtAbGluayBudW1iZXJUb0hleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGJpZ0ludFRvSGV4KDBuKTsgLy8gJzB4MCdcbiAqIGJpZ0ludFRvSGV4KDFuKTsgLy8gJzB4MSdcbiAqIGJpZ0ludFRvSGV4KDE2bik7IC8vICcweDEwJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYGJpZ2ludGAgdG8gY29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcsIHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKiBAdGhyb3dzIElmIHRoZSBgYmlnaW50YCBpcyBub3QgYSBub24tbmVnYXRpdmUgaW50ZWdlci5cbiAqL1xuY29uc3QgYmlnSW50VG9IZXggPSAodmFsdWUpID0+IHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnLCAnVmFsdWUgbXVzdCBiZSBhIGJpZ2ludC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSAwLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBiaWdpbnQuJyk7XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkodmFsdWUudG9TdHJpbmcoMTYpKTtcbn07XG5leHBvcnRzLmJpZ0ludFRvSGV4ID0gYmlnSW50VG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBudW1iZXIuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgc3RyaW5nIGlzIGFcbiAqIHZhbGlkIGhleCBzdHJpbmcsIGFuZCB0aGF0IHRoZSByZXN1bHRpbmcgbnVtYmVyIGlzIGEgc2FmZSBpbnRlZ2VyLiBCb3RoXG4gKiBcIjB4XCItcHJlZml4ZWQgYW5kIHVucHJlZml4ZWQgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgYmlnaW50YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBoZXhUb0JpZ0ludH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGhleFRvTnVtYmVyKCcweDAnKTsgLy8gMFxuICogaGV4VG9OdW1iZXIoJzB4MScpOyAvLyAxXG4gKiBoZXhUb051bWJlcignMHgxMCcpOyAvLyAxNlxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4YWRlY2ltYWwgc3RyaW5nLCBvciBpZiB0aGUgcmVzdWx0aW5nXG4gKiBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5jb25zdCBoZXhUb051bWJlciA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBoZXhfMS5hc3NlcnRJc0hleFN0cmluZykodmFsdWUpO1xuICAgIC8vIGBwYXJzZUludGAgYWNjZXB0cyB2YWx1ZXMgd2l0aG91dCB0aGUgXCIweFwiLXByZWZpeCwgd2hlcmVhcyBgTnVtYmVyYCBkb2VzXG4gICAgLy8gbm90LiBVc2luZyB0aGlzIGlzIHNsaWdodGx5IGZhc3RlciB0aGFuIGBOdW1iZXIoYWRkMHgodmFsdWUpKWAuXG4gICAgY29uc3QgbnVtYmVyVmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTYpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlclZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBoZXhUb0JpZ0ludGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gbnVtYmVyVmFsdWU7XG59O1xuZXhwb3J0cy5oZXhUb051bWJlciA9IGhleFRvTnVtYmVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYGJpZ2ludGAuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgc3RyaW5nIGlzXG4gKiBhIHZhbGlkIGhleCBzdHJpbmcuIEJvdGggXCIweFwiLXByZWZpeGVkIGFuZCB1bnByZWZpeGVkIHN0cmluZ3MgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgbnVtYmVyIGluc3RlYWQsIHVzZSB7QGxpbmsgaGV4VG9OdW1iZXJ9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBoZXhUb0JpZ0ludCgnMHgwJyk7IC8vIDBuXG4gKiBoZXhUb0JpZ0ludCgnMHgxJyk7IC8vIDFuXG4gKiBoZXhUb0JpZ0ludCgnMHgxMCcpOyAvLyAxNm5cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGEgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgYGJpZ2ludGAuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmNvbnN0IGhleFRvQmlnSW50ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGhleF8xLmFzc2VydElzSGV4U3RyaW5nKSh2YWx1ZSk7XG4gICAgLy8gVGhlIGBCaWdJbnRgIGNvbnN0cnVjdG9yIHJlcXVpcmVzIHRoZSBcIjB4XCItcHJlZml4IHRvIHBhcnNlIGEgaGV4IHN0cmluZy5cbiAgICByZXR1cm4gQmlnSW50KCgwLCBoZXhfMS5hZGQweCkodmFsdWUpKTtcbn07XG5leHBvcnRzLmhleFRvQmlnSW50ID0gaGV4VG9CaWdJbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/number.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/opaque.cjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/opaque.cjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=opaque.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3Qvb3BhcXVlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9vcGFxdWUuY2pzP2YyYTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGFxdWUuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/opaque.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/promise.cjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/promise.cjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createDeferredPromise = void 0;\n/**\n * Create a defered Promise.\n *\n * If the Promise is rejected prior to a handler being added, this can result in an\n * `UnhandledPromiseRejection` error. Optionally this can be suppressed with the\n * `suppressUnhandledRejection` flag, as it's common to belatedly handle deferred Promises, or to\n * ignore them if they're no longer relevant (e.g. related to a cancelled request).\n *\n * However, be very careful that you have handled the Promise if you do this. Suppressing these\n * errors is dangerous, they exist for good reason. An unhandled rejection can hide errors, making\n * debugging extremely difficult. They should only be suppressed if you're confident that the\n * Promise is always handled correctly, in both the success and failure cases.\n *\n * @param args - The arguments.\n * @param args.suppressUnhandledRejection - This option adds an empty error handler\n * to the Promise to suppress the UnhandledPromiseRejection error. This can be\n * useful if the deferred Promise is sometimes intentionally not used.\n * @returns A deferred Promise.\n * @template Result - The result type of the Promise.\n */\nfunction createDeferredPromise({ suppressUnhandledRejection = false, } = {}) {\n    let resolve;\n    let reject;\n    const promise = new Promise((innerResolve, innerReject) => {\n        resolve = innerResolve;\n        reject = innerReject;\n    });\n    if (suppressUnhandledRejection) {\n        promise.catch((_error) => {\n            // This handler is used to suppress the UnhandledPromiseRejection error\n        });\n    }\n    // @ts-expect-error We know that these are assigned, but TypeScript doesn't\n    return { promise, resolve, reject };\n}\nexports.createDeferredPromise = createDeferredPromise;\n//# sourceMappingURL=promise.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvcHJvbWlzZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0NBQXNDLElBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9wcm9taXNlLmNqcz9hZTVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVEZWZlcnJlZFByb21pc2UgPSB2b2lkIDA7XG4vKipcbiAqIENyZWF0ZSBhIGRlZmVyZWQgUHJvbWlzZS5cbiAqXG4gKiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCBwcmlvciB0byBhIGhhbmRsZXIgYmVpbmcgYWRkZWQsIHRoaXMgY2FuIHJlc3VsdCBpbiBhblxuICogYFVuaGFuZGxlZFByb21pc2VSZWplY3Rpb25gIGVycm9yLiBPcHRpb25hbGx5IHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgd2l0aCB0aGVcbiAqIGBzdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbmAgZmxhZywgYXMgaXQncyBjb21tb24gdG8gYmVsYXRlZGx5IGhhbmRsZSBkZWZlcnJlZCBQcm9taXNlcywgb3IgdG9cbiAqIGlnbm9yZSB0aGVtIGlmIHRoZXkncmUgbm8gbG9uZ2VyIHJlbGV2YW50IChlLmcuIHJlbGF0ZWQgdG8gYSBjYW5jZWxsZWQgcmVxdWVzdCkuXG4gKlxuICogSG93ZXZlciwgYmUgdmVyeSBjYXJlZnVsIHRoYXQgeW91IGhhdmUgaGFuZGxlZCB0aGUgUHJvbWlzZSBpZiB5b3UgZG8gdGhpcy4gU3VwcHJlc3NpbmcgdGhlc2VcbiAqIGVycm9ycyBpcyBkYW5nZXJvdXMsIHRoZXkgZXhpc3QgZm9yIGdvb2QgcmVhc29uLiBBbiB1bmhhbmRsZWQgcmVqZWN0aW9uIGNhbiBoaWRlIGVycm9ycywgbWFraW5nXG4gKiBkZWJ1Z2dpbmcgZXh0cmVtZWx5IGRpZmZpY3VsdC4gVGhleSBzaG91bGQgb25seSBiZSBzdXBwcmVzc2VkIGlmIHlvdSdyZSBjb25maWRlbnQgdGhhdCB0aGVcbiAqIFByb21pc2UgaXMgYWx3YXlzIGhhbmRsZWQgY29ycmVjdGx5LCBpbiBib3RoIHRoZSBzdWNjZXNzIGFuZCBmYWlsdXJlIGNhc2VzLlxuICpcbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSBhcmdzLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9uIC0gVGhpcyBvcHRpb24gYWRkcyBhbiBlbXB0eSBlcnJvciBoYW5kbGVyXG4gKiB0byB0aGUgUHJvbWlzZSB0byBzdXBwcmVzcyB0aGUgVW5oYW5kbGVkUHJvbWlzZVJlamVjdGlvbiBlcnJvci4gVGhpcyBjYW4gYmVcbiAqIHVzZWZ1bCBpZiB0aGUgZGVmZXJyZWQgUHJvbWlzZSBpcyBzb21ldGltZXMgaW50ZW50aW9uYWxseSBub3QgdXNlZC5cbiAqIEByZXR1cm5zIEEgZGVmZXJyZWQgUHJvbWlzZS5cbiAqIEB0ZW1wbGF0ZSBSZXN1bHQgLSBUaGUgcmVzdWx0IHR5cGUgb2YgdGhlIFByb21pc2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkUHJvbWlzZSh7IHN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9uID0gZmFsc2UsIH0gPSB7fSkge1xuICAgIGxldCByZXNvbHZlO1xuICAgIGxldCByZWplY3Q7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChpbm5lclJlc29sdmUsIGlubmVyUmVqZWN0KSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSBpbm5lclJlc29sdmU7XG4gICAgICAgIHJlamVjdCA9IGlubmVyUmVqZWN0O1xuICAgIH0pO1xuICAgIGlmIChzdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbikge1xuICAgICAgICBwcm9taXNlLmNhdGNoKChfZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIFRoaXMgaGFuZGxlciBpcyB1c2VkIHRvIHN1cHByZXNzIHRoZSBVbmhhbmRsZWRQcm9taXNlUmVqZWN0aW9uIGVycm9yXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGtub3cgdGhhdCB0aGVzZSBhcmUgYXNzaWduZWQsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3RcbiAgICByZXR1cm4geyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfTtcbn1cbmV4cG9ydHMuY3JlYXRlRGVmZXJyZWRQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvbWlzZS5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/promise.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/time.cjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/time.cjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.timeSince = exports.inMilliseconds = exports.Duration = void 0;\n/**\n * Common duration constants, in milliseconds.\n */\nvar Duration;\n(function (Duration) {\n    /**\n     * A millisecond.\n     */\n    Duration[Duration[\"Millisecond\"] = 1] = \"Millisecond\";\n    /**\n     * A second, in milliseconds.\n     */\n    Duration[Duration[\"Second\"] = 1000] = \"Second\";\n    /**\n     * A minute, in milliseconds.\n     */\n    Duration[Duration[\"Minute\"] = 60000] = \"Minute\";\n    /**\n     * An hour, in milliseconds.\n     */\n    Duration[Duration[\"Hour\"] = 3600000] = \"Hour\";\n    /**\n     * A day, in milliseconds.\n     */\n    Duration[Duration[\"Day\"] = 86400000] = \"Day\";\n    /**\n     * A week, in milliseconds.\n     */\n    Duration[Duration[\"Week\"] = 604800000] = \"Week\";\n    /**\n     * A year, in milliseconds.\n     */\n    Duration[Duration[\"Year\"] = 31536000000] = \"Year\";\n})(Duration = exports.Duration || (exports.Duration = {}));\nconst isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;\nconst assertIsNonNegativeInteger = (number, name) => {\n    if (!isNonNegativeInteger(number)) {\n        throw new Error(`\"${name}\" must be a non-negative integer. Received: \"${number}\".`);\n    }\n};\n/**\n * Calculates the millisecond value of the specified number of units of time.\n *\n * @param count - The number of units of time.\n * @param duration - The unit of time to count.\n * @returns The count multiplied by the specified duration.\n */\nfunction inMilliseconds(count, duration) {\n    assertIsNonNegativeInteger(count, 'count');\n    return count * duration;\n}\nexports.inMilliseconds = inMilliseconds;\n/**\n * Gets the milliseconds since a particular Unix epoch timestamp.\n *\n * @param timestamp - A Unix millisecond timestamp.\n * @returns The number of milliseconds elapsed since the specified timestamp.\n */\nfunction timeSince(timestamp) {\n    assertIsNonNegativeInteger(timestamp, 'timestamp');\n    return Date.now() - timestamp;\n}\nexports.timeSince = timeSince;\n//# sourceMappingURL=time.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvdGltZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsc0JBQXNCLEdBQUcsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDLGdCQUFnQixLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLLCtDQUErQyxPQUFPO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RpbWUuY2pzP2M4ODYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRpbWVTaW5jZSA9IGV4cG9ydHMuaW5NaWxsaXNlY29uZHMgPSBleHBvcnRzLkR1cmF0aW9uID0gdm9pZCAwO1xuLyoqXG4gKiBDb21tb24gZHVyYXRpb24gY29uc3RhbnRzLCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbnZhciBEdXJhdGlvbjtcbihmdW5jdGlvbiAoRHVyYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBBIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiTWlsbGlzZWNvbmRcIl0gPSAxXSA9IFwiTWlsbGlzZWNvbmRcIjtcbiAgICAvKipcbiAgICAgKiBBIHNlY29uZCwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiU2Vjb25kXCJdID0gMTAwMF0gPSBcIlNlY29uZFwiO1xuICAgIC8qKlxuICAgICAqIEEgbWludXRlLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJNaW51dGVcIl0gPSA2MDAwMF0gPSBcIk1pbnV0ZVwiO1xuICAgIC8qKlxuICAgICAqIEFuIGhvdXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIkhvdXJcIl0gPSAzNjAwMDAwXSA9IFwiSG91clwiO1xuICAgIC8qKlxuICAgICAqIEEgZGF5LCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJEYXlcIl0gPSA4NjQwMDAwMF0gPSBcIkRheVwiO1xuICAgIC8qKlxuICAgICAqIEEgd2VlaywgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiV2Vla1wiXSA9IDYwNDgwMDAwMF0gPSBcIldlZWtcIjtcbiAgICAvKipcbiAgICAgKiBBIHllYXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIlllYXJcIl0gPSAzMTUzNjAwMDAwMF0gPSBcIlllYXJcIjtcbn0pKER1cmF0aW9uID0gZXhwb3J0cy5EdXJhdGlvbiB8fCAoZXhwb3J0cy5EdXJhdGlvbiA9IHt9KSk7XG5jb25zdCBpc05vbk5lZ2F0aXZlSW50ZWdlciA9IChudW1iZXIpID0+IE51bWJlci5pc0ludGVnZXIobnVtYmVyKSAmJiBudW1iZXIgPj0gMDtcbmNvbnN0IGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyID0gKG51bWJlciwgbmFtZSkgPT4ge1xuICAgIGlmICghaXNOb25OZWdhdGl2ZUludGVnZXIobnVtYmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlci4gUmVjZWl2ZWQ6IFwiJHtudW1iZXJ9XCIuYCk7XG4gICAgfVxufTtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbWlsbGlzZWNvbmQgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdW5pdHMgb2YgdGltZS5cbiAqXG4gKiBAcGFyYW0gY291bnQgLSBUaGUgbnVtYmVyIG9mIHVuaXRzIG9mIHRpbWUuXG4gKiBAcGFyYW0gZHVyYXRpb24gLSBUaGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICogQHJldHVybnMgVGhlIGNvdW50IG11bHRpcGxpZWQgYnkgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5NaWxsaXNlY29uZHMoY291bnQsIGR1cmF0aW9uKSB7XG4gICAgYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIoY291bnQsICdjb3VudCcpO1xuICAgIHJldHVybiBjb3VudCAqIGR1cmF0aW9uO1xufVxuZXhwb3J0cy5pbk1pbGxpc2Vjb25kcyA9IGluTWlsbGlzZWNvbmRzO1xuLyoqXG4gKiBHZXRzIHRoZSBtaWxsaXNlY29uZHMgc2luY2UgYSBwYXJ0aWN1bGFyIFVuaXggZXBvY2ggdGltZXN0YW1wLlxuICpcbiAqIEBwYXJhbSB0aW1lc3RhbXAgLSBBIFVuaXggbWlsbGlzZWNvbmQgdGltZXN0YW1wLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAqL1xuZnVuY3Rpb24gdGltZVNpbmNlKHRpbWVzdGFtcCkge1xuICAgIGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyKHRpbWVzdGFtcCwgJ3RpbWVzdGFtcCcpO1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xufVxuZXhwb3J0cy50aW1lU2luY2UgPSB0aW1lU2luY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lLmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/time.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/transaction-types.cjs":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/transaction-types.cjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=transaction-types.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvdHJhbnNhY3Rpb24tdHlwZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RyYW5zYWN0aW9uLXR5cGVzLmNqcz85MWMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb24tdHlwZXMuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/transaction-types.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/versions.cjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/versions.cjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nconst semver_1 = __webpack_require__(/*! semver */ \"(ssr)/./node_modules/semver/index.js\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/assert.cjs\");\n/**\n * A struct for validating a version string.\n */\nexports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version', (value) => {\n    if ((0, semver_1.valid)(value) === null) {\n        return `Expected SemVer version, got \"${value}\"`;\n    }\n    return true;\n});\nexports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version range', (value) => {\n    if ((0, semver_1.validRange)(value) === null) {\n        return `Expected SemVer range, got \"${value}\"`;\n    }\n    return true;\n});\n/**\n * Checks whether a SemVer version is valid.\n *\n * @param version - A potential version.\n * @returns `true` if the version is valid, and `false` otherwise.\n */\nfunction isValidSemVerVersion(version) {\n    return (0, superstruct_1.is)(version, exports.VersionStruct);\n}\nexports.isValidSemVerVersion = isValidSemVerVersion;\n/**\n * Checks whether a SemVer version range is valid.\n *\n * @param versionRange - A potential version range.\n * @returns `true` if the version range is valid, and `false` otherwise.\n */\nfunction isValidSemVerRange(versionRange) {\n    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);\n}\nexports.isValidSemVerRange = isValidSemVerRange;\n/**\n * Asserts that a value is a valid concrete SemVer version.\n *\n * @param version - A potential SemVer concrete version.\n */\nfunction assertIsSemVerVersion(version) {\n    (0, assert_1.assertStruct)(version, exports.VersionStruct);\n}\nexports.assertIsSemVerVersion = assertIsSemVerVersion;\n/**\n * Asserts that a value is a valid SemVer range.\n *\n * @param range - A potential SemVer range.\n */\nfunction assertIsSemVerRange(range) {\n    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);\n}\nexports.assertIsSemVerRange = assertIsSemVerRange;\n/**\n * Checks whether a SemVer version is greater than another.\n *\n * @param version1 - The left-hand version.\n * @param version2 - The right-hand version.\n * @returns `version1 > version2`.\n */\nfunction gtVersion(version1, version2) {\n    return (0, semver_1.gt)(version1, version2);\n}\nexports.gtVersion = gtVersion;\n/**\n * Checks whether a SemVer version is greater than all possibilities in a range.\n *\n * @param version - A SemvVer version.\n * @param range - The range to check against.\n * @returns `version > range`.\n */\nfunction gtRange(version, range) {\n    return (0, semver_1.gtr)(version, range);\n}\nexports.gtRange = gtRange;\n/**\n * Returns whether a SemVer version satisfies a SemVer range.\n *\n * @param version - The SemVer version to check.\n * @param versionRange - The SemVer version range to check against.\n * @returns Whether the version satisfied the version range.\n */\nfunction satisfiesVersionRange(version, versionRange) {\n    return (0, semver_1.satisfies)(version, versionRange, {\n        includePrerelease: true,\n    });\n}\nexports.satisfiesVersionRange = satisfiesVersionRange;\n//# sourceMappingURL=versions.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvdmVyc2lvbnMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLGVBQWUsR0FBRyxpQkFBaUIsR0FBRywyQkFBMkIsR0FBRyw2QkFBNkIsR0FBRywwQkFBMEIsR0FBRyw0QkFBNEIsR0FBRywwQkFBMEIsR0FBRyxxQkFBcUI7QUFDbFAsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQXVCO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLG9EQUFRO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLDJHQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMEJBQTBCO0FBQzFCO0FBQ0EsOENBQThDLE1BQU07QUFDcEQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC92ZXJzaW9ucy5janM/ZjVmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2F0aXNmaWVzVmVyc2lvblJhbmdlID0gZXhwb3J0cy5ndFJhbmdlID0gZXhwb3J0cy5ndFZlcnNpb24gPSBleHBvcnRzLmFzc2VydElzU2VtVmVyUmFuZ2UgPSBleHBvcnRzLmFzc2VydElzU2VtVmVyVmVyc2lvbiA9IGV4cG9ydHMuaXNWYWxpZFNlbVZlclJhbmdlID0gZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IGV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gZXhwb3J0cy5WZXJzaW9uU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBzZW12ZXJfMSA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydC5janNcIik7XG4vKipcbiAqIEEgc3RydWN0IGZvciB2YWxpZGF0aW5nIGEgdmVyc2lvbiBzdHJpbmcuXG4gKi9cbmV4cG9ydHMuVmVyc2lvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnJlZmluZSkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAnVmVyc2lvbicsICh2YWx1ZSkgPT4ge1xuICAgIGlmICgoMCwgc2VtdmVyXzEudmFsaWQpKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIFNlbVZlciB2ZXJzaW9uLCBnb3QgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbmV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucmVmaW5lKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksICdWZXJzaW9uIHJhbmdlJywgKHZhbHVlKSA9PiB7XG4gICAgaWYgKCgwLCBzZW12ZXJfMS52YWxpZFJhbmdlKSh2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBTZW1WZXIgcmFuZ2UsIGdvdCBcIiR7dmFsdWV9XCJgO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQSBwb3RlbnRpYWwgdmVyc2lvbi5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVyc2lvbiBpcyB2YWxpZCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU2VtVmVyVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2ZXJzaW9uLCBleHBvcnRzLlZlcnNpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IGlzVmFsaWRTZW1WZXJWZXJzaW9uO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIHJhbmdlIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uUmFuZ2UgLSBBIHBvdGVudGlhbCB2ZXJzaW9uIHJhbmdlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZXJzaW9uIHJhbmdlIGlzIHZhbGlkLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTZW1WZXJSYW5nZSh2ZXJzaW9uUmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZlcnNpb25SYW5nZSwgZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkU2VtVmVyUmFuZ2UgPSBpc1ZhbGlkU2VtVmVyUmFuZ2U7XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgY29uY3JldGUgU2VtVmVyIHZlcnNpb24uXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIHBvdGVudGlhbCBTZW1WZXIgY29uY3JldGUgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTZW1WZXJWZXJzaW9uKHZlcnNpb24pIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2ZXJzaW9uLCBleHBvcnRzLlZlcnNpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1NlbVZlclZlcnNpb24gPSBhc3NlcnRJc1NlbVZlclZlcnNpb247XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgU2VtVmVyIHJhbmdlLlxuICpcbiAqIEBwYXJhbSByYW5nZSAtIEEgcG90ZW50aWFsIFNlbVZlciByYW5nZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTZW1WZXJSYW5nZShyYW5nZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHJhbmdlLCBleHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCk7XG59XG5leHBvcnRzLmFzc2VydElzU2VtVmVyUmFuZ2UgPSBhc3NlcnRJc1NlbVZlclJhbmdlO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uMSAtIFRoZSBsZWZ0LWhhbmQgdmVyc2lvbi5cbiAqIEBwYXJhbSB2ZXJzaW9uMiAtIFRoZSByaWdodC1oYW5kIHZlcnNpb24uXG4gKiBAcmV0dXJucyBgdmVyc2lvbjEgPiB2ZXJzaW9uMmAuXG4gKi9cbmZ1bmN0aW9uIGd0VmVyc2lvbih2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLmd0KSh2ZXJzaW9uMSwgdmVyc2lvbjIpO1xufVxuZXhwb3J0cy5ndFZlcnNpb24gPSBndFZlcnNpb247XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCBwb3NzaWJpbGl0aWVzIGluIGEgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIFNlbXZWZXIgdmVyc2lvbi5cbiAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgYHZlcnNpb24gPiByYW5nZWAuXG4gKi9cbmZ1bmN0aW9uIGd0UmFuZ2UodmVyc2lvbiwgcmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLmd0cikodmVyc2lvbiwgcmFuZ2UpO1xufVxuZXhwb3J0cy5ndFJhbmdlID0gZ3RSYW5nZTtcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gc2F0aXNmaWVzIGEgU2VtVmVyIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIFNlbVZlciB2ZXJzaW9uIHRvIGNoZWNrLlxuICogQHBhcmFtIHZlcnNpb25SYW5nZSAtIFRoZSBTZW1WZXIgdmVyc2lvbiByYW5nZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmVyc2lvbiBzYXRpc2ZpZWQgdGhlIHZlcnNpb24gcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHNhdGlzZmllc1ZlcnNpb25SYW5nZSh2ZXJzaW9uLCB2ZXJzaW9uUmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLnNhdGlzZmllcykodmVyc2lvbiwgdmVyc2lvblJhbmdlLCB7XG4gICAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiB0cnVlLFxuICAgIH0pO1xufVxuZXhwb3J0cy5zYXRpc2ZpZXNWZXJzaW9uUmFuZ2UgPSBzYXRpc2ZpZXNWZXJzaW9uUmFuZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9ucy5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/versions.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/superstruct/dist/error.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/superstruct/dist/error.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StructError = void 0;\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const cause = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? cause);\n        if (explanation !== null && explanation !== undefined) {\n            this.cause = cause;\n        }\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\nexports.StructError = StructError;\n//# sourceMappingURL=error.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3QvZXJyb3IuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRCxnQkFBZ0IsT0FBTztBQUN2QixnRUFBZ0UsZ0JBQWdCLEtBQUssUUFBUTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zdXBlcnN0cnVjdC9kaXN0L2Vycm9yLmNqcz82YzM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBBIGBTdHJ1Y3RGYWlsdXJlYCByZXByZXNlbnRzIGEgc2luZ2xlIHNwZWNpZmljIGZhaWx1cmUgaW4gdmFsaWRhdGlvbi5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJ1Y3RFcnJvciA9IHZvaWQgMDtcbi8qKlxuICogYFN0cnVjdEVycm9yYCBvYmplY3RzIGFyZSB0aHJvd24gKG9yIHJldHVybmVkKSB3aGVuIHZhbGlkYXRpb24gZmFpbHMuXG4gKlxuICogVmFsaWRhdGlvbiBsb2dpYyBpcyBkZXNpZ24gdG8gZXhpdCBlYXJseSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS4gVGhlIGVycm9yXG4gKiByZXByZXNlbnRzIHRoZSBmaXJzdCBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgdmFsaWRhdGlvbi4gRm9yIG1vcmUgZGV0YWlsLFxuICogdGhlIGBlcnJvci5mYWlsdXJlc2AgcHJvcGVydHkgaXMgYSBnZW5lcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgcnVuIHRvXG4gKiBjb250aW51ZSB2YWxpZGF0aW9uIGFuZCByZWNlaXZlIGFsbCB0aGUgZmFpbHVyZXMgaW4gdGhlIGRhdGEuXG4gKi9cbmNsYXNzIFN0cnVjdEVycm9yIGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihmYWlsdXJlLCBmYWlsdXJlcykge1xuICAgICAgICBsZXQgY2FjaGVkO1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UsIGV4cGxhbmF0aW9uLCAuLi5yZXN0IH0gPSBmYWlsdXJlO1xuICAgICAgICBjb25zdCB7IHBhdGggfSA9IGZhaWx1cmU7XG4gICAgICAgIGNvbnN0IGNhdXNlID0gcGF0aC5sZW5ndGggPT09IDAgPyBtZXNzYWdlIDogYEF0IHBhdGg6ICR7cGF0aC5qb2luKCcuJyl9IC0tICR7bWVzc2FnZX1gO1xuICAgICAgICBzdXBlcihleHBsYW5hdGlvbiA/PyBjYXVzZSk7XG4gICAgICAgIGlmIChleHBsYW5hdGlvbiAhPT0gbnVsbCAmJiBleHBsYW5hdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCByZXN0KTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB0aGlzLmZhaWx1cmVzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChjYWNoZWQgPz8gKGNhY2hlZCA9IFtmYWlsdXJlLCAuLi5mYWlsdXJlcygpXSkpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuU3RydWN0RXJyb3IgPSBTdHJ1Y3RFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/superstruct/dist/error.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/superstruct/dist/index.cjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./error.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/error.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./struct.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/struct.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./structs/coercions.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/structs/coercions.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./structs/refinements.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/structs/refinements.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./structs/types.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/structs/types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./structs/utilities.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/structs/utilities.cjs\"), exports);\n//# sourceMappingURL=index.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyw4RUFBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsZ0ZBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLHNHQUF5QjtBQUM5QyxhQUFhLG1CQUFPLENBQUMsMEdBQTJCO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQyw4RkFBcUI7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLHNHQUF5QjtBQUM5QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9pbmRleC5janM/ZDJlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Vycm9yLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3RydWN0LmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3RydWN0cy9jb2VyY2lvbnMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdHJ1Y3RzL3JlZmluZW1lbnRzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3RydWN0cy90eXBlcy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N0cnVjdHMvdXRpbGl0aWVzLmNqc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/superstruct/dist/struct.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@metamask/superstruct/dist/struct.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validate = exports.is = exports.mask = exports.create = exports.assert = exports.Struct = void 0;\nconst error_js_1 = __webpack_require__(/*! ./error.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/error.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/utils.cjs\");\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () {\n            /* noop */\n        }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return (0, utils_js_1.toFailures)(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return (0, utils_js_1.toFailures)(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\nexports.Struct = Struct;\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param message - An optional message to include in the error.\n */\nfunction assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\nexports.assert = assert;\n/**\n * Create a value with the coercion logic of struct and validate it.\n *\n * @param value - The value to coerce and validate.\n * @param struct - The struct to validate against.\n * @param message - An optional message to include in the error.\n * @returns The coerced and validated value.\n */\nfunction create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\nexports.create = create;\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n *\n * @param value - The value to mask.\n * @param struct - The struct to mask against.\n * @param message - An optional message to include in the error.\n * @returns The masked value.\n */\nfunction mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\nexports.mask = mask;\n/**\n * Check if a value passes a struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @returns `true` if the value passes the struct, `false` otherwise.\n */\nfunction is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\nexports.is = is;\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param options - Optional settings.\n * @param options.coerce - Whether to coerce the value before validating it.\n * @param options.mask - Whether to mask the value before validating it.\n * @param options.message - An optional message to include in the error.\n * @returns A tuple containing the error (if invalid) and the validated value.\n */\nfunction validate(value, struct, options = {}) {\n    const tuples = (0, utils_js_1.run)(value, struct, options);\n    const tuple = (0, utils_js_1.shiftIterator)(tuples);\n    if (tuple[0]) {\n        const error = new error_js_1.StructError(tuple[0], function* () {\n            for (const innerTuple of tuples) {\n                if (innerTuple[0]) {\n                    yield innerTuple[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    const validatedValue = tuple[1];\n    return [undefined, validatedValue];\n}\nexports.validate = validate;\n//# sourceMappingURL=struct.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3Qvc3RydWN0LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxVQUFVLEdBQUcsWUFBWSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYztBQUMvRixtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBYTtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUJBQXVCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtQ0FBbUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3Qvc3RydWN0LmNqcz9mNDljIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZSA9IGV4cG9ydHMuaXMgPSBleHBvcnRzLm1hc2sgPSBleHBvcnRzLmNyZWF0ZSA9IGV4cG9ydHMuYXNzZXJ0ID0gZXhwb3J0cy5TdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBlcnJvcl9qc18xID0gcmVxdWlyZShcIi4vZXJyb3IuY2pzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmNqc1wiKTtcbi8qKlxuICogYFN0cnVjdGAgb2JqZWN0cyBlbmNhcHN1bGF0ZSB0aGUgdmFsaWRhdGlvbiBsb2dpYyBmb3IgYSBzcGVjaWZpYyB0eXBlIG9mXG4gKiB2YWx1ZXMuIE9uY2UgY29uc3RydWN0ZWQsIHlvdSB1c2UgdGhlIGBhc3NlcnRgLCBgaXNgIG9yIGB2YWxpZGF0ZWAgaGVscGVycyB0b1xuICogdmFsaWRhdGUgdW5rbm93biBpbnB1dCBkYXRhIGFnYWluc3QgdGhlIHN0cnVjdC5cbiAqL1xuY2xhc3MgU3RydWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBjb25zdCB7IHR5cGUsIHNjaGVtYSwgdmFsaWRhdG9yLCByZWZpbmVyLCBjb2VyY2VyID0gKHZhbHVlKSA9PiB2YWx1ZSwgZW50cmllcyA9IGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvKiBub29wICovXG4gICAgICAgIH0sIH0gPSBwcm9wcztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgICAgIHRoaXMuY29lcmNlciA9IGNvZXJjZXI7XG4gICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEudG9GYWlsdXJlcykocmVzdWx0LCBjb250ZXh0LCB0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0b3IgPSAoKSA9PiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmaW5lcikge1xuICAgICAgICAgICAgdGhpcy5yZWZpbmVyID0gKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLnRvRmFpbHVyZXMpKHJlc3VsdCwgY29udGV4dCwgdGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVmaW5lciA9ICgpID0+IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2VydCB0aGF0IGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLCB0aHJvd2luZyBpZiBpdCBkb2Vzbid0LlxuICAgICAqL1xuICAgIGFzc2VydCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gYXNzZXJ0KHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgc3RydWN0J3MgY29lcmNpb24gbG9naWMsIHRoZW4gdmFsaWRhdGUgaXQuXG4gICAgICovXG4gICAgY3JlYXRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGUodmFsdWUsIHRoaXMsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXModmFsdWUsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXNrIGEgdmFsdWUsIGNvZXJjaW5nIGFuZCB2YWxpZGF0aW5nIGl0LCBidXQgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZlxuICAgICAqIHByb3BlcnRpZXMgZGVmaW5lZCBieSB0aGUgc3RydWN0J3Mgc2NoZW1hLlxuICAgICAqL1xuICAgIG1hc2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1hc2sodmFsdWUsIHRoaXMsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24gbG9naWMsIHJldHVybmluZyBhIHR1cGxlXG4gICAgICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gICAgICpcbiAgICAgKiBZb3UgbWF5IG9wdGlvbmFsbHkgcGFzcyBgdHJ1ZWAgZm9yIHRoZSBgd2l0aENvZXJjaW9uYCBhcmd1bWVudCB0byBjb2VyY2VcbiAgICAgKiB0aGUgdmFsdWUgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdmFsaWRhdGUgaXQuIElmIHlvdSBkbywgdGhlIHJlc3VsdCB3aWxsXG4gICAgICogY29udGFpbiB0aGUgY29lcmNlZCByZXN1bHQgd2hlbiBzdWNjZXNzZnVsLlxuICAgICAqL1xuICAgIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHZhbHVlLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLlN0cnVjdCA9IFN0cnVjdDtcbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QsIHRocm93aW5nIGlmIGl0IGRvZXNuJ3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gdmFsaWRhdGUgYWdhaW5zdC5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gQW4gb3B0aW9uYWwgbWVzc2FnZSB0byBpbmNsdWRlIGluIHRoZSBlcnJvci5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IG1lc3NhZ2UgfSk7XG4gICAgaWYgKHJlc3VsdFswXSkge1xuICAgICAgICB0aHJvdyByZXN1bHRbMF07XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG4vKipcbiAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIGNvZXJjaW9uIGxvZ2ljIG9mIHN0cnVjdCBhbmQgdmFsaWRhdGUgaXQuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvZXJjZSBhbmQgdmFsaWRhdGUuXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBhZ2FpbnN0LlxuICogQHBhcmFtIG1lc3NhZ2UgLSBBbiBvcHRpb25hbCBtZXNzYWdlIHRvIGluY2x1ZGUgaW4gdGhlIGVycm9yLlxuICogQHJldHVybnMgVGhlIGNvZXJjZWQgYW5kIHZhbGlkYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlKHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IGNvZXJjZTogdHJ1ZSwgbWVzc2FnZSB9KTtcbiAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgIHRocm93IHJlc3VsdFswXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbMV07XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG4vKipcbiAqIE1hc2sgYSB2YWx1ZSwgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgYSBzdHJ1Y3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIG1hc2suXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBtYXNrIGFnYWluc3QuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIEFuIG9wdGlvbmFsIG1lc3NhZ2UgdG8gaW5jbHVkZSBpbiB0aGUgZXJyb3IuXG4gKiBAcmV0dXJucyBUaGUgbWFza2VkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXNrKHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IGNvZXJjZTogdHJ1ZSwgbWFzazogdHJ1ZSwgbWVzc2FnZSB9KTtcbiAgICBpZiAocmVzdWx0WzBdKSB7XG4gICAgICAgIHRocm93IHJlc3VsdFswXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbMV07XG4gICAgfVxufVxuZXhwb3J0cy5tYXNrID0gbWFzaztcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gdmFsaWRhdGUgYWdhaW5zdC5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpcyh2YWx1ZSwgc3RydWN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCk7XG4gICAgcmV0dXJuICFyZXN1bHRbMF07XG59XG5leHBvcnRzLmlzID0gaXM7XG4vKipcbiAqIFZhbGlkYXRlIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgcmV0dXJuaW5nIGFuIGVycm9yIGlmIGludmFsaWQsIG9yIHRoZVxuICogdmFsdWUgKHdpdGggcG90ZW50aWFsIGNvZXJjaW9uKSBpZiB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBhZ2FpbnN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBzZXR0aW5ncy5cbiAqIEBwYXJhbSBvcHRpb25zLmNvZXJjZSAtIFdoZXRoZXIgdG8gY29lcmNlIHRoZSB2YWx1ZSBiZWZvcmUgdmFsaWRhdGluZyBpdC5cbiAqIEBwYXJhbSBvcHRpb25zLm1hc2sgLSBXaGV0aGVyIHRvIG1hc2sgdGhlIHZhbHVlIGJlZm9yZSB2YWxpZGF0aW5nIGl0LlxuICogQHBhcmFtIG9wdGlvbnMubWVzc2FnZSAtIEFuIG9wdGlvbmFsIG1lc3NhZ2UgdG8gaW5jbHVkZSBpbiB0aGUgZXJyb3IuXG4gKiBAcmV0dXJucyBBIHR1cGxlIGNvbnRhaW5pbmcgdGhlIGVycm9yIChpZiBpbnZhbGlkKSBhbmQgdGhlIHZhbGlkYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdHVwbGVzID0gKDAsIHV0aWxzX2pzXzEucnVuKSh2YWx1ZSwgc3RydWN0LCBvcHRpb25zKTtcbiAgICBjb25zdCB0dXBsZSA9ICgwLCB1dGlsc19qc18xLnNoaWZ0SXRlcmF0b3IpKHR1cGxlcyk7XG4gICAgaWYgKHR1cGxlWzBdKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IGVycm9yX2pzXzEuU3RydWN0RXJyb3IodHVwbGVbMF0sIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlubmVyVHVwbGUgb2YgdHVwbGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyVHVwbGVbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgaW5uZXJUdXBsZVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW2Vycm9yLCB1bmRlZmluZWRdO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0ZWRWYWx1ZSA9IHR1cGxlWzFdO1xuICAgIHJldHVybiBbdW5kZWZpbmVkLCB2YWxpZGF0ZWRWYWx1ZV07XG59XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJ1Y3QuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/superstruct/dist/struct.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/superstruct/dist/structs/coercions.cjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@metamask/superstruct/dist/structs/coercions.cjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.trimmed = exports.defaulted = exports.coerce = void 0;\nconst struct_js_1 = __webpack_require__(/*! ../struct.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/struct.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../utils.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/utils.cjs\");\nconst types_js_1 = __webpack_require__(/*! ./types.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/structs/types.cjs\");\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationfor example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @param condition - A struct that the input must pass to be coerced.\n * @param coercer - A function that takes the input and returns the coerced\n * value.\n * @returns A new struct that will coerce its input before validating it.\n */\nfunction coerce(struct, condition, coercer) {\n    return new struct_js_1.Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return (0, struct_js_1.is)(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\nexports.coerce = coerce;\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @param fallback - The value to use when the input is `undefined`.\n * @param options - An optional options object.\n * @param options.strict - When `true`, the fallback will only be used when the\n * input is `undefined`. When `false`, the fallback will be used when the input\n * is `undefined` or when the input is a plain object and the fallback is a\n * plain object, and any keys in the fallback are missing from the input.\n * @returns A new struct that will replace `undefined` inputs with a default.\n */\nfunction defaulted(struct, fallback, options = {}) {\n    return coerce(struct, (0, types_js_1.unknown)(), (value) => {\n        const result = typeof fallback === 'function' ? fallback() : fallback;\n        if (value === undefined) {\n            return result;\n        }\n        if (!options.strict && (0, utils_js_1.isPlainObject)(value) && (0, utils_js_1.isPlainObject)(result)) {\n            const ret = { ...value };\n            let changed = false;\n            for (const key in result) {\n                if (ret[key] === undefined) {\n                    ret[key] = result[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return value;\n    });\n}\nexports.defaulted = defaulted;\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will trim string inputs before validating them.\n */\nfunction trimmed(struct) {\n    return coerce(struct, (0, types_js_1.string)(), (value) => value.trim());\n}\nexports.trimmed = trimmed;\n//# sourceMappingURL=coercions.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3Qvc3RydWN0cy9jb2VyY2lvbnMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxpQkFBaUIsR0FBRyxjQUFjO0FBQ3BELG9CQUFvQixtQkFBTyxDQUFDLGlGQUFlO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLCtFQUFjO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLHNGQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9zdHJ1Y3RzL2NvZXJjaW9ucy5janM/NDEyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHJpbW1lZCA9IGV4cG9ydHMuZGVmYXVsdGVkID0gZXhwb3J0cy5jb2VyY2UgPSB2b2lkIDA7XG5jb25zdCBzdHJ1Y3RfanNfMSA9IHJlcXVpcmUoXCIuLi9zdHJ1Y3QuY2pzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy5janNcIik7XG5jb25zdCB0eXBlc19qc18xID0gcmVxdWlyZShcIi4vdHlwZXMuY2pzXCIpO1xuLyoqXG4gKiBBdWdtZW50IGEgYFN0cnVjdGAgdG8gYWRkIGFuIGFkZGl0aW9uYWwgY29lcmNpb24gc3RlcCB0byBpdHMgaW5wdXQuXG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyYW5zZm9ybSBpbnB1dCBkYXRhIGJlZm9yZSB2YWxpZGF0aW5nIGl0LCB0byBpbmNyZWFzZSB0aGVcbiAqIGxpa2VsaWhvb2QgdGhhdCBpdCBwYXNzZXMgdmFsaWRhdGlvbuKAlGZvciBleGFtcGxlIGZvciBkZWZhdWx0IHZhbHVlcywgcGFyc2luZ1xuICogZGlmZmVyZW50IGZvcm1hdHMsIGV0Yy5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHBhcmFtIGNvbmRpdGlvbiAtIEEgc3RydWN0IHRoYXQgdGhlIGlucHV0IG11c3QgcGFzcyB0byBiZSBjb2VyY2VkLlxuICogQHBhcmFtIGNvZXJjZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIGlucHV0IGFuZCByZXR1cm5zIHRoZSBjb2VyY2VkXG4gKiB2YWx1ZS5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgY29lcmNlIGl0cyBpbnB1dCBiZWZvcmUgdmFsaWRhdGluZyBpdC5cbiAqL1xuZnVuY3Rpb24gY29lcmNlKHN0cnVjdCwgY29uZGl0aW9uLCBjb2VyY2VyKSB7XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5TdHJ1Y3Qoe1xuICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgIGNvZXJjZXI6ICh2YWx1ZSwgY3R4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHN0cnVjdF9qc18xLmlzKSh2YWx1ZSwgY29uZGl0aW9uKVxuICAgICAgICAgICAgICAgID8gc3RydWN0LmNvZXJjZXIoY29lcmNlcih2YWx1ZSwgY3R4KSwgY3R4KVxuICAgICAgICAgICAgICAgIDogc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byByZXBsYWNlIGB1bmRlZmluZWRgIHZhbHVlcyB3aXRoIGEgZGVmYXVsdC5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHBhcmFtIGZhbGxiYWNrIC0gVGhlIHZhbHVlIHRvIHVzZSB3aGVuIHRoZSBpbnB1dCBpcyBgdW5kZWZpbmVkYC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0gb3B0aW9ucy5zdHJpY3QgLSBXaGVuIGB0cnVlYCwgdGhlIGZhbGxiYWNrIHdpbGwgb25seSBiZSB1c2VkIHdoZW4gdGhlXG4gKiBpbnB1dCBpcyBgdW5kZWZpbmVkYC4gV2hlbiBgZmFsc2VgLCB0aGUgZmFsbGJhY2sgd2lsbCBiZSB1c2VkIHdoZW4gdGhlIGlucHV0XG4gKiBpcyBgdW5kZWZpbmVkYCBvciB3aGVuIHRoZSBpbnB1dCBpcyBhIHBsYWluIG9iamVjdCBhbmQgdGhlIGZhbGxiYWNrIGlzIGFcbiAqIHBsYWluIG9iamVjdCwgYW5kIGFueSBrZXlzIGluIHRoZSBmYWxsYmFjayBhcmUgbWlzc2luZyBmcm9tIHRoZSBpbnB1dC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgcmVwbGFjZSBgdW5kZWZpbmVkYCBpbnB1dHMgd2l0aCBhIGRlZmF1bHQuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRlZChzdHJ1Y3QsIGZhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gY29lcmNlKHN0cnVjdCwgKDAsIHR5cGVzX2pzXzEudW5rbm93bikoKSwgKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHR5cGVvZiBmYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGZhbGxiYWNrKCkgOiBmYWxsYmFjaztcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLnN0cmljdCAmJiAoMCwgdXRpbHNfanNfMS5pc1BsYWluT2JqZWN0KSh2YWx1ZSkgJiYgKDAsIHV0aWxzX2pzXzEuaXNQbGFpbk9iamVjdCkocmVzdWx0KSkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0geyAuLi52YWx1ZSB9O1xuICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gcmVzdWx0W2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHRlZCA9IGRlZmF1bHRlZDtcbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byB0cmltIHN0cmluZyBpbnB1dHMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gYXVnbWVudC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgdHJpbSBzdHJpbmcgaW5wdXRzIGJlZm9yZSB2YWxpZGF0aW5nIHRoZW0uXG4gKi9cbmZ1bmN0aW9uIHRyaW1tZWQoc3RydWN0KSB7XG4gICAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsICgwLCB0eXBlc19qc18xLnN0cmluZykoKSwgKHZhbHVlKSA9PiB2YWx1ZS50cmltKCkpO1xufVxuZXhwb3J0cy50cmltbWVkID0gdHJpbW1lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZXJjaW9ucy5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/superstruct/dist/structs/coercions.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/superstruct/dist/structs/refinements.cjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@metamask/superstruct/dist/structs/refinements.cjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.refine = exports.size = exports.pattern = exports.nonempty = exports.min = exports.max = exports.empty = void 0;\nconst struct_js_1 = __webpack_require__(/*! ../struct.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/struct.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../utils.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/utils.cjs\");\n/**\n * Ensure that a string, array, map, or set is empty.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will only accept empty values.\n */\nfunction empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\nexports.empty = empty;\n/**\n * Get the size of a string, array, map, or set.\n *\n * @param value - The value to measure.\n * @returns The size of the value.\n */\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    return value.length;\n}\n/**\n * Ensure that a number or date is below a threshold.\n *\n * @param struct - The struct to augment.\n * @param threshold - The maximum value that the input can be.\n * @param options - An optional options object.\n * @param options.exclusive - When `true`, the input must be strictly less than\n * the threshold. When `false`, the input must be less than or equal to the\n * threshold.\n * @returns A new struct that will only accept values below the threshold.\n */\nfunction max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                }${threshold} but received \\`${value}\\``;\n    });\n}\nexports.max = max;\n/**\n * Ensure that a number or date is above a threshold.\n *\n * @param struct - The struct to augment.\n * @param threshold - The minimum value that the input can be.\n * @param options - An optional options object.\n * @param options.exclusive - When `true`, the input must be strictly greater\n * than the threshold. When `false`, the input must be greater than or equal to\n * the threshold.\n * @returns A new struct that will only accept values above the threshold.\n */\nfunction min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                }${threshold} but received \\`${value}\\``;\n    });\n}\nexports.min = min;\n/**\n * Ensure that a string, array, map or set is not empty.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will only accept non-empty values.\n */\nfunction nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\nexports.nonempty = nonempty;\n/**\n * Ensure that a string matches a regular expression.\n *\n * @param struct - The struct to augment.\n * @param regexp - The regular expression to match against.\n * @returns A new struct that will only accept strings matching the regular\n * expression.\n */\nfunction pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\nexports.pattern = pattern;\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length,\n * or time) between `min` and `max`.\n *\n * @param struct - The struct to augment.\n * @param minimum - The minimum size that the input can be.\n * @param maximum - The maximum size that the input can be.\n * @returns A new struct that will only accept values within the given size\n * range.\n */\nfunction size(struct, minimum, maximum = minimum) {\n    const expected = `Expected a ${struct.type}`;\n    const of = minimum === maximum\n        ? `of \\`${minimum}\\``\n        : `between \\`${minimum}\\` and \\`${maximum}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((minimum <= value && value <= maximum) ||\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            // eslint-disable-next-line @typescript-eslint/no-shadow\n            const { size } = value;\n            return ((minimum <= size && size <= maximum) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        const { length } = value;\n        return ((minimum <= length && length <= maximum) ||\n            `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n    });\n}\nexports.size = size;\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n *\n * @param struct - The struct to augment.\n * @param name - The name of the refinement.\n * @param refiner - The refiner function.\n * @returns A new struct that will run the refiner function after the existing\n * validation.\n */\nfunction refine(struct, name, refiner) {\n    return new struct_js_1.Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = (0, utils_js_1.toFailures)(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\nexports.refine = refine;\n//# sourceMappingURL=refinements.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3Qvc3RydWN0cy9yZWZpbmVtZW50cy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLFlBQVksR0FBRyxlQUFlLEdBQUcsZ0JBQWdCLEdBQUcsV0FBVyxHQUFHLFdBQVcsR0FBRyxhQUFhO0FBQzlHLG9CQUFvQixtQkFBTyxDQUFDLGlGQUFlO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLCtFQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYSxvQ0FBb0MsS0FBSztBQUN2RixLQUFLO0FBQ0w7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYSxZQUFZO0FBQ3ZEO0FBQ0EsaUJBQWlCLEVBQUUsV0FBVyxpQkFBaUIsTUFBTTtBQUNyRCxLQUFLO0FBQ0w7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYSxlQUFlO0FBQzFEO0FBQ0EsaUJBQWlCLEVBQUUsV0FBVyxpQkFBaUIsTUFBTTtBQUNyRCxLQUFLO0FBQ0w7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYTtBQUNoRSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhLGNBQWMsY0FBYyxvQkFBb0IsTUFBTTtBQUM3RixLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsdUJBQXVCLFFBQVEsV0FBVyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVUsRUFBRSxJQUFJLGlCQUFpQixNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0EsbUJBQW1CLFVBQVUsY0FBYyxJQUFJLG9DQUFvQyxLQUFLO0FBQ3hGO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQSxlQUFlLFVBQVUsZ0JBQWdCLElBQUksc0NBQXNDLE9BQU87QUFDMUYsS0FBSztBQUNMO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3Qvc3RydWN0cy9yZWZpbmVtZW50cy5janM/ZmNmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVmaW5lID0gZXhwb3J0cy5zaXplID0gZXhwb3J0cy5wYXR0ZXJuID0gZXhwb3J0cy5ub25lbXB0eSA9IGV4cG9ydHMubWluID0gZXhwb3J0cy5tYXggPSBleHBvcnRzLmVtcHR5ID0gdm9pZCAwO1xuY29uc3Qgc3RydWN0X2pzXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0LmNqc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMuY2pzXCIpO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCwgb3Igc2V0IGlzIGVtcHR5LlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGF1Z21lbnQuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IGVtcHR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZW1wdHkoc3RydWN0KSB7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdlbXB0eScsICh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgICAgICBjb25zdCBzaXplID0gZ2V0U2l6ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiAoc2l6ZSA9PT0gMCB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGFuIGVtcHR5ICR7c3RydWN0LnR5cGV9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgXFxgJHtzaXplfVxcYGApO1xuICAgIH0pO1xufVxuZXhwb3J0cy5lbXB0eSA9IGVtcHR5O1xuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgYSBzdHJpbmcsIGFycmF5LCBtYXAsIG9yIHNldC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gbWVhc3VyZS5cbiAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0U2l6ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gdmFsdWUuc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBiZWxvdyBhIHRocmVzaG9sZC5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHBhcmFtIHRocmVzaG9sZCAtIFRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgdGhlIGlucHV0IGNhbiBiZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0gb3B0aW9ucy5leGNsdXNpdmUgLSBXaGVuIGB0cnVlYCwgdGhlIGlucHV0IG11c3QgYmUgc3RyaWN0bHkgbGVzcyB0aGFuXG4gKiB0aGUgdGhyZXNob2xkLiBXaGVuIGBmYWxzZWAsIHRoZSBpbnB1dCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGVcbiAqIHRocmVzaG9sZC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgdmFsdWVzIGJlbG93IHRoZSB0aHJlc2hvbGQuXG4gKi9cbmZ1bmN0aW9uIG1heChzdHJ1Y3QsIHRocmVzaG9sZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBleGNsdXNpdmUgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtYXgnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIGV4Y2x1c2l2ZVxuICAgICAgICAgICAgPyB2YWx1ZSA8IHRocmVzaG9sZFxuICAgICAgICAgICAgOiB2YWx1ZSA8PSB0aHJlc2hvbGQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfSBsZXNzIHRoYW4gJHtleGNsdXNpdmUgPyAnJyA6ICdvciBlcXVhbCB0byAnXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgIH0ke3RocmVzaG9sZH0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYDtcbiAgICB9KTtcbn1cbmV4cG9ydHMubWF4ID0gbWF4O1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIG51bWJlciBvciBkYXRlIGlzIGFib3ZlIGEgdGhyZXNob2xkLlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGF1Z21lbnQuXG4gKiBAcGFyYW0gdGhyZXNob2xkIC0gVGhlIG1pbmltdW0gdmFsdWUgdGhhdCB0aGUgaW5wdXQgY2FuIGJlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zLmV4Y2x1c2l2ZSAtIFdoZW4gYHRydWVgLCB0aGUgaW5wdXQgbXVzdCBiZSBzdHJpY3RseSBncmVhdGVyXG4gKiB0aGFuIHRoZSB0aHJlc2hvbGQuIFdoZW4gYGZhbHNlYCwgdGhlIGlucHV0IG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXG4gKiB0aGUgdGhyZXNob2xkLlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCB2YWx1ZXMgYWJvdmUgdGhlIHRocmVzaG9sZC5cbiAqL1xuZnVuY3Rpb24gbWluKHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGV4Y2x1c2l2ZSB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21pbicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gZXhjbHVzaXZlXG4gICAgICAgICAgICA/IHZhbHVlID4gdGhyZXNob2xkXG4gICAgICAgICAgICA6IHZhbHVlID49IHRocmVzaG9sZCB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IGdyZWF0ZXIgdGhhbiAke2V4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICdcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgfSR7dGhyZXNob2xkfSBidXQgcmVjZWl2ZWQgXFxgJHt2YWx1ZX1cXGBgO1xuICAgIH0pO1xufVxuZXhwb3J0cy5taW4gPSBtaW47XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbWFwIG9yIHNldCBpcyBub3QgZW1wdHkuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gYXVnbWVudC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgbm9uLWVtcHR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbm9uZW1wdHkoc3RydWN0KSB7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdub25lbXB0eScsICh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgICAgICBjb25zdCBzaXplID0gZ2V0U2l6ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiAoc2l6ZSA+IDAgfHwgYEV4cGVjdGVkIGEgbm9uZW1wdHkgJHtzdHJ1Y3QudHlwZX0gYnV0IHJlY2VpdmVkIGFuIGVtcHR5IG9uZWApO1xuICAgIH0pO1xufVxuZXhwb3J0cy5ub25lbXB0eSA9IG5vbmVtcHR5O1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZyBtYXRjaGVzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGF1Z21lbnQuXG4gKiBAcGFyYW0gcmVnZXhwIC0gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBhZ2FpbnN0LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCBzdHJpbmdzIG1hdGNoaW5nIHRoZSByZWd1bGFyXG4gKiBleHByZXNzaW9uLlxuICovXG5mdW5jdGlvbiBwYXR0ZXJuKHN0cnVjdCwgcmVnZXhwKSB7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdwYXR0ZXJuJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAocmVnZXhwLnRlc3QodmFsdWUpIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfSBtYXRjaGluZyBcXGAvJHtyZWdleHAuc291cmNlfS9cXGAgYnV0IHJlY2VpdmVkIFwiJHt2YWx1ZX1cImApO1xuICAgIH0pO1xufVxuZXhwb3J0cy5wYXR0ZXJuID0gcGF0dGVybjtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcsIGFycmF5LCBudW1iZXIsIGRhdGUsIG1hcCwgb3Igc2V0IGhhcyBhIHNpemUgKG9yIGxlbmd0aCxcbiAqIG9yIHRpbWUpIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGF1Z21lbnQuXG4gKiBAcGFyYW0gbWluaW11bSAtIFRoZSBtaW5pbXVtIHNpemUgdGhhdCB0aGUgaW5wdXQgY2FuIGJlLlxuICogQHBhcmFtIG1heGltdW0gLSBUaGUgbWF4aW11bSBzaXplIHRoYXQgdGhlIGlucHV0IGNhbiBiZS5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgdmFsdWVzIHdpdGhpbiB0aGUgZ2l2ZW4gc2l6ZVxuICogcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHNpemUoc3RydWN0LCBtaW5pbXVtLCBtYXhpbXVtID0gbWluaW11bSkge1xuICAgIGNvbnN0IGV4cGVjdGVkID0gYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX1gO1xuICAgIGNvbnN0IG9mID0gbWluaW11bSA9PT0gbWF4aW11bVxuICAgICAgICA/IGBvZiBcXGAke21pbmltdW19XFxgYFxuICAgICAgICA6IGBiZXR3ZWVuIFxcYCR7bWluaW11bX1cXGAgYW5kIFxcYCR7bWF4aW11bX1cXGBgO1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnc2l6ZScsICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKG1pbmltdW0gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4aW11bSkgfHxcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9ICR7b2Z9IGJ1dCByZWNlaXZlZCBcXGAke3ZhbHVlfVxcYGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgICAgICAgICAgY29uc3QgeyBzaXplIH0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAoKG1pbmltdW0gPD0gc2l6ZSAmJiBzaXplIDw9IG1heGltdW0pIHx8XG4gICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9IHdpdGggYSBzaXplICR7b2Z9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgXFxgJHtzaXplfVxcYGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuICgobWluaW11bSA8PSBsZW5ndGggJiYgbGVuZ3RoIDw9IG1heGltdW0pIHx8XG4gICAgICAgICAgICBgJHtleHBlY3RlZH0gd2l0aCBhIGxlbmd0aCAke29mfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBsZW5ndGggb2YgXFxgJHtsZW5ndGh9XFxgYCk7XG4gICAgfSk7XG59XG5leHBvcnRzLnNpemUgPSBzaXplO1xuLyoqXG4gKiBBdWdtZW50IGEgYFN0cnVjdGAgdG8gYWRkIGFuIGFkZGl0aW9uYWwgcmVmaW5lbWVudCB0byB0aGUgdmFsaWRhdGlvbi5cbiAqXG4gKiBUaGUgcmVmaW5lciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJlY2VpdmUgYSB2YWx1ZSBvZiB0aGUgc3RydWN0J3MgdHlwZSxcbiAqIGJlY2F1c2UgdGhlIHN0cnVjdCdzIGV4aXN0aW5nIHZhbGlkYXRpb24gd2lsbCBhbHJlYWR5IGhhdmUgcGFzc2VkLiBUaGlzXG4gKiBhbGxvd3MgeW91IHRvIGxheWVyIGFkZGl0aW9uYWwgdmFsaWRhdGlvbiBvbiB0b3Agb2YgZXhpc3Rpbmcgc3RydWN0cy5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcmVmaW5lbWVudC5cbiAqIEBwYXJhbSByZWZpbmVyIC0gVGhlIHJlZmluZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIHJ1biB0aGUgcmVmaW5lciBmdW5jdGlvbiBhZnRlciB0aGUgZXhpc3RpbmdcbiAqIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHJlZmluZShzdHJ1Y3QsIG5hbWUsIHJlZmluZXIpIHtcbiAgICByZXR1cm4gbmV3IHN0cnVjdF9qc18xLlN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgeWllbGQqIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gKDAsIHV0aWxzX2pzXzEudG9GYWlsdXJlcykocmVzdWx0LCBjdHgsIHN0cnVjdCwgdmFsdWUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIGZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeyAuLi5mYWlsdXJlLCByZWZpbmVtZW50OiBuYW1lIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLnJlZmluZSA9IHJlZmluZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZmluZW1lbnRzLmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/superstruct/dist/structs/refinements.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/superstruct/dist/structs/types.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@metamask/superstruct/dist/structs/types.cjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unknown = exports.union = exports.type = exports.tuple = exports.string = exports.set = exports.regexp = exports.record = exports.optional = exports.object = exports.number = exports.nullable = exports.never = exports.map = exports.literal = exports.intersection = exports.integer = exports.instance = exports.func = exports.enums = exports.date = exports.boolean = exports.bigint = exports.array = exports.any = void 0;\nconst struct_js_1 = __webpack_require__(/*! ../struct.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/struct.cjs\");\nconst utils_js_1 = __webpack_require__(/*! ../utils.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/utils.cjs\");\nconst utilities_js_1 = __webpack_require__(/*! ./utilities.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/structs/utilities.cjs\");\n/**\n * Ensure that any value passes validation.\n *\n * @returns A struct that will always pass validation.\n */\nfunction any() {\n    return (0, utilities_js_1.define)('any', () => true);\n}\nexports.any = any;\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n *\n * @param Element - The struct to validate each element in the array against.\n * @returns A new struct that will only accept arrays of the given type.\n */\nfunction array(Element) {\n    return new struct_js_1.Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [index, arrayValue] of value.entries()) {\n                    yield [index, arrayValue, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n    });\n}\nexports.array = array;\n/**\n * Ensure that a value is a bigint.\n *\n * @returns A new struct that will only accept bigints.\n */\nfunction bigint() {\n    return (0, utilities_js_1.define)('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\nexports.bigint = bigint;\n/**\n * Ensure that a value is a boolean.\n *\n * @returns A new struct that will only accept booleans.\n */\nfunction boolean() {\n    return (0, utilities_js_1.define)('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\nexports.boolean = boolean;\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n *\n * @returns A new struct that will only accept valid `Date` objects.\n */\nfunction date() {\n    return (0, utilities_js_1.define)('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${(0, utils_js_1.print)(value)}`);\n    });\n}\nexports.date = date;\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n *\n * @param values - The potential values that the input can be.\n * @returns A new struct that will only accept the given values.\n */\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((value) => (0, utils_js_1.print)(value)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new struct_js_1.Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n    });\n}\nexports.enums = enums;\n/**\n * Ensure that a value is a function.\n *\n * @returns A new struct that will only accept functions.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction func() {\n    return (0, utilities_js_1.define)('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${(0, utils_js_1.print)(value)}`);\n    });\n}\nexports.func = func;\n/**\n * Ensure that a value is an instance of a specific class.\n *\n * @param Class - The class that the value must be an instance of.\n * @returns A new struct that will only accept instances of the given class.\n */\nfunction instance(Class) {\n    return (0, utilities_js_1.define)('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${(0, utils_js_1.print)(value)}`);\n    });\n}\nexports.instance = instance;\n/**\n * Ensure that a value is an integer.\n *\n * @returns A new struct that will only accept integers.\n */\nfunction integer() {\n    return (0, utilities_js_1.define)('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${(0, utils_js_1.print)(value)}`);\n    });\n}\nexports.integer = integer;\n/**\n * Ensure that a value matches all of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match all of the\n * given structs.\n */\nfunction intersection(Structs) {\n    return new struct_js_1.Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, context) {\n            for (const { entries } of Structs) {\n                yield* entries(value, context);\n            }\n        },\n        *validator(value, context) {\n            for (const { validator } of Structs) {\n                yield* validator(value, context);\n            }\n        },\n        *refiner(value, context) {\n            for (const { refiner } of Structs) {\n                yield* refiner(value, context);\n            }\n        },\n    });\n}\nexports.intersection = intersection;\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nfunction literal(constant) {\n    const description = (0, utils_js_1.print)(constant);\n    const valueType = typeof constant;\n    return new struct_js_1.Struct({\n        type: 'literal',\n        schema: valueType === 'string' ||\n            valueType === 'number' ||\n            valueType === 'boolean'\n            ? constant\n            : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n    });\n}\nexports.literal = literal;\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n *\n * @param Key - The struct to validate each key in the map against.\n * @param Value - The struct to validate each value in the map against.\n * @returns A new struct that will only accept `Map` objects.\n */\nfunction map(Key, Value) {\n    return new struct_js_1.Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [mapKey, mapValue] of value.entries()) {\n                    yield [mapKey, mapKey, Key];\n                    yield [mapKey, mapValue, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n    });\n}\nexports.map = map;\n/**\n * Ensure that no value ever passes validation.\n *\n * @returns A new struct that will never pass validation.\n */\nfunction never() {\n    return (0, utilities_js_1.define)('never', () => false);\n}\nexports.never = never;\n/**\n * Augment an existing struct to allow `null` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `null` values.\n */\nfunction nullable(struct) {\n    return new struct_js_1.Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\nexports.nullable = nullable;\n/**\n * Ensure that a value is a number.\n *\n * @returns A new struct that will only accept numbers.\n */\nfunction number() {\n    return (0, utilities_js_1.define)('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${(0, utils_js_1.print)(value)}`);\n    });\n}\nexports.number = number;\n/**\n * Ensure that a value is an object, that it has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new struct_js_1.Struct({\n        type: 'object',\n        schema: schema ?? null,\n        *entries(value) {\n            if (schema && (0, utils_js_1.isObject)(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return ((0, utils_js_1.isObject)(value) || `Expected an object, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n        coercer(value) {\n            return (0, utils_js_1.isObject)(value) ? { ...value } : value;\n        },\n    });\n}\nexports.object = object;\n/**\n * Augment a struct to allow `undefined` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `undefined` values.\n */\nfunction optional(struct) {\n    return new struct_js_1.Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\nexports.optional = optional;\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * @param Key - The struct to validate each key in the record against.\n * @param Value - The struct to validate each value in the record against.\n * @returns A new struct that will only accept objects.\n */\nfunction record(Key, Value) {\n    return new struct_js_1.Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if ((0, utils_js_1.isObject)(value)) {\n                // eslint-disable-next-line guard-for-in\n                for (const objectKey in value) {\n                    const objectValue = value[objectKey];\n                    yield [objectKey, objectKey, Key];\n                    yield [objectKey, objectValue, Value];\n                }\n            }\n        },\n        validator(value) {\n            return ((0, utils_js_1.isObject)(value) || `Expected an object, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n    });\n}\nexports.record = record;\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n *\n * @returns A new struct that will only accept `RegExp` objects.\n */\nfunction regexp() {\n    return (0, utilities_js_1.define)('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\nexports.regexp = regexp;\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n *\n * @param Element - The struct to validate each element in the set against.\n * @returns A new struct that will only accept `Set` objects.\n */\nfunction set(Element) {\n    return new struct_js_1.Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const setValue of value) {\n                    yield [setValue, setValue, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n    });\n}\nexports.set = set;\n/**\n * Ensure that a value is a string.\n *\n * @returns A new struct that will only accept strings.\n */\nfunction string() {\n    return (0, utilities_js_1.define)('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${(0, utils_js_1.print)(value)}`);\n    });\n}\nexports.string = string;\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept tuples of the given types.\n */\nfunction tuple(Structs) {\n    const Never = never();\n    return new struct_js_1.Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n    });\n}\nexports.tuple = tuple;\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nfunction type(schema) {\n    const keys = Object.keys(schema);\n    return new struct_js_1.Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if ((0, utils_js_1.isObject)(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return ((0, utils_js_1.isObject)(value) || `Expected an object, but received: ${(0, utils_js_1.print)(value)}`);\n        },\n        coercer(value) {\n            return (0, utils_js_1.isObject)(value) ? { ...value } : value;\n        },\n    });\n}\nexports.type = type;\n/**\n * Ensure that a value matches one of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match one of the\n * given structs.\n */\nfunction union(Structs) {\n    const description = Structs.map((struct) => struct.type).join(' | ');\n    return new struct_js_1.Struct({\n        type: 'union',\n        schema: null,\n        coercer(value) {\n            for (const InnerStruct of Structs) {\n                const [error, coerced] = InnerStruct.validate(value, { coerce: true });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const InnerStruct of Structs) {\n                const [...tuples] = (0, utils_js_1.run)(value, InnerStruct, ctx);\n                const [first] = tuples;\n                if (!first?.[0]) {\n                    return [];\n                }\n                for (const [failure] of tuples) {\n                    if (failure) {\n                        failures.push(failure);\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${(0, utils_js_1.print)(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\nexports.union = union;\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n *\n * @returns A struct that will always pass validation.\n */\nfunction unknown() {\n    return (0, utilities_js_1.define)('unknown', () => true);\n}\nexports.unknown = unknown;\n//# sourceMappingURL=types.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3Qvc3RydWN0cy90eXBlcy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLGFBQWEsR0FBRyxZQUFZLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxXQUFXLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGdCQUFnQixHQUFHLGFBQWEsR0FBRyxXQUFXLEdBQUcsZUFBZSxHQUFHLG9CQUFvQixHQUFHLGVBQWUsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsYUFBYSxHQUFHLFlBQVksR0FBRyxlQUFlLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxXQUFXO0FBQ2xhLG9CQUFvQixtQkFBTyxDQUFDLGlGQUFlO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLCtFQUFjO0FBQ3pDLHVCQUF1QixtQkFBTyxDQUFDLDhGQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMERBQTBELDZCQUE2QjtBQUN2RixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELDZCQUE2QjtBQUM1RixLQUFLO0FBQ0w7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZLG9CQUFvQiw2QkFBNkI7QUFDbEcsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsNkJBQTZCO0FBQy9FLEtBQUs7QUFDTDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVyw2QkFBNkIsNkJBQTZCO0FBQ2pHLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZCQUE2QjtBQUMvRSxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWSxvQkFBb0IsNkJBQTZCO0FBQ3ZHLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNERBQTRELDZCQUE2QjtBQUN6RixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDZCQUE2QjtBQUM3RSxLQUFLO0FBQ0w7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRGQUE0Riw2QkFBNkI7QUFDekgsU0FBUztBQUNUO0FBQ0EsdURBQXVELFdBQVc7QUFDbEUsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRGQUE0Riw2QkFBNkI7QUFDekgsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNERBQTRELDZCQUE2QjtBQUN6RixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsNkJBQTZCO0FBQzdFLEtBQUs7QUFDTDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9EQUFvRCw2QkFBNkI7QUFDakYsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNEZBQTRGLDZCQUE2QjtBQUN6SCxTQUFTO0FBQ1Q7QUFDQSx1REFBdUQsV0FBVztBQUNsRSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsY0FBYztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxZQUFZLG9CQUFvQiw2QkFBNkI7QUFDM0g7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc3VwZXJzdHJ1Y3QvZGlzdC9zdHJ1Y3RzL3R5cGVzLmNqcz83YTBjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51bmtub3duID0gZXhwb3J0cy51bmlvbiA9IGV4cG9ydHMudHlwZSA9IGV4cG9ydHMudHVwbGUgPSBleHBvcnRzLnN0cmluZyA9IGV4cG9ydHMuc2V0ID0gZXhwb3J0cy5yZWdleHAgPSBleHBvcnRzLnJlY29yZCA9IGV4cG9ydHMub3B0aW9uYWwgPSBleHBvcnRzLm9iamVjdCA9IGV4cG9ydHMubnVtYmVyID0gZXhwb3J0cy5udWxsYWJsZSA9IGV4cG9ydHMubmV2ZXIgPSBleHBvcnRzLm1hcCA9IGV4cG9ydHMubGl0ZXJhbCA9IGV4cG9ydHMuaW50ZXJzZWN0aW9uID0gZXhwb3J0cy5pbnRlZ2VyID0gZXhwb3J0cy5pbnN0YW5jZSA9IGV4cG9ydHMuZnVuYyA9IGV4cG9ydHMuZW51bXMgPSBleHBvcnRzLmRhdGUgPSBleHBvcnRzLmJvb2xlYW4gPSBleHBvcnRzLmJpZ2ludCA9IGV4cG9ydHMuYXJyYXkgPSBleHBvcnRzLmFueSA9IHZvaWQgMDtcbmNvbnN0IHN0cnVjdF9qc18xID0gcmVxdWlyZShcIi4uL3N0cnVjdC5janNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4uL3V0aWxzLmNqc1wiKTtcbmNvbnN0IHV0aWxpdGllc19qc18xID0gcmVxdWlyZShcIi4vdXRpbGl0aWVzLmNqc1wiKTtcbi8qKlxuICogRW5zdXJlIHRoYXQgYW55IHZhbHVlIHBhc3NlcyB2YWxpZGF0aW9uLlxuICpcbiAqIEByZXR1cm5zIEEgc3RydWN0IHRoYXQgd2lsbCBhbHdheXMgcGFzcyB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBhbnkoKSB7XG4gICAgcmV0dXJuICgwLCB1dGlsaXRpZXNfanNfMS5kZWZpbmUpKCdhbnknLCAoKSA9PiB0cnVlKTtcbn1cbmV4cG9ydHMuYW55ID0gYW55O1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGFycmF5IGFuZCB0aGF0IGl0cyBlbGVtZW50cyBhcmUgb2YgYSBzcGVjaWZpYyB0eXBlLlxuICpcbiAqIE5vdGU6IElmIHlvdSBvbWl0IHRoZSBlbGVtZW50IHN0cnVjdCwgdGhlIGFycmF5cyBlbGVtZW50cyB3aWxsIG5vdCBiZVxuICogaXRlcmF0ZWQgYXQgYWxsLiBUaGlzIGNhbiBiZSBoZWxwZnVsIGZvciBjYXNlcyB3aGVyZSBwZXJmb3JtYW5jZSBpcyBjcml0aWNhbCxcbiAqIGFuZCBpdCBpcyBwcmVmZXJyZWQgdG8gdXNpbmcgYGFycmF5KGFueSgpKWAuXG4gKlxuICogQHBhcmFtIEVsZW1lbnQgLSBUaGUgc3RydWN0IHRvIHZhbGlkYXRlIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgYWdhaW5zdC5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgYXJyYXlzIG9mIHRoZSBnaXZlbiB0eXBlLlxuICovXG5mdW5jdGlvbiBhcnJheShFbGVtZW50KSB7XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5TdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICBzY2hlbWE6IEVsZW1lbnQsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoRWxlbWVudCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBhcnJheVZhbHVlXSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2luZGV4LCBhcnJheVZhbHVlLCBFbGVtZW50XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNsaWNlKCkgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGFuIGFycmF5IHZhbHVlLCBidXQgcmVjZWl2ZWQ6ICR7KDAsIHV0aWxzX2pzXzEucHJpbnQpKHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuYXJyYXkgPSBhcnJheTtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGJpZ2ludC5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IGJpZ2ludHMuXG4gKi9cbmZ1bmN0aW9uIGJpZ2ludCgpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxpdGllc19qc18xLmRlZmluZSkoJ2JpZ2ludCcsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JztcbiAgICB9KTtcbn1cbmV4cG9ydHMuYmlnaW50ID0gYmlnaW50O1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IGJvb2xlYW5zLlxuICovXG5mdW5jdGlvbiBib29sZWFuKCkge1xuICAgIHJldHVybiAoMCwgdXRpbGl0aWVzX2pzXzEuZGVmaW5lKSgnYm9vbGVhbicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gICAgfSk7XG59XG5leHBvcnRzLmJvb2xlYW4gPSBib29sZWFuO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgYERhdGVgLlxuICpcbiAqIE5vdGU6IHRoaXMgYWxzbyBlbnN1cmVzIHRoYXQgdGhlIHZhbHVlIGlzICpub3QqIGFuIGludmFsaWQgYERhdGVgIG9iamVjdCxcbiAqIHdoaWNoIGNhbiBvY2N1ciB3aGVuIHBhcnNpbmcgYSBkYXRlIGZhaWxzIGJ1dCBzdGlsbCByZXR1cm5zIGEgYERhdGVgLlxuICpcbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgdmFsaWQgYERhdGVgIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGRhdGUoKSB7XG4gICAgcmV0dXJuICgwLCB1dGlsaXRpZXNfanNfMS5kZWZpbmUpKCdkYXRlJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAoKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKSkgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIHZhbGlkIFxcYERhdGVcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7KDAsIHV0aWxzX2pzXzEucHJpbnQpKHZhbHVlKX1gKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGF0ZSA9IGRhdGU7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgb25lIG9mIGEgc2V0IG9mIHBvdGVudGlhbCB2YWx1ZXMuXG4gKlxuICogTm90ZTogYWZ0ZXIgY3JlYXRpbmcgdGhlIHN0cnVjdCwgeW91IGNhbiBhY2Nlc3MgdGhlIGRlZmluaXRpb24gb2YgdGhlXG4gKiBwb3RlbnRpYWwgdmFsdWVzIGFzIGBzdHJ1Y3Quc2NoZW1hYC5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHBvdGVudGlhbCB2YWx1ZXMgdGhhdCB0aGUgaW5wdXQgY2FuIGJlLlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCB0aGUgZ2l2ZW4gdmFsdWVzLlxuICovXG5mdW5jdGlvbiBlbnVtcyh2YWx1ZXMpIHtcbiAgICBjb25zdCBzY2hlbWEgPSB7fTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiAoMCwgdXRpbHNfanNfMS5wcmludCkodmFsdWUpKS5qb2luKCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdmFsdWVzKSB7XG4gICAgICAgIHNjaGVtYVtrZXldID0ga2V5O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHN0cnVjdF9qc18xLlN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdlbnVtcycsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgb25lIG9mIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7KDAsIHV0aWxzX2pzXzEucHJpbnQpKHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuZW51bXMgPSBlbnVtcztcbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgZnVuY3Rpb25zLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZnVuY3Rpb24gZnVuYygpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxpdGllc19qc18xLmRlZmluZSkoJ2Z1bmMnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIGZ1bmN0aW9uLCBidXQgcmVjZWl2ZWQ6ICR7KDAsIHV0aWxzX2pzXzEucHJpbnQpKHZhbHVlKX1gKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZnVuYyA9IGZ1bmM7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgYSBzcGVjaWZpYyBjbGFzcy5cbiAqXG4gKiBAcGFyYW0gQ2xhc3MgLSBUaGUgY2xhc3MgdGhhdCB0aGUgdmFsdWUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZi5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgaW5zdGFuY2VzIG9mIHRoZSBnaXZlbiBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gaW5zdGFuY2UoQ2xhc3MpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxpdGllc19qc18xLmRlZmluZSkoJ2luc3RhbmNlJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBDbGFzcyB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgXFxgJHtDbGFzcy5uYW1lfVxcYCBpbnN0YW5jZSwgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IGludGVnZXJzLlxuICovXG5mdW5jdGlvbiBpbnRlZ2VyKCkge1xuICAgIHJldHVybiAoMCwgdXRpbGl0aWVzX2pzXzEuZGVmaW5lKSgnaW50ZWdlcicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYW4gaW50ZWdlciwgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmludGVnZXIgPSBpbnRlZ2VyO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIG1hdGNoZXMgYWxsIG9mIGEgc2V0IG9mIHR5cGVzLlxuICpcbiAqIEBwYXJhbSBTdHJ1Y3RzIC0gVGhlIHNldCBvZiBzdHJ1Y3RzIHRoYXQgdGhlIHZhbHVlIG11c3QgbWF0Y2guXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IHZhbHVlcyB0aGF0IG1hdGNoIGFsbCBvZiB0aGVcbiAqIGdpdmVuIHN0cnVjdHMuXG4gKi9cbmZ1bmN0aW9uIGludGVyc2VjdGlvbihTdHJ1Y3RzKSB7XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5TdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnaW50ZXJzZWN0aW9uJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IGVudHJpZXMgfSBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIGVudHJpZXModmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAqdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgdmFsaWRhdG9yIH0gb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB2YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAqcmVmaW5lcih2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlZmluZXIgfSBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHJlZmluZXIodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0cy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gZXhhY3QgdmFsdWUsIHVzaW5nIGA9PT1gIGZvciBjb21wYXJpc29uLlxuICpcbiAqIEBwYXJhbSBjb25zdGFudCAtIFRoZSBleGFjdCB2YWx1ZSB0aGF0IHRoZSBpbnB1dCBtdXN0IGJlLlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCB0aGUgZXhhY3QgZ2l2ZW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpdGVyYWwoY29uc3RhbnQpIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9ICgwLCB1dGlsc19qc18xLnByaW50KShjb25zdGFudCk7XG4gICAgY29uc3QgdmFsdWVUeXBlID0gdHlwZW9mIGNvbnN0YW50O1xuICAgIHJldHVybiBuZXcgc3RydWN0X2pzXzEuU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ2xpdGVyYWwnLFxuICAgICAgICBzY2hlbWE6IHZhbHVlVHlwZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIHZhbHVlVHlwZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIHZhbHVlVHlwZSA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgICAgICA/IGNvbnN0YW50XG4gICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gY29uc3RhbnQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgdGhlIGxpdGVyYWwgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHsoMCwgdXRpbHNfanNfMS5wcmludCkodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0cy5saXRlcmFsID0gbGl0ZXJhbDtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGBNYXBgIG9iamVjdCwgYW5kIHRoYXQgaXRzIGtleXMgYW5kIHZhbHVlcyBhcmUgb2ZcbiAqIHNwZWNpZmljIHR5cGVzLlxuICpcbiAqIEBwYXJhbSBLZXkgLSBUaGUgc3RydWN0IHRvIHZhbGlkYXRlIGVhY2gga2V5IGluIHRoZSBtYXAgYWdhaW5zdC5cbiAqIEBwYXJhbSBWYWx1ZSAtIFRoZSBzdHJ1Y3QgdG8gdmFsaWRhdGUgZWFjaCB2YWx1ZSBpbiB0aGUgbWFwIGFnYWluc3QuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IGBNYXBgIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcChLZXksIFZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5TdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnbWFwJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKEtleSAmJiBWYWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW21hcEtleSwgbWFwVmFsdWVdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbbWFwS2V5LCBtYXBLZXksIEtleV07XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFttYXBLZXksIG1hcFZhbHVlLCBWYWx1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBNYXAgPyBuZXcgTWFwKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGBNYXBcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7KDAsIHV0aWxzX2pzXzEucHJpbnQpKHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydHMubWFwID0gbWFwO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBubyB2YWx1ZSBldmVyIHBhc3NlcyB2YWxpZGF0aW9uLlxuICpcbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgbmV2ZXIgcGFzcyB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBuZXZlcigpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxpdGllc19qc18xLmRlZmluZSkoJ25ldmVyJywgKCkgPT4gZmFsc2UpO1xufVxuZXhwb3J0cy5uZXZlciA9IG5ldmVyO1xuLyoqXG4gKiBBdWdtZW50IGFuIGV4aXN0aW5nIHN0cnVjdCB0byBhbGxvdyBgbnVsbGAgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGF1Z21lbnQuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIGFjY2VwdCBgbnVsbGAgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBudWxsYWJsZShzdHJ1Y3QpIHtcbiAgICByZXR1cm4gbmV3IHN0cnVjdF9qc18xLlN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IG51bGwgfHwgc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSxcbiAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICAgIH0pO1xufVxuZXhwb3J0cy5udWxsYWJsZSA9IG51bGxhYmxlO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgbnVtYmVyLlxuICpcbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgbnVtYmVycy5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyKCkge1xuICAgIHJldHVybiAoMCwgdXRpbGl0aWVzX2pzXzEuZGVmaW5lKSgnbnVtYmVyJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSkgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIG51bWJlciwgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBvYmplY3QsIHRoYXQgaXQgaGFzIGEga25vd24gc2V0IG9mIHByb3BlcnRpZXMsXG4gKiBhbmQgdGhhdCBpdHMgcHJvcGVydGllcyBhcmUgb2Ygc3BlY2lmaWMgdHlwZXMuXG4gKlxuICogTm90ZTogVW5yZWNvZ25pemVkIHByb3BlcnRpZXMgd2lsbCBmYWlsIHZhbGlkYXRpb24uXG4gKlxuICogQHBhcmFtIHNjaGVtYSAtIEFuIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIHN0cnVjdHVyZSBvZiB0aGUgb2JqZWN0LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBvYmplY3Qoc2NoZW1hKSB7XG4gICAgY29uc3Qga25vd25zID0gc2NoZW1hID8gT2JqZWN0LmtleXMoc2NoZW1hKSA6IFtdO1xuICAgIGNvbnN0IE5ldmVyID0gbmV2ZXIoKTtcbiAgICByZXR1cm4gbmV3IHN0cnVjdF9qc18xLlN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYSA/PyBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYSAmJiAoMCwgdXRpbHNfanNfMS5pc09iamVjdCkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5rbm93bnMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga25vd25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHVua25vd25zLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZVtrZXldLCBzY2hlbWFba2V5XV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVua25vd25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIE5ldmVyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgoMCwgdXRpbHNfanNfMS5pc09iamVjdCkodmFsdWUpIHx8IGBFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHsoMCwgdXRpbHNfanNfMS5wcmludCkodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEuaXNPYmplY3QpKHZhbHVlKSA/IHsgLi4udmFsdWUgfSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0cy5vYmplY3QgPSBvYmplY3Q7XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gYWxsb3cgYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIGF1Z21lbnQuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIGFjY2VwdCBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsKHN0cnVjdCkge1xuICAgIHJldHVybiBuZXcgc3RydWN0X2pzXzEuU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICAgIH0pO1xufVxuZXhwb3J0cy5vcHRpb25hbCA9IG9wdGlvbmFsO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGtleXMgYW5kIHZhbHVlcyBvZiBzcGVjaWZpYyB0eXBlcywgYnV0XG4gKiB3aXRob3V0IGVuc3VyaW5nIGFueSBzcGVjaWZpYyBzaGFwZSBvZiBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBSZWNvcmRgIHV0aWxpdHkuXG4gKi9cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBrZXlzIGFuZCB2YWx1ZXMgb2Ygc3BlY2lmaWMgdHlwZXMsIGJ1dFxuICogd2l0aG91dCBlbnN1cmluZyBhbnkgc3BlY2lmaWMgc2hhcGUgb2YgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0gS2V5IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBlYWNoIGtleSBpbiB0aGUgcmVjb3JkIGFnYWluc3QuXG4gKiBAcGFyYW0gVmFsdWUgLSBUaGUgc3RydWN0IHRvIHZhbGlkYXRlIGVhY2ggdmFsdWUgaW4gdGhlIHJlY29yZCBhZ2FpbnN0LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBvbmx5IGFjY2VwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiByZWNvcmQoS2V5LCBWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgc3RydWN0X2pzXzEuU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ3JlY29yZCcsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfanNfMS5pc09iamVjdCkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqZWN0S2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdFZhbHVlID0gdmFsdWVbb2JqZWN0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW29iamVjdEtleSwgb2JqZWN0S2V5LCBLZXldO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbb2JqZWN0S2V5LCBvYmplY3RWYWx1ZSwgVmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKCgwLCB1dGlsc19qc18xLmlzT2JqZWN0KSh2YWx1ZSkgfHwgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLnJlY29yZCA9IHJlY29yZDtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGBSZWdFeHBgLlxuICpcbiAqIE5vdGU6IHRoaXMgZG9lcyBub3QgdGVzdCB0aGUgdmFsdWUgYWdhaW5zdCB0aGUgcmVndWxhciBleHByZXNzaW9uISBGb3IgdGhhdFxuICogeW91IG5lZWQgdG8gdXNlIHRoZSBgcGF0dGVybigpYCByZWZpbmVtZW50LlxuICpcbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgYFJlZ0V4cGAgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwKCkge1xuICAgIHJldHVybiAoMCwgdXRpbGl0aWVzX2pzXzEuZGVmaW5lKSgncmVnZXhwJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICB9KTtcbn1cbmV4cG9ydHMucmVnZXhwID0gcmVnZXhwO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYFNldGAgb2JqZWN0LCBhbmQgdGhhdCBpdHMgZWxlbWVudHMgYXJlIG9mIGFcbiAqIHNwZWNpZmljIHR5cGUuXG4gKlxuICogQHBhcmFtIEVsZW1lbnQgLSBUaGUgc3RydWN0IHRvIHZhbGlkYXRlIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0IGFnYWluc3QuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IGBTZXRgIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIHNldChFbGVtZW50KSB7XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5TdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnc2V0JyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKEVsZW1lbnQgJiYgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNldFZhbHVlIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtzZXRWYWx1ZSwgc2V0VmFsdWUsIEVsZW1lbnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0ID8gbmV3IFNldCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgU2V0IHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgXFxgU2V0XFxgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLnNldCA9IHNldDtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IHN0cmluZ3MuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZygpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxpdGllc19qc18xLmRlZmluZSkoJ3N0cmluZycsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIHN0cmluZywgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHR1cGxlIG9mIGEgc3BlY2lmaWMgbGVuZ3RoLCBhbmQgdGhhdCBlYWNoIG9mIGl0c1xuICogZWxlbWVudHMgaXMgb2YgYSBzcGVjaWZpYyB0eXBlLlxuICpcbiAqIEBwYXJhbSBTdHJ1Y3RzIC0gVGhlIHNldCBvZiBzdHJ1Y3RzIHRoYXQgdGhlIHZhbHVlIG11c3QgbWF0Y2guXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IHR1cGxlcyBvZiB0aGUgZ2l2ZW4gdHlwZXMuXG4gKi9cbmZ1bmN0aW9uIHR1cGxlKFN0cnVjdHMpIHtcbiAgICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5TdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAndHVwbGUnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChTdHJ1Y3RzLmxlbmd0aCwgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtpLCB2YWx1ZVtpXSwgU3RydWN0c1tpXSB8fCBOZXZlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gYXJyYXksIGJ1dCByZWNlaXZlZDogJHsoMCwgdXRpbHNfanNfMS5wcmludCkodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0cy50dXBsZSA9IHR1cGxlO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGhhcyBhIHNldCBvZiBrbm93biBwcm9wZXJ0aWVzIG9mIHNwZWNpZmljIHR5cGVzLlxuICpcbiAqIE5vdGU6IFVucmVjb2duaXplZCBwcm9wZXJ0aWVzIGFyZSBhbGxvd2VkIGFuZCB1bnRvdWNoZWQuIFRoaXMgaXMgc2ltaWxhciB0b1xuICogaG93IFR5cGVTY3JpcHQncyBzdHJ1Y3R1cmFsIHR5cGluZyB3b3Jrcy5cbiAqXG4gKiBAcGFyYW0gc2NoZW1hIC0gQW4gb2JqZWN0IHRoYXQgZGVmaW5lcyB0aGUgc3RydWN0dXJlIG9mIHRoZSBvYmplY3QuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIHR5cGUoc2NoZW1hKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNjaGVtYSk7XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5TdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAndHlwZScsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfanNfMS5pc09iamVjdCkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ssIHZhbHVlW2tdLCBzY2hlbWFba11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKCgwLCB1dGlsc19qc18xLmlzT2JqZWN0KSh2YWx1ZSkgfHwgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS5pc09iamVjdCkodmFsdWUpID8geyAuLi52YWx1ZSB9IDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLnR5cGUgPSB0eXBlO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIG1hdGNoZXMgb25lIG9mIGEgc2V0IG9mIHR5cGVzLlxuICpcbiAqIEBwYXJhbSBTdHJ1Y3RzIC0gVGhlIHNldCBvZiBzdHJ1Y3RzIHRoYXQgdGhlIHZhbHVlIG11c3QgbWF0Y2guXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IHZhbHVlcyB0aGF0IG1hdGNoIG9uZSBvZiB0aGVcbiAqIGdpdmVuIHN0cnVjdHMuXG4gKi9cbmZ1bmN0aW9uIHVuaW9uKFN0cnVjdHMpIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IFN0cnVjdHMubWFwKChzdHJ1Y3QpID0+IHN0cnVjdC50eXBlKS5qb2luKCcgfCAnKTtcbiAgICByZXR1cm4gbmV3IHN0cnVjdF9qc18xLlN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICd1bmlvbicsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBJbm5lclN0cnVjdCBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2Vycm9yLCBjb2VyY2VkXSA9IElubmVyU3RydWN0LnZhbGlkYXRlKHZhbHVlLCB7IGNvZXJjZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2VyY2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IElubmVyU3RydWN0IG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbLi4udHVwbGVzXSA9ICgwLCB1dGlsc19qc18xLnJ1bikodmFsdWUsIElubmVyU3RydWN0LCBjdHgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtmaXJzdF0gPSB0dXBsZXM7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdD8uWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZmFpbHVyZV0gb2YgdHVwbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlcy5wdXNoKGZhaWx1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgdGhlIHZhbHVlIHRvIHNhdGlzZnkgYSB1bmlvbiBvZiBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgYnV0IHJlY2VpdmVkOiAkeygwLCB1dGlsc19qc18xLnByaW50KSh2YWx1ZSl9YCxcbiAgICAgICAgICAgICAgICAuLi5mYWlsdXJlcyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLnVuaW9uID0gdW5pb247XG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbiwgd2l0aG91dCB3aWRlbmluZyBpdHMgdHlwZSB0byBgYW55YC5cbiAqXG4gKiBAcmV0dXJucyBBIHN0cnVjdCB0aGF0IHdpbGwgYWx3YXlzIHBhc3MgdmFsaWRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gdW5rbm93bigpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxpdGllc19qc18xLmRlZmluZSkoJ3Vua25vd24nLCAoKSA9PiB0cnVlKTtcbn1cbmV4cG9ydHMudW5rbm93biA9IHVua25vd247XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/superstruct/dist/structs/types.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/superstruct/dist/structs/utilities.cjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@metamask/superstruct/dist/structs/utilities.cjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pick = exports.partial = exports.omit = exports.lazy = exports.dynamic = exports.deprecated = exports.define = exports.assign = void 0;\nconst struct_js_1 = __webpack_require__(/*! ../struct.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/struct.cjs\");\nconst types_js_1 = __webpack_require__(/*! ./types.cjs */ \"(ssr)/./node_modules/@metamask/superstruct/dist/structs/types.cjs\");\n/**\n * Create a new struct that combines the properties from multiple object or type\n * structs. Its return type will match the first parameter's type.\n *\n * @param Structs - The structs to combine.\n * @returns A new struct that combines the properties of the input structs.\n */\nfunction assign(...Structs) {\n    const isType = Structs[0]?.type === 'type';\n    const schemas = Structs.map(({ schema }) => schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? (0, types_js_1.type)(schema) : (0, types_js_1.object)(schema);\n}\nexports.assign = assign;\n/**\n * Define a new struct type with a custom validation function.\n *\n * @param name - The name of the struct type.\n * @param validator - The validation function.\n * @returns A new struct type.\n */\nfunction define(name, validator) {\n    return new struct_js_1.Struct({ type: name, schema: null, validator });\n}\nexports.define = define;\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n *\n * @param struct - The struct to augment.\n * @param log - The function to call when the value is not `undefined`.\n * @returns A new struct that will only accept `undefined` or values that pass\n * the input struct.\n */\nfunction deprecated(struct, log) {\n    return new struct_js_1.Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            log(value, ctx);\n            return struct.validator(value, ctx);\n        },\n    });\n}\nexports.deprecated = deprecated;\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n *\n * @param fn - The callback to create the struct.\n * @returns A new struct with dynamic validation logic.\n */\nfunction dynamic(fn) {\n    return new struct_js_1.Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\nexports.dynamic = dynamic;\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n *\n * @param fn - The callback to create the struct.\n * @returns A new struct with lazily evaluated validation logic.\n */\nfunction lazy(fn) {\n    let struct;\n    return new struct_js_1.Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\nexports.lazy = lazy;\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n *\n * @param struct - The struct to augment.\n * @param keys - The keys to omit.\n * @returns A new struct that will not accept the input keys.\n */\nfunction omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return (0, types_js_1.type)(subschema);\n        default:\n            return (0, types_js_1.object)(subschema);\n    }\n}\nexports.omit = omit;\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept the input keys as `undefined`.\n */\nfunction partial(struct) {\n    const isStruct = struct instanceof struct_js_1.Struct;\n    const schema = isStruct ? { ...struct.schema } : { ...struct };\n    // eslint-disable-next-line guard-for-in\n    for (const key in schema) {\n        schema[key] = (0, types_js_1.optional)(schema[key]);\n    }\n    if (isStruct && struct.type === 'type') {\n        return (0, types_js_1.type)(schema);\n    }\n    return (0, types_js_1.object)(schema);\n}\nexports.partial = partial;\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n *\n * @param struct - The struct to augment.\n * @param keys - The keys to pick.\n * @returns A new struct that will only accept the input keys.\n */\nfunction pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return (0, types_js_1.type)(subschema);\n        default:\n            return (0, types_js_1.object)(subschema);\n    }\n}\nexports.pick = pick;\n//# sourceMappingURL=utilities.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3Qvc3RydWN0cy91dGlsaXRpZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVksR0FBRyxlQUFlLEdBQUcsWUFBWSxHQUFHLFlBQVksR0FBRyxlQUFlLEdBQUcsa0JBQWtCLEdBQUcsY0FBYyxHQUFHLGNBQWM7QUFDckksb0JBQW9CLG1CQUFPLENBQUMsaUZBQWU7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsc0ZBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0MsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQ0FBcUM7QUFDekU7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQixJQUFJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3Qvc3RydWN0cy91dGlsaXRpZXMuY2pzPzFiMDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBpY2sgPSBleHBvcnRzLnBhcnRpYWwgPSBleHBvcnRzLm9taXQgPSBleHBvcnRzLmxhenkgPSBleHBvcnRzLmR5bmFtaWMgPSBleHBvcnRzLmRlcHJlY2F0ZWQgPSBleHBvcnRzLmRlZmluZSA9IGV4cG9ydHMuYXNzaWduID0gdm9pZCAwO1xuY29uc3Qgc3RydWN0X2pzXzEgPSByZXF1aXJlKFwiLi4vc3RydWN0LmNqc1wiKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi90eXBlcy5janNcIik7XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgdGhhdCBjb21iaW5lcyB0aGUgcHJvcGVydGllcyBmcm9tIG11bHRpcGxlIG9iamVjdCBvciB0eXBlXG4gKiBzdHJ1Y3RzLiBJdHMgcmV0dXJuIHR5cGUgd2lsbCBtYXRjaCB0aGUgZmlyc3QgcGFyYW1ldGVyJ3MgdHlwZS5cbiAqXG4gKiBAcGFyYW0gU3RydWN0cyAtIFRoZSBzdHJ1Y3RzIHRvIGNvbWJpbmUuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCBjb21iaW5lcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgaW5wdXQgc3RydWN0cy5cbiAqL1xuZnVuY3Rpb24gYXNzaWduKC4uLlN0cnVjdHMpIHtcbiAgICBjb25zdCBpc1R5cGUgPSBTdHJ1Y3RzWzBdPy50eXBlID09PSAndHlwZSc7XG4gICAgY29uc3Qgc2NoZW1hcyA9IFN0cnVjdHMubWFwKCh7IHNjaGVtYSB9KSA9PiBzY2hlbWEpO1xuICAgIGNvbnN0IHNjaGVtYSA9IE9iamVjdC5hc3NpZ24oe30sIC4uLnNjaGVtYXMpO1xuICAgIHJldHVybiBpc1R5cGUgPyAoMCwgdHlwZXNfanNfMS50eXBlKShzY2hlbWEpIDogKDAsIHR5cGVzX2pzXzEub2JqZWN0KShzY2hlbWEpO1xufVxuZXhwb3J0cy5hc3NpZ24gPSBhc3NpZ247XG4vKipcbiAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgc3RydWN0IHR5cGUuXG4gKiBAcGFyYW0gdmFsaWRhdG9yIC0gVGhlIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lKG5hbWUsIHZhbGlkYXRvcikge1xuICAgIHJldHVybiBuZXcgc3RydWN0X2pzXzEuU3RydWN0KHsgdHlwZTogbmFtZSwgc2NoZW1hOiBudWxsLCB2YWxpZGF0b3IgfSk7XG59XG5leHBvcnRzLmRlZmluZSA9IGRlZmluZTtcbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBzdHJ1Y3QsIGJ1dCB0aGUgdmFsdWUgaXMgYWxsb3dlZCB0b1xuICogYmUgYHVuZGVmaW5lZGAuIGBsb2dgIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSB2YWx1ZSBpcyBub3QgYHVuZGVmaW5lZGAuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gYXVnbWVudC5cbiAqIEBwYXJhbSBsb2cgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSB2YWx1ZSBpcyBub3QgYHVuZGVmaW5lZGAuXG4gKiBAcmV0dXJucyBBIG5ldyBzdHJ1Y3QgdGhhdCB3aWxsIG9ubHkgYWNjZXB0IGB1bmRlZmluZWRgIG9yIHZhbHVlcyB0aGF0IHBhc3NcbiAqIHRoZSBpbnB1dCBzdHJ1Y3QuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoc3RydWN0LCBsb2cpIHtcbiAgICByZXR1cm4gbmV3IHN0cnVjdF9qc18xLlN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLmRlcHJlY2F0ZWQgPSBkZXByZWNhdGVkO1xuLyoqXG4gKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBkeW5hbWljIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSB0aGUgdmFsdWUgY3VycmVudGx5IGJlaW5nIHZhbGlkYXRlZCwgYW5kIG11c3RcbiAqIHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdmFsaWRhdGUgaXQgd2l0aC4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIG1vZGVsXG4gKiB2YWxpZGF0aW9uIGxvZ2ljIHRoYXQgY2hhbmdlcyBiYXNlZCBvbiBpdHMgaW5wdXQuXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIGNhbGxiYWNrIHRvIGNyZWF0ZSB0aGUgc3RydWN0LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHdpdGggZHluYW1pYyB2YWxpZGF0aW9uIGxvZ2ljLlxuICovXG5mdW5jdGlvbiBkeW5hbWljKGZuKSB7XG4gICAgcmV0dXJuIG5ldyBzdHJ1Y3RfanNfMS5TdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnZHluYW1pYycsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB5aWVsZCogc3RydWN0LmVudHJpZXModmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICByZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0cy5keW5hbWljID0gZHluYW1pYztcbi8qKlxuICogQ3JlYXRlIGEgc3RydWN0IHdpdGggbGF6aWx5IGV2YWx1YXRlZCB2YWxpZGF0aW9uIGxvZ2ljLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHZhbGlkYXRpb24gaXMgcnVuIHdpdGggdGhlIHN0cnVjdCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXG4gKiBhbmQgbXVzdCByZXR1cm4gYSBzdHJ1Y3Qgb2JqZWN0IHRvIHVzZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGNhc2VzIHdoZXJlIHlvdVxuICogd2FudCB0byBoYXZlIHNlbGYtcmVmZXJlbnRpYWwgc3RydWN0cyBmb3IgbmVzdGVkIGRhdGEgc3RydWN0dXJlcyB0byBhdm9pZCBhXG4gKiBjaXJjdWxhciBkZWZpbml0aW9uIHByb2JsZW0uXG4gKlxuICogQHBhcmFtIGZuIC0gVGhlIGNhbGxiYWNrIHRvIGNyZWF0ZSB0aGUgc3RydWN0LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHdpdGggbGF6aWx5IGV2YWx1YXRlZCB2YWxpZGF0aW9uIGxvZ2ljLlxuICovXG5mdW5jdGlvbiBsYXp5KGZuKSB7XG4gICAgbGV0IHN0cnVjdDtcbiAgICByZXR1cm4gbmV3IHN0cnVjdF9qc18xLlN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdsYXp5JyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydHMubGF6eSA9IGxhenk7XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IGV4Y2x1ZGluZ1xuICogc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgT21pdGAgdXRpbGl0eS5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHBhcmFtIGtleXMgLSBUaGUga2V5cyB0byBvbWl0LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBub3QgYWNjZXB0IHRoZSBpbnB1dCBrZXlzLlxuICovXG5mdW5jdGlvbiBvbWl0KHN0cnVjdCwga2V5cykge1xuICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBzdHJ1Y3Q7XG4gICAgY29uc3Qgc3Vic2NoZW1hID0geyAuLi5zY2hlbWEgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGRlbGV0ZSBzdWJzY2hlbWFba2V5XTtcbiAgICB9XG4gICAgc3dpdGNoIChzdHJ1Y3QudHlwZSkge1xuICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS50eXBlKShzdWJzY2hlbWEpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICgwLCB0eXBlc19qc18xLm9iamVjdCkoc3Vic2NoZW1hKTtcbiAgICB9XG59XG5leHBvcnRzLm9taXQgPSBvbWl0O1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCB3aXRoIGFsbCBvZiBpdHNcbiAqIHByb3BlcnRpZXMgYWxsb3dlZCB0byBiZSBgdW5kZWZpbmVkYC5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUGFydGlhbGAgdXRpbGl0eS5cbiAqXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBhdWdtZW50LlxuICogQHJldHVybnMgQSBuZXcgc3RydWN0IHRoYXQgd2lsbCBhY2NlcHQgdGhlIGlucHV0IGtleXMgYXMgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIHBhcnRpYWwoc3RydWN0KSB7XG4gICAgY29uc3QgaXNTdHJ1Y3QgPSBzdHJ1Y3QgaW5zdGFuY2VvZiBzdHJ1Y3RfanNfMS5TdHJ1Y3Q7XG4gICAgY29uc3Qgc2NoZW1hID0gaXNTdHJ1Y3QgPyB7IC4uLnN0cnVjdC5zY2hlbWEgfSA6IHsgLi4uc3RydWN0IH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBzY2hlbWFba2V5XSA9ICgwLCB0eXBlc19qc18xLm9wdGlvbmFsKShzY2hlbWFba2V5XSk7XG4gICAgfVxuICAgIGlmIChpc1N0cnVjdCAmJiBzdHJ1Y3QudHlwZSA9PT0gJ3R5cGUnKSB7XG4gICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS50eXBlKShzY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEub2JqZWN0KShzY2hlbWEpO1xufVxuZXhwb3J0cy5wYXJ0aWFsID0gcGFydGlhbDtcbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgb25seSBpbmNsdWRpbmdcbiAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFBpY2tgIHV0aWxpdHkuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gYXVnbWVudC5cbiAqIEBwYXJhbSBrZXlzIC0gVGhlIGtleXMgdG8gcGljay5cbiAqIEByZXR1cm5zIEEgbmV3IHN0cnVjdCB0aGF0IHdpbGwgb25seSBhY2NlcHQgdGhlIGlucHV0IGtleXMuXG4gKi9cbmZ1bmN0aW9uIHBpY2soc3RydWN0LCBrZXlzKSB7XG4gICAgY29uc3QgeyBzY2hlbWEgfSA9IHN0cnVjdDtcbiAgICBjb25zdCBzdWJzY2hlbWEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIHN1YnNjaGVtYVtrZXldID0gc2NoZW1hW2tleV07XG4gICAgfVxuICAgIHN3aXRjaCAoc3RydWN0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEudHlwZSkoc3Vic2NoZW1hKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5vYmplY3QpKHN1YnNjaGVtYSk7XG4gICAgfVxufVxuZXhwb3J0cy5waWNrID0gcGljaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxpdGllcy5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/superstruct/dist/structs/utilities.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/superstruct/dist/utils.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/superstruct/dist/utils.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.run = exports.toFailures = exports.toFailure = exports.shiftIterator = exports.print = exports.isPlainObject = exports.isObject = void 0;\n/**\n * Check if a value is an iterator.\n *\n * @param value - The value to check.\n * @returns Whether the value is an iterator.\n */\nfunction isIterable(value) {\n    return isObject(value) && typeof value[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a plain object.\n */\nfunction isObject(value) {\n    return typeof value === 'object' && value !== null;\n}\nexports.isObject = isObject;\n/**\n * Check if a value is a plain object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a plain object.\n */\nfunction isPlainObject(value) {\n    if (Object.prototype.toString.call(value) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.prototype;\n}\nexports.isPlainObject = isPlainObject;\n/**\n * Return a value as a printable string.\n *\n * @param value - The value to print.\n * @returns The value as a string.\n */\nfunction print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\nexports.print = print;\n/**\n * Shift (remove and return) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n *\n * @param input - The iterator to shift.\n * @returns The first value of the iterator, or `undefined` if the iterator is\n * empty.\n */\nfunction shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\nexports.shiftIterator = shiftIterator;\n/**\n * Convert a single validation result to a failure.\n *\n * @param result - The result to convert.\n * @param context - The context of the validation.\n * @param struct - The struct being validated.\n * @param value - The value being validated.\n * @returns A failure if the result is a failure, or `undefined` if the result\n * is a success.\n */\nfunction toFailure(result, context, struct, value) {\n    if (result === true) {\n        return undefined;\n    }\n    else if (result === false) {\n        // eslint-disable-next-line no-param-reassign\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        // eslint-disable-next-line no-param-reassign\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\nexports.toFailure = toFailure;\n/**\n * Convert a validation result to an iterable of failures.\n *\n * @param result - The result to convert.\n * @param context - The context of the validation.\n * @param struct - The struct being validated.\n * @param value - The value being validated.\n * @yields The failures.\n * @returns An iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        // eslint-disable-next-line no-param-reassign\n        result = [result];\n    }\n    for (const validationResult of result) {\n        const failure = toFailure(validationResult, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\nexports.toFailures = toFailures;\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n *\n * @param value - The value to check.\n * @param struct - The struct to check against.\n * @param options - Optional settings.\n * @param options.path - The path to the value in the input data.\n * @param options.branch - The branch of the value in the input data.\n * @param options.coerce - Whether to coerce the value before validating it.\n * @param options.mask - Whether to mask the value before validating it.\n * @param options.message - An optional message to include in the error.\n * @yields An iterator of failures or success.\n * @returns An iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const context = { path, branch };\n    if (coerce) {\n        // eslint-disable-next-line no-param-reassign\n        value = struct.coercer(value, context);\n        if (mask &&\n            struct.type !== 'type' &&\n            isObject(struct.schema) &&\n            isObject(value) &&\n            !Array.isArray(value)) {\n            for (const key in value) {\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, context)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    // eslint-disable-next-line prefer-const\n    for (let [innerKey, innerValue, innerStruct] of struct.entries(value, context)) {\n        const iterable = run(innerValue, innerStruct, {\n            path: innerKey === undefined ? path : [...path, innerKey],\n            branch: innerKey === undefined ? branch : [...branch, innerValue],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const result of iterable) {\n            if (result[0]) {\n                status =\n                    result[0].refinement === null || result[0].refinement === undefined\n                        ? 'not_valid'\n                        : 'not_refined';\n                yield [result[0], undefined];\n            }\n            else if (coerce) {\n                innerValue = result[1];\n                if (innerKey === undefined) {\n                    // eslint-disable-next-line no-param-reassign\n                    value = innerValue;\n                }\n                else if (value instanceof Map) {\n                    value.set(innerKey, innerValue);\n                }\n                else if (value instanceof Set) {\n                    value.add(innerValue);\n                }\n                else if (isObject(value)) {\n                    if (innerValue !== undefined || innerKey in value) {\n                        value[innerKey] = innerValue;\n                    }\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, context)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\nexports.run = run;\n//# sourceMappingURL=utils.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3QvdXRpbHMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVcsR0FBRyxrQkFBa0IsR0FBRyxpQkFBaUIsR0FBRyxxQkFBcUIsR0FBRyxhQUFhLEdBQUcscUJBQXFCLEdBQUcsZ0JBQWdCO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLE1BQU07QUFDeEU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLE9BQU87QUFDbkIsWUFBWSxvREFBb0QsS0FBSyxJQUFJLG1DQUFtQyxXQUFXLFNBQVMsb0JBQW9CLGFBQWEsT0FBTztBQUN4SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxZQUFZLDREQUE0RDtBQUN4RSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3N1cGVyc3RydWN0L2Rpc3QvdXRpbHMuY2pzPzM0NDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJ1biA9IGV4cG9ydHMudG9GYWlsdXJlcyA9IGV4cG9ydHMudG9GYWlsdXJlID0gZXhwb3J0cy5zaGlmdEl0ZXJhdG9yID0gZXhwb3J0cy5wcmludCA9IGV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGV4cG9ydHMuaXNPYmplY3QgPSB2b2lkIDA7XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaXRlcmF0b3IuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYW4gaXRlcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cbmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4vKipcbiAqIFJldHVybiBhIHZhbHVlIGFzIGEgcHJpbnRhYmxlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcHJpbnQuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgYXMgYSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHByaW50KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IGAke3ZhbHVlfWA7XG59XG5leHBvcnRzLnByaW50ID0gcHJpbnQ7XG4vKipcbiAqIFNoaWZ0IChyZW1vdmUgYW5kIHJldHVybikgdGhlIGZpcnN0IHZhbHVlIGZyb20gdGhlIGBpbnB1dGAgaXRlcmF0b3IuXG4gKiBMaWtlIGBBcnJheS5wcm90b3R5cGUuc2hpZnQoKWAgYnV0IGZvciBhbiBgSXRlcmF0b3JgLlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSBpdGVyYXRvciB0byBzaGlmdC5cbiAqIEByZXR1cm5zIFRoZSBmaXJzdCB2YWx1ZSBvZiB0aGUgaXRlcmF0b3IsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBpdGVyYXRvciBpc1xuICogZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIHNoaWZ0SXRlcmF0b3IoaW5wdXQpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpbnB1dC5uZXh0KCk7XG4gICAgcmV0dXJuIGRvbmUgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbn1cbmV4cG9ydHMuc2hpZnRJdGVyYXRvciA9IHNoaWZ0SXRlcmF0b3I7XG4vKipcbiAqIENvbnZlcnQgYSBzaW5nbGUgdmFsaWRhdGlvbiByZXN1bHQgdG8gYSBmYWlsdXJlLlxuICpcbiAqIEBwYXJhbSByZXN1bHQgLSBUaGUgcmVzdWx0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IG9mIHRoZSB2YWxpZGF0aW9uLlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgYmVpbmcgdmFsaWRhdGVkLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGJlaW5nIHZhbGlkYXRlZC5cbiAqIEByZXR1cm5zIEEgZmFpbHVyZSBpZiB0aGUgcmVzdWx0IGlzIGEgZmFpbHVyZSwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHJlc3VsdFxuICogaXMgYSBzdWNjZXNzLlxuICovXG5mdW5jdGlvbiB0b0ZhaWx1cmUocmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICByZXN1bHQgPSB7fTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHJlc3VsdCA9IHsgbWVzc2FnZTogcmVzdWx0IH07XG4gICAgfVxuICAgIGNvbnN0IHsgcGF0aCwgYnJhbmNoIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gc3RydWN0O1xuICAgIGNvbnN0IHsgcmVmaW5lbWVudCwgbWVzc2FnZSA9IGBFeHBlY3RlZCBhIHZhbHVlIG9mIHR5cGUgXFxgJHt0eXBlfVxcYCR7cmVmaW5lbWVudCA/IGAgd2l0aCByZWZpbmVtZW50IFxcYCR7cmVmaW5lbWVudH1cXGBgIDogJyd9LCBidXQgcmVjZWl2ZWQ6IFxcYCR7cHJpbnQodmFsdWUpfVxcYGAsIH0gPSByZXN1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHJlZmluZW1lbnQsXG4gICAgICAgIGtleTogcGF0aFtwYXRoLmxlbmd0aCAtIDFdLFxuICAgICAgICBwYXRoLFxuICAgICAgICBicmFuY2gsXG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgbWVzc2FnZSxcbiAgICB9O1xufVxuZXhwb3J0cy50b0ZhaWx1cmUgPSB0b0ZhaWx1cmU7XG4vKipcbiAqIENvbnZlcnQgYSB2YWxpZGF0aW9uIHJlc3VsdCB0byBhbiBpdGVyYWJsZSBvZiBmYWlsdXJlcy5cbiAqXG4gKiBAcGFyYW0gcmVzdWx0IC0gVGhlIHJlc3VsdCB0byBjb252ZXJ0LlxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCBvZiB0aGUgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IGJlaW5nIHZhbGlkYXRlZC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBiZWluZyB2YWxpZGF0ZWQuXG4gKiBAeWllbGRzIFRoZSBmYWlsdXJlcy5cbiAqIEByZXR1cm5zIEFuIGl0ZXJhYmxlIG9mIGZhaWx1cmVzLlxuICovXG5mdW5jdGlvbiogdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgICBpZiAoIWlzSXRlcmFibGUocmVzdWx0KSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdF07XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsaWRhdGlvblJlc3VsdCBvZiByZXN1bHQpIHtcbiAgICAgICAgY29uc3QgZmFpbHVyZSA9IHRvRmFpbHVyZSh2YWxpZGF0aW9uUmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKTtcbiAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgIHlpZWxkIGZhaWx1cmU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnRvRmFpbHVyZXMgPSB0b0ZhaWx1cmVzO1xuLyoqXG4gKiBDaGVjayBhIHZhbHVlIGFnYWluc3QgYSBzdHJ1Y3QsIHRyYXZlcnNpbmcgZGVlcGx5IGludG8gbmVzdGVkIHZhbHVlcywgYW5kXG4gKiByZXR1cm5pbmcgYW4gaXRlcmF0b3Igb2YgZmFpbHVyZXMgb3Igc3VjY2Vzcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBzZXR0aW5ncy5cbiAqIEBwYXJhbSBvcHRpb25zLnBhdGggLSBUaGUgcGF0aCB0byB0aGUgdmFsdWUgaW4gdGhlIGlucHV0IGRhdGEuXG4gKiBAcGFyYW0gb3B0aW9ucy5icmFuY2ggLSBUaGUgYnJhbmNoIG9mIHRoZSB2YWx1ZSBpbiB0aGUgaW5wdXQgZGF0YS5cbiAqIEBwYXJhbSBvcHRpb25zLmNvZXJjZSAtIFdoZXRoZXIgdG8gY29lcmNlIHRoZSB2YWx1ZSBiZWZvcmUgdmFsaWRhdGluZyBpdC5cbiAqIEBwYXJhbSBvcHRpb25zLm1hc2sgLSBXaGV0aGVyIHRvIG1hc2sgdGhlIHZhbHVlIGJlZm9yZSB2YWxpZGF0aW5nIGl0LlxuICogQHBhcmFtIG9wdGlvbnMubWVzc2FnZSAtIEFuIG9wdGlvbmFsIG1lc3NhZ2UgdG8gaW5jbHVkZSBpbiB0aGUgZXJyb3IuXG4gKiBAeWllbGRzIEFuIGl0ZXJhdG9yIG9mIGZhaWx1cmVzIG9yIHN1Y2Nlc3MuXG4gKiBAcmV0dXJucyBBbiBpdGVyYXRvciBvZiBmYWlsdXJlcyBvciBzdWNjZXNzLlxuICovXG5mdW5jdGlvbiogcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcGF0aCA9IFtdLCBicmFuY2ggPSBbdmFsdWVdLCBjb2VyY2UgPSBmYWxzZSwgbWFzayA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7IHBhdGgsIGJyYW5jaCB9O1xuICAgIGlmIChjb2VyY2UpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHZhbHVlID0gc3RydWN0LmNvZXJjZXIodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICBpZiAobWFzayAmJlxuICAgICAgICAgICAgc3RydWN0LnR5cGUgIT09ICd0eXBlJyAmJlxuICAgICAgICAgICAgaXNPYmplY3Qoc3RydWN0LnNjaGVtYSkgJiZcbiAgICAgICAgICAgIGlzT2JqZWN0KHZhbHVlKSAmJlxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJ1Y3Quc2NoZW1hW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXR1cyA9ICd2YWxpZCc7XG4gICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpKSB7XG4gICAgICAgIGZhaWx1cmUuZXhwbGFuYXRpb24gPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgICAgIHN0YXR1cyA9ICdub3RfdmFsaWQnO1xuICAgICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGZvciAobGV0IFtpbm5lcktleSwgaW5uZXJWYWx1ZSwgaW5uZXJTdHJ1Y3RdIG9mIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjb250ZXh0KSkge1xuICAgICAgICBjb25zdCBpdGVyYWJsZSA9IHJ1bihpbm5lclZhbHVlLCBpbm5lclN0cnVjdCwge1xuICAgICAgICAgICAgcGF0aDogaW5uZXJLZXkgPT09IHVuZGVmaW5lZCA/IHBhdGggOiBbLi4ucGF0aCwgaW5uZXJLZXldLFxuICAgICAgICAgICAgYnJhbmNoOiBpbm5lcktleSA9PT0gdW5kZWZpbmVkID8gYnJhbmNoIDogWy4uLmJyYW5jaCwgaW5uZXJWYWx1ZV0sXG4gICAgICAgICAgICBjb2VyY2UsXG4gICAgICAgICAgICBtYXNrLFxuICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5tZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbMF0ucmVmaW5lbWVudCA9PT0gbnVsbCB8fCByZXN1bHRbMF0ucmVmaW5lbWVudCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdub3RfdmFsaWQnXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdub3RfcmVmaW5lZCc7XG4gICAgICAgICAgICAgICAgeWllbGQgW3Jlc3VsdFswXSwgdW5kZWZpbmVkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvZXJjZSkge1xuICAgICAgICAgICAgICAgIGlubmVyVmFsdWUgPSByZXN1bHRbMV07XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaW5uZXJWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2V0KGlubmVyS2V5LCBpbm5lclZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuYWRkKGlubmVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyVmFsdWUgIT09IHVuZGVmaW5lZCB8fCBpbm5lcktleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbaW5uZXJLZXldID0gaW5uZXJWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdHVzICE9PSAnbm90X3ZhbGlkJykge1xuICAgICAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnJlZmluZXIodmFsdWUsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICBmYWlsdXJlLmV4cGxhbmF0aW9uID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgICAgICAgc3RhdHVzID0gJ25vdF9yZWZpbmVkJztcbiAgICAgICAgICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09ICd2YWxpZCcpIHtcbiAgICAgICAgeWllbGQgW3VuZGVmaW5lZCwgdmFsdWVdO1xuICAgIH1cbn1cbmV4cG9ydHMucnVuID0gcnVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/superstruct/dist/utils.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/assert.cjs":
/*!******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/assert.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nconst errors_1 = __webpack_require__(/*! ./errors.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/errors.cjs\");\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */\nfunction isConstructable(fn) {\n    /* istanbul ignore next */\n    return Boolean(typeof fn?.prototype?.constructor?.name === 'string');\n}\n/**\n * Attempts to obtain the message from a possible error object. If it is\n * possible to do so, any trailing period will be removed from the message;\n * otherwise an empty string is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The message without any trailing period if `error` is an object\n * with a `message` property; the string version of `error` without any trailing\n * period if it is not `undefined` or `null`; otherwise an empty string.\n */\nfunction getErrorMessageWithoutTrailingPeriod(error) {\n    // We'll add our own period.\n    return (0, errors_1.getErrorMessage)(error).replace(/\\.$/u, '');\n}\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper, message) {\n    if (isConstructable(ErrorWrapper)) {\n        return new ErrorWrapper({\n            message,\n        });\n    }\n    return ErrorWrapper({\n        message,\n    });\n}\n/**\n * The default error class that is thrown if an assertion fails.\n */\nclass AssertionError extends Error {\n    constructor(options) {\n        super(options.message);\n        this.code = 'ERR_ASSERTION';\n    }\n}\nexports.AssertionError = AssertionError;\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */\nfunction assert(value, message = 'Assertion failed.', \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    if (!value) {\n        if (message instanceof Error) {\n            throw message;\n        }\n        throw getError(ErrorWrapper, message);\n    }\n}\nexports.assert = assert;\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */\nfunction assertStruct(value, struct, errorPrefix = 'Assertion failed', \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    try {\n        (0, superstruct_1.assert)(value, struct);\n    }\n    catch (error) {\n        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`);\n    }\n}\nexports.assertStruct = assertStruct;\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */\nfunction assertExhaustive(_object) {\n    throw new Error('Invalid branch reached. Should be detected during compilation.');\n}\nexports.assertExhaustive = assertExhaustive;\n//# sourceMappingURL=assert.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYXNzZXJ0LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRyxjQUFjLEdBQUcsc0JBQXNCO0FBQ3pGLHNCQUFzQixtQkFBTyxDQUFDLHdGQUF1QjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQSw2Q0FBNkMsc0JBQXNCO0FBQ25FLElBQUksYUFBYTtBQUNqQjtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZLElBQUksNENBQTRDO0FBQ3BHO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYXNzZXJ0LmNqcz84YWQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRFeGhhdXN0aXZlID0gZXhwb3J0cy5hc3NlcnRTdHJ1Y3QgPSBleHBvcnRzLmFzc2VydCA9IGV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzLmNqc1wiKTtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGNvbnN0cnVjdG9yLCBpLmUuLCBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB3aXRoXG4gKiB0aGUgYG5ld2Aga2V5d29yZC5cbiAqXG4gKiBAcGFyYW0gZm4gLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgY29uc3RydWN0b3IsIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0NvbnN0cnVjdGFibGUoZm4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiBCb29sZWFuKHR5cGVvZiBmbj8ucHJvdG90eXBlPy5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ3N0cmluZycpO1xufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBvYnRhaW4gdGhlIG1lc3NhZ2UgZnJvbSBhIHBvc3NpYmxlIGVycm9yIG9iamVjdC4gSWYgaXQgaXNcbiAqIHBvc3NpYmxlIHRvIGRvIHNvLCBhbnkgdHJhaWxpbmcgcGVyaW9kIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBtZXNzYWdlO1xuICogb3RoZXJ3aXNlIGFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3Igb2JqZWN0IHRvIGdldCB0aGUgbWVzc2FnZSBmcm9tLlxuICogQHJldHVybnMgVGhlIG1lc3NhZ2Ugd2l0aG91dCBhbnkgdHJhaWxpbmcgcGVyaW9kIGlmIGBlcnJvcmAgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIGEgYG1lc3NhZ2VgIHByb3BlcnR5OyB0aGUgc3RyaW5nIHZlcnNpb24gb2YgYGVycm9yYCB3aXRob3V0IGFueSB0cmFpbGluZ1xuICogcGVyaW9kIGlmIGl0IGlzIG5vdCBgdW5kZWZpbmVkYCBvciBgbnVsbGA7IG90aGVyd2lzZSBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZVdpdGhvdXRUcmFpbGluZ1BlcmlvZChlcnJvcikge1xuICAgIC8vIFdlJ2xsIGFkZCBvdXIgb3duIHBlcmlvZC5cbiAgICByZXR1cm4gKDAsIGVycm9yc18xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IpLnJlcGxhY2UoL1xcLiQvdSwgJycpO1xufVxuLyoqXG4gKiBJbml0aWFsaXNlIGFuIHtAbGluayBBc3NlcnRpb25FcnJvckNvbnN0cnVjdG9yfSBlcnJvci5cbiAqXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHVzZS5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBUaGUgZXJyb3Igb2JqZWN0LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5mdW5jdGlvbiBnZXRFcnJvcihFcnJvcldyYXBwZXIsIG1lc3NhZ2UpIHtcbiAgICBpZiAoaXNDb25zdHJ1Y3RhYmxlKEVycm9yV3JhcHBlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcldyYXBwZXIoe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBFcnJvcldyYXBwZXIoe1xuICAgICAgICBtZXNzYWdlLFxuICAgIH0pO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBlcnJvciBjbGFzcyB0aGF0IGlzIHRocm93biBpZiBhbiBhc3NlcnRpb24gZmFpbHMuXG4gKi9cbmNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcbi8qKlxuICogU2FtZSBhcyBOb2RlLmpzIGFzc2VydC5cbiAqIElmIHRoZSB2YWx1ZSBpcyBmYWxzeSwgdGhyb3dzIGFuIGVycm9yLCBkb2VzIG5vdGhpbmcgb3RoZXJ3aXNlLlxuICpcbiAqIEB0aHJvd3Mge0BsaW5rIEFzc2VydGlvbkVycm9yfSBJZiB2YWx1ZSBpcyBmYWxzeS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB0ZXN0IHRoYXQgc2hvdWxkIGJlIHRydXRoeSB0byBwYXNzLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBNZXNzYWdlIHRvIGJlIHBhc3NlZCB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9IG9yIGFuXG4gKiB7QGxpbmsgRXJyb3J9IGluc3RhbmNlIHRvIHRocm93LlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS4gSWYgYSBjdXN0b20gZXJyb3IgY2xhc3MgaXMgcHJvdmlkZWQgZm9yXG4gKiB0aGUgYG1lc3NhZ2VgIGFyZ3VtZW50LCB0aGlzIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgbWVzc2FnZSA9ICdBc3NlcnRpb24gZmFpbGVkLicsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbi8qKlxuICogQXNzZXJ0IGEgdmFsdWUgYWdhaW5zdCBhIFN1cGVyc3RydWN0IHN0cnVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gc3RydWN0IC0gVGhlIHN0cnVjdCB0byB2YWxpZGF0ZSBhZ2FpbnN0LlxuICogQHBhcmFtIGVycm9yUHJlZml4IC0gQSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciBtZXNzYWdlLiBEZWZhdWx0cyB0b1xuICogXCJBc3NlcnRpb24gZmFpbGVkXCIuXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRTdHJ1Y3QodmFsdWUsIHN0cnVjdCwgZXJyb3JQcmVmaXggPSAnQXNzZXJ0aW9uIGZhaWxlZCcsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgICAoMCwgc3VwZXJzdHJ1Y3RfMS5hc3NlcnQpKHZhbHVlLCBzdHJ1Y3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBgJHtlcnJvclByZWZpeH06ICR7Z2V0RXJyb3JNZXNzYWdlV2l0aG91dFRyYWlsaW5nUGVyaW9kKGVycm9yKX0uYCk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRTdHJ1Y3QgPSBhc3NlcnRTdHJ1Y3Q7XG4vKipcbiAqIFVzZSBpbiB0aGUgZGVmYXVsdCBjYXNlIG9mIGEgc3dpdGNoIHRoYXQgeW91IHdhbnQgdG8gYmUgZnVsbHkgZXhoYXVzdGl2ZS5cbiAqIFVzaW5nIHRoaXMgZnVuY3Rpb24gZm9yY2VzIHRoZSBjb21waWxlciB0byBlbmZvcmNlIGV4aGF1c3Rpdml0eSBkdXJpbmdcbiAqIGNvbXBpbGUtdGltZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCBudW1iZXIgPSAxO1xuICogc3dpdGNoIChudW1iZXIpIHtcbiAqICAgY2FzZSAwOlxuICogICAgIC4uLlxuICogICBjYXNlIDE6XG4gKiAgICAgLi4uXG4gKiAgIGRlZmF1bHQ6XG4gKiAgICAgYXNzZXJ0RXhoYXVzdGl2ZShzbmFwUHJlZml4KTtcbiAqIH1cbiAqIGBgYFxuICogQHBhcmFtIF9vYmplY3QgLSBUaGUgb2JqZWN0IG9uIHdoaWNoIHRoZSBzd2l0Y2ggaXMgYmVpbmcgb3BlcmF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEV4aGF1c3RpdmUoX29iamVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBicmFuY2ggcmVhY2hlZC4gU2hvdWxkIGJlIGRldGVjdGVkIGR1cmluZyBjb21waWxhdGlvbi4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0RXhoYXVzdGl2ZSA9IGFzc2VydEV4aGF1c3RpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/assert.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/base64.cjs":
/*!******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/base64.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.base64 = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/assert.cjs\");\n/**\n * Ensure that a provided string-based struct is valid base64.\n *\n * @param struct - The string based struct.\n * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.\n * @returns A superstruct validating base64.\n */\nconst base64 = (struct, options = {}) => {\n    const paddingRequired = options.paddingRequired ?? false;\n    const characterSet = options.characterSet ?? 'base64';\n    let letters;\n    if (characterSet === 'base64') {\n        letters = String.raw `[A-Za-z0-9+\\/]`;\n    }\n    else {\n        (0, assert_1.assert)(characterSet === 'base64url');\n        letters = String.raw `[-_A-Za-z0-9]`;\n    }\n    let re;\n    if (paddingRequired) {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, 'u');\n    }\n    else {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, 'u');\n    }\n    return (0, superstruct_1.pattern)(struct, re);\n};\nexports.base64 = base64;\n//# sourceMappingURL=base64.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYmFzZTY0LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2Qsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQXVCO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLDBFQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHFCQUFxQjtBQUNoRztBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTLEVBQUUsT0FBTyxTQUFTLEVBQUUsSUFBSSxTQUFTLEVBQUU7QUFDM0U7QUFDQTtBQUNBLCtCQUErQixTQUFTLEVBQUUsT0FBTyxTQUFTLElBQUksR0FBRyxTQUFTLEVBQUUsSUFBSSxTQUFTLEVBQUU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Jhc2U2NC5janM/ODM5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFzZTY0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydC5janNcIik7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgcHJvdmlkZWQgc3RyaW5nLWJhc2VkIHN0cnVjdCBpcyB2YWxpZCBiYXNlNjQuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJpbmcgYmFzZWQgc3RydWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIHRvIHNwZWNpYWxpemUgYmFzZTY0IHZhbGlkYXRpb24uIFNlZSB7QGxpbmsgQmFzZTY0T3B0aW9uc30gZG9jdW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIEEgc3VwZXJzdHJ1Y3QgdmFsaWRhdGluZyBiYXNlNjQuXG4gKi9cbmNvbnN0IGJhc2U2NCA9IChzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHBhZGRpbmdSZXF1aXJlZCA9IG9wdGlvbnMucGFkZGluZ1JlcXVpcmVkID8/IGZhbHNlO1xuICAgIGNvbnN0IGNoYXJhY3RlclNldCA9IG9wdGlvbnMuY2hhcmFjdGVyU2V0ID8/ICdiYXNlNjQnO1xuICAgIGxldCBsZXR0ZXJzO1xuICAgIGlmIChjaGFyYWN0ZXJTZXQgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbQS1aYS16MC05K1xcL11gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoY2hhcmFjdGVyU2V0ID09PSAnYmFzZTY0dXJsJyk7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbLV9BLVphLXowLTldYDtcbiAgICB9XG4gICAgbGV0IHJlO1xuICAgIGlmIChwYWRkaW5nUmVxdWlyZWQpIHtcbiAgICAgICAgcmUgPSBuZXcgUmVnRXhwKGBeKD86JHtsZXR0ZXJzfXs0fSkqKD86JHtsZXR0ZXJzfXszfT18JHtsZXR0ZXJzfXsyfT09KT8kYCwgJ3UnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlID0gbmV3IFJlZ0V4cChgXig/OiR7bGV0dGVyc317NH0pKig/OiR7bGV0dGVyc317MiwzfXwke2xldHRlcnN9ezN9PXwke2xldHRlcnN9ezJ9PT0pPyRgLCAndScpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoc3RydWN0LCByZSk7XG59O1xuZXhwb3J0cy5iYXNlNjQgPSBiYXNlNjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/base64.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/bytes.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/bytes.cjs ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createDataView = exports.concatBytes = exports.valueToBytes = exports.base64ToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToBase64 = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;\nconst base_1 = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/index.js\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/assert.cjs\");\nconst hex_1 = __webpack_require__(/*! ./hex.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/hex.cjs\");\n// '0'.charCodeAt(0) === 48\nconst HEX_MINIMUM_NUMBER_CHARACTER = 48;\n// '9'.charCodeAt(0) === 57\nconst HEX_MAXIMUM_NUMBER_CHARACTER = 58;\nconst HEX_CHARACTER_OFFSET = 87;\n/**\n * Memoized function that returns an array to be used as a lookup table for\n * converting bytes to hexadecimal values.\n *\n * The array is created lazily and then cached for future use. The benefit of\n * this approach is that the performance of converting bytes to hex is much\n * better than if we were to call `toString(16)` on each byte.\n *\n * The downside is that the array is created once and then never garbage\n * collected. This is not a problem in practice because the array is only 256\n * elements long.\n *\n * @returns A function that returns the lookup table.\n */\nfunction getPrecomputedHexValuesBuilder() {\n    // To avoid issues with tree shaking, we need to use a function to return the\n    // array. This is because the array is only used in the `bytesToHex` function\n    // and if we were to use a global variable, the array might be removed by the\n    // tree shaker.\n    const lookupTable = [];\n    return () => {\n        if (lookupTable.length === 0) {\n            for (let i = 0; i < 256; i++) {\n                lookupTable.push(i.toString(16).padStart(2, '0'));\n            }\n        }\n        return lookupTable;\n    };\n}\n/**\n * Function implementation of the {@link getPrecomputedHexValuesBuilder}\n * function.\n */\nconst getPrecomputedHexValues = getPrecomputedHexValuesBuilder();\n/**\n * Check if a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @returns Whether the value is a `Uint8Array`.\n */\nfunction isBytes(value) {\n    return value instanceof Uint8Array;\n}\nexports.isBytes = isBytes;\n/**\n * Assert that a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @throws If the value is not a `Uint8Array`.\n */\nfunction assertIsBytes(value) {\n    (0, assert_1.assert)(isBytes(value), 'Value must be a Uint8Array.');\n}\nexports.assertIsBytes = assertIsBytes;\n/**\n * Convert a `Uint8Array` to a hexadecimal string.\n *\n * @param bytes - The bytes to convert to a hexadecimal string.\n * @returns The hexadecimal string.\n */\nfunction bytesToHex(bytes) {\n    assertIsBytes(bytes);\n    if (bytes.length === 0) {\n        return '0x';\n    }\n    const lookupTable = getPrecomputedHexValues();\n    const hexadecimal = new Array(bytes.length);\n    for (let i = 0; i < bytes.length; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        hexadecimal[i] = lookupTable[bytes[i]];\n    }\n    return (0, hex_1.add0x)(hexadecimal.join(''));\n}\nexports.bytesToHex = bytesToHex;\n/**\n * Convert a `Uint8Array` to a `bigint`.\n *\n * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.\n * To convert a two's complement encoded `Uint8Array` to a `bigint`, use\n * {@link bytesToSignedBigInt}.\n *\n * @param bytes - The bytes to convert to a `bigint`.\n * @returns The `bigint`.\n */\nfunction bytesToBigInt(bytes) {\n    assertIsBytes(bytes);\n    const hexadecimal = bytesToHex(bytes);\n    return BigInt(hexadecimal);\n}\nexports.bytesToBigInt = bytesToBigInt;\n/**\n * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are\n * encoded in two's complement.\n *\n * To convert a `Uint8Array` to an unsigned `bigint` instead, use\n * {@link bytesToBigInt}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param bytes - The bytes to convert to a signed `bigint`.\n * @returns The signed `bigint`.\n */\nfunction bytesToSignedBigInt(bytes) {\n    assertIsBytes(bytes);\n    let value = BigInt(0);\n    for (const byte of bytes) {\n        // eslint-disable-next-line no-bitwise\n        value = (value << BigInt(8)) + BigInt(byte);\n    }\n    return BigInt.asIntN(bytes.length * 8, value);\n}\nexports.bytesToSignedBigInt = bytesToSignedBigInt;\n/**\n * Convert a `Uint8Array` to a `number`.\n *\n * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.\n *\n * @param bytes - The bytes to convert to a number.\n * @returns The number.\n * @throws If the resulting number is not a safe integer.\n */\nfunction bytesToNumber(bytes) {\n    assertIsBytes(bytes);\n    const bigint = bytesToBigInt(bytes);\n    (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');\n    return Number(bigint);\n}\nexports.bytesToNumber = bytesToNumber;\n/**\n * Convert a UTF-8 encoded `Uint8Array` to a `string`.\n *\n * @param bytes - The bytes to convert to a string.\n * @returns The string.\n */\nfunction bytesToString(bytes) {\n    assertIsBytes(bytes);\n    return new TextDecoder().decode(bytes);\n}\nexports.bytesToString = bytesToString;\n/**\n * Convert a `Uint8Array` to a base64 encoded string.\n *\n * @param bytes - The bytes to convert to a base64 encoded string.\n * @returns The base64 encoded string.\n */\nfunction bytesToBase64(bytes) {\n    assertIsBytes(bytes);\n    return base_1.base64.encode(bytes);\n}\nexports.bytesToBase64 = bytesToBase64;\n/**\n * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be\n * prefixed with `0x`. It accepts even and odd length strings.\n *\n * If the value is \"0x\", an empty `Uint8Array` is returned.\n *\n * @param value - The hexadecimal string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction hexToBytes(value) {\n    // \"0x\" is often used as empty byte array.\n    if (value?.toLowerCase?.() === '0x') {\n        return new Uint8Array();\n    }\n    (0, hex_1.assertIsHexString)(value);\n    // Remove the `0x` prefix if it exists, and pad the string to have an even\n    // number of characters.\n    const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();\n    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;\n    const bytes = new Uint8Array(normalizedValue.length / 2);\n    for (let i = 0; i < bytes.length; i++) {\n        // While this is not the prettiest way to convert a hexadecimal string to a\n        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each\n        // character.\n        const c1 = normalizedValue.charCodeAt(i * 2);\n        const c2 = normalizedValue.charCodeAt(i * 2 + 1);\n        const n1 = c1 -\n            (c1 < HEX_MAXIMUM_NUMBER_CHARACTER\n                ? HEX_MINIMUM_NUMBER_CHARACTER\n                : HEX_CHARACTER_OFFSET);\n        const n2 = c2 -\n            (c2 < HEX_MAXIMUM_NUMBER_CHARACTER\n                ? HEX_MINIMUM_NUMBER_CHARACTER\n                : HEX_CHARACTER_OFFSET);\n        bytes[i] = n1 * 16 + n2;\n    }\n    return bytes;\n}\nexports.hexToBytes = hexToBytes;\n/**\n * Convert a `bigint` to a `Uint8Array`.\n *\n * This assumes that the `bigint` is an unsigned integer. To convert a signed\n * `bigint` instead, use {@link signedBigIntToBytes}.\n *\n * @param value - The bigint to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction bigIntToBytes(value) {\n    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');\n    (0, assert_1.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nexports.bigIntToBytes = bigIntToBytes;\n/**\n * Check if a `bigint` fits in a certain number of bytes.\n *\n * @param value - The `bigint` to check.\n * @param bytes - The number of bytes.\n * @returns Whether the `bigint` fits in the number of bytes.\n */\nfunction bigIntFits(value, bytes) {\n    (0, assert_1.assert)(bytes > 0);\n    /* eslint-disable no-bitwise */\n    const mask = value >> BigInt(31);\n    return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));\n    /* eslint-enable no-bitwise */\n}\n/**\n * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement\n * encoding to represent negative numbers.\n *\n * To convert an unsigned `bigint` to a `Uint8Array` instead, use\n * {@link bigIntToBytes}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param value - The number to convert to bytes.\n * @param byteLength - The length of the resulting `Uint8Array`. If the number\n * is larger than the maximum value that can be represented by the given length,\n * an error is thrown.\n * @returns The bytes as `Uint8Array`.\n */\nfunction signedBigIntToBytes(value, byteLength) {\n    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');\n    (0, assert_1.assert)(typeof byteLength === 'number', 'Byte length must be a number.');\n    (0, assert_1.assert)(byteLength > 0, 'Byte length must be greater than 0.');\n    (0, assert_1.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');\n    // ESLint doesn't like mutating function parameters, so to avoid having to\n    // disable the rule, we create a new variable.\n    let numberValue = value;\n    const bytes = new Uint8Array(byteLength);\n    for (let i = 0; i < bytes.length; i++) {\n        bytes[i] = Number(BigInt.asUintN(8, numberValue));\n        // eslint-disable-next-line no-bitwise\n        numberValue >>= BigInt(8);\n    }\n    return bytes.reverse();\n}\nexports.signedBigIntToBytes = signedBigIntToBytes;\n/**\n * Convert a `number` to a `Uint8Array`.\n *\n * @param value - The number to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n * @throws If the number is not a safe integer.\n */\nfunction numberToBytes(value) {\n    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');\n    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');\n    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nexports.numberToBytes = numberToBytes;\n/**\n * Convert a `string` to a UTF-8 encoded `Uint8Array`.\n *\n * @param value - The string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction stringToBytes(value) {\n    (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');\n    return new TextEncoder().encode(value);\n}\nexports.stringToBytes = stringToBytes;\n/**\n * Convert a base64 encoded string to a `Uint8Array`.\n *\n * @param value - The base64 encoded string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction base64ToBytes(value) {\n    (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');\n    return base_1.base64.decode(value);\n}\nexports.base64ToBytes = base64ToBytes;\n/**\n * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,\n * a `bigint`, a `number`, or a `string`.\n *\n * This will attempt to guess the type of the value based on its type and\n * contents. For more control over the conversion, use the more specific\n * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.\n *\n * If the value is a `string`, and it is prefixed with `0x`, it will be\n * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a\n * UTF-8 string. To convert a hexadecimal string to bytes without interpreting\n * it as a UTF-8 string, use {@link hexToBytes} instead.\n *\n * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed\n * `bigint` to bytes, use {@link signedBigIntToBytes} instead.\n *\n * If the value is a `Uint8Array`, it will be returned as-is.\n *\n * @param value - The value to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nfunction valueToBytes(value) {\n    if (typeof value === 'bigint') {\n        return bigIntToBytes(value);\n    }\n    if (typeof value === 'number') {\n        return numberToBytes(value);\n    }\n    if (typeof value === 'string') {\n        if (value.startsWith('0x')) {\n            return hexToBytes(value);\n        }\n        return stringToBytes(value);\n    }\n    if (isBytes(value)) {\n        return value;\n    }\n    throw new TypeError(`Unsupported value type: \"${typeof value}\".`);\n}\nexports.valueToBytes = valueToBytes;\n/**\n * Concatenate multiple byte-like values into a single `Uint8Array`. The values\n * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses\n * {@link valueToBytes} under the hood to convert each value to bytes. Refer to\n * the documentation of that function for more information.\n *\n * @param values - The values to concatenate.\n * @returns The concatenated bytes as `Uint8Array`.\n */\nfunction concatBytes(values) {\n    const normalizedValues = new Array(values.length);\n    let byteLength = 0;\n    for (let i = 0; i < values.length; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const value = valueToBytes(values[i]);\n        normalizedValues[i] = value;\n        byteLength += value.length;\n    }\n    const bytes = new Uint8Array(byteLength);\n    for (let i = 0, offset = 0; i < normalizedValues.length; i++) {\n        // While we could simply spread the values into an array and use\n        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.\n        bytes.set(normalizedValues[i], offset);\n        offset += normalizedValues[i].length;\n    }\n    return bytes;\n}\nexports.concatBytes = concatBytes;\n/**\n * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience\n * function that avoids having to create a {@link DataView} manually, which\n * requires passing the `byteOffset` and `byteLength` parameters every time.\n *\n * Not passing the `byteOffset` and `byteLength` parameters can result in\n * unexpected behavior when the {@link Uint8Array} is a view of a larger\n * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.\n *\n * This function also supports Node.js {@link Buffer}s.\n *\n * @example\n * ```typescript\n * const bytes = new Uint8Array([1, 2, 3]);\n *\n * // This is equivalent to:\n * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n * const dataView = createDataView(bytes);\n * ```\n * @param bytes - The bytes to create the {@link DataView} from.\n * @returns The {@link DataView}.\n */\nfunction createDataView(bytes) {\n    // To maintain compatibility with Node.js, we need to check if the bytes are\n    // a Buffer. If so, we need to slice the buffer to get the underlying\n    // ArrayBuffer.\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {\n        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);\n        return new DataView(buffer);\n    }\n    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n}\nexports.createDataView = createDataView;\n//# sourceMappingURL=bytes.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYnl0ZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLDJCQUEyQixHQUFHLHFCQUFxQixHQUFHLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLDJCQUEyQixHQUFHLHFCQUFxQixHQUFHLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHLGVBQWU7QUFDblosZUFBZSxtQkFBTyxDQUFDLGtFQUFhO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFjO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxvQkFBb0I7QUFDN0U7QUFDQSxJQUFJLDBCQUEwQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EseURBQXlELG9CQUFvQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixjQUFjO0FBQy9GO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0IsSUFBSSxvQkFBb0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakU7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvQkFBb0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZCQUE2QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGFBQWEsZ0JBQWdCLFFBQVEsaUJBQWlCO0FBQ3RELDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRCxJQUFJLGtCQUFrQixvQkFBb0IsMEJBQTBCO0FBQ3BFO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRCxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYnl0ZXMuY2pzPzA4MWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZURhdGFWaWV3ID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudmFsdWVUb0J5dGVzID0gZXhwb3J0cy5iYXNlNjRUb0J5dGVzID0gZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gZXhwb3J0cy5udW1iZXJUb0J5dGVzID0gZXhwb3J0cy5zaWduZWRCaWdJbnRUb0J5dGVzID0gZXhwb3J0cy5iaWdJbnRUb0J5dGVzID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5ieXRlc1RvQmFzZTY0ID0gZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gZXhwb3J0cy5ieXRlc1RvTnVtYmVyID0gZXhwb3J0cy5ieXRlc1RvU2lnbmVkQmlnSW50ID0gZXhwb3J0cy5ieXRlc1RvQmlnSW50ID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5hc3NlcnRJc0J5dGVzID0gZXhwb3J0cy5pc0J5dGVzID0gdm9pZCAwO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIkBzY3VyZS9iYXNlXCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnQuY2pzXCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXguY2pzXCIpO1xuLy8gJzAnLmNoYXJDb2RlQXQoMCkgPT09IDQ4XG5jb25zdCBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSID0gNDg7XG4vLyAnOScuY2hhckNvZGVBdCgwKSA9PT0gNTdcbmNvbnN0IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVIgPSA1ODtcbmNvbnN0IEhFWF9DSEFSQUNURVJfT0ZGU0VUID0gODc7XG4vKipcbiAqIE1lbW9pemVkIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheSB0byBiZSB1c2VkIGFzIGEgbG9va3VwIHRhYmxlIGZvclxuICogY29udmVydGluZyBieXRlcyB0byBoZXhhZGVjaW1hbCB2YWx1ZXMuXG4gKlxuICogVGhlIGFycmF5IGlzIGNyZWF0ZWQgbGF6aWx5IGFuZCB0aGVuIGNhY2hlZCBmb3IgZnV0dXJlIHVzZS4gVGhlIGJlbmVmaXQgb2ZcbiAqIHRoaXMgYXBwcm9hY2ggaXMgdGhhdCB0aGUgcGVyZm9ybWFuY2Ugb2YgY29udmVydGluZyBieXRlcyB0byBoZXggaXMgbXVjaFxuICogYmV0dGVyIHRoYW4gaWYgd2Ugd2VyZSB0byBjYWxsIGB0b1N0cmluZygxNilgIG9uIGVhY2ggYnl0ZS5cbiAqXG4gKiBUaGUgZG93bnNpZGUgaXMgdGhhdCB0aGUgYXJyYXkgaXMgY3JlYXRlZCBvbmNlIGFuZCB0aGVuIG5ldmVyIGdhcmJhZ2VcbiAqIGNvbGxlY3RlZC4gVGhpcyBpcyBub3QgYSBwcm9ibGVtIGluIHByYWN0aWNlIGJlY2F1c2UgdGhlIGFycmF5IGlzIG9ubHkgMjU2XG4gKiBlbGVtZW50cyBsb25nLlxuICpcbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBsb29rdXAgdGFibGUuXG4gKi9cbmZ1bmN0aW9uIGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpIHtcbiAgICAvLyBUbyBhdm9pZCBpc3N1ZXMgd2l0aCB0cmVlIHNoYWtpbmcsIHdlIG5lZWQgdG8gdXNlIGEgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZVxuICAgIC8vIGFycmF5LiBUaGlzIGlzIGJlY2F1c2UgdGhlIGFycmF5IGlzIG9ubHkgdXNlZCBpbiB0aGUgYGJ5dGVzVG9IZXhgIGZ1bmN0aW9uXG4gICAgLy8gYW5kIGlmIHdlIHdlcmUgdG8gdXNlIGEgZ2xvYmFsIHZhcmlhYmxlLCB0aGUgYXJyYXkgbWlnaHQgYmUgcmVtb3ZlZCBieSB0aGVcbiAgICAvLyB0cmVlIHNoYWtlci5cbiAgICBjb25zdCBsb29rdXBUYWJsZSA9IFtdO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChsb29rdXBUYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsb29rdXBUYWJsZS5wdXNoKGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb29rdXBUYWJsZTtcbiAgICB9O1xufVxuLyoqXG4gKiBGdW5jdGlvbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUge0BsaW5rIGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcn1cbiAqIGZ1bmN0aW9uLlxuICovXG5jb25zdCBnZXRQcmVjb21wdXRlZEhleFZhbHVlcyA9IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpO1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBpc0J5dGVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheTtcbn1cbmV4cG9ydHMuaXNCeXRlcyA9IGlzQnl0ZXM7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoaXNCeXRlcyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgVWludDhBcnJheS4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNCeXRlcyA9IGFzc2VydElzQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJzB4JztcbiAgICB9XG4gICAgY29uc3QgbG9va3VwVGFibGUgPSBnZXRQcmVjb21wdXRlZEhleFZhbHVlcygpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gbmV3IEFycmF5KGJ5dGVzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBoZXhhZGVjaW1hbFtpXSA9IGxvb2t1cFRhYmxlW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkoaGV4YWRlY2ltYWwuam9pbignJykpO1xufVxuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgbnVtYmVyYCBpbnN0ZWFkLCB1c2Uge0BsaW5rIGJ5dGVzVG9OdW1iZXJ9LlxuICogVG8gY29udmVydCBhIHR3bydzIGNvbXBsZW1lbnQgZW5jb2RlZCBgVWludDhBcnJheWAgdG8gYSBgYmlnaW50YCwgdXNlXG4gKiB7QGxpbmsgYnl0ZXNUb1NpZ25lZEJpZ0ludH0uXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBgYmlnaW50YC5cbiAqIEByZXR1cm5zIFRoZSBgYmlnaW50YC5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0JpZ0ludChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gYnl0ZXNUb0hleChieXRlcyk7XG4gICAgcmV0dXJuIEJpZ0ludChoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLmJ5dGVzVG9CaWdJbnQgPSBieXRlc1RvQmlnSW50O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgc2lnbmVkIGBiaWdpbnRgLiBUaGlzIGFzc3VtZXMgdGhhdCB0aGUgYnl0ZXMgYXJlXG4gKiBlbmNvZGVkIGluIHR3bydzIGNvbXBsZW1lbnQuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhbiB1bnNpZ25lZCBgYmlnaW50YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBieXRlc1RvQmlnSW50fS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1R3byUyN3NfY29tcGxlbWVudFxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBzaWduZWQgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgc2lnbmVkIGBiaWdpbnRgLlxuICovXG5mdW5jdGlvbiBieXRlc1RvU2lnbmVkQmlnSW50KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgbGV0IHZhbHVlID0gQmlnSW50KDApO1xuICAgIGZvciAoY29uc3QgYnl0ZSBvZiBieXRlcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA8PCBCaWdJbnQoOCkpICsgQmlnSW50KGJ5dGUpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50LmFzSW50TihieXRlcy5sZW5ndGggKiA4LCB2YWx1ZSk7XG59XG5leHBvcnRzLmJ5dGVzVG9TaWduZWRCaWdJbnQgPSBieXRlc1RvU2lnbmVkQmlnSW50O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYG51bWJlcmAuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgIGluc3RlYWQsIHVzZSB7QGxpbmsgYnl0ZXNUb0JpZ0ludH0uXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgcmVzdWx0aW5nIG51bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXIoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBjb25zdCBiaWdpbnQgPSBieXRlc1RvQmlnSW50KGJ5dGVzKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShiaWdpbnQgPD0gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSwgJ051bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYnl0ZXNUb0JpZ0ludGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gTnVtYmVyKGJpZ2ludCk7XG59XG5leHBvcnRzLmJ5dGVzVG9OdW1iZXIgPSBieXRlc1RvTnVtYmVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgVVRGLTggZW5jb2RlZCBgVWludDhBcnJheWAgdG8gYSBgc3RyaW5nYC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGJ5dGVzVG9TdHJpbmc7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBieXRlc1RvQmFzZTY0KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIGJhc2VfMS5iYXNlNjQuZW5jb2RlKGJ5dGVzKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb0Jhc2U2NCA9IGJ5dGVzVG9CYXNlNjQ7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgVWludDhBcnJheWAuIFRoZSBzdHJpbmcgY2FuIG9wdGlvbmFsbHkgYmVcbiAqIHByZWZpeGVkIHdpdGggYDB4YC4gSXQgYWNjZXB0cyBldmVuIGFuZCBvZGQgbGVuZ3RoIHN0cmluZ3MuXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIFwiMHhcIiwgYW4gZW1wdHkgYFVpbnQ4QXJyYXlgIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXModmFsdWUpIHtcbiAgICAvLyBcIjB4XCIgaXMgb2Z0ZW4gdXNlZCBhcyBlbXB0eSBieXRlIGFycmF5LlxuICAgIGlmICh2YWx1ZT8udG9Mb3dlckNhc2U/LigpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICAoMCwgaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmcpKHZhbHVlKTtcbiAgICAvLyBSZW1vdmUgdGhlIGAweGAgcHJlZml4IGlmIGl0IGV4aXN0cywgYW5kIHBhZCB0aGUgc3RyaW5nIHRvIGhhdmUgYW4gZXZlblxuICAgIC8vIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICAgIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSAoMCwgaGV4XzEucmVtb3ZlMHgpKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IHN0cmlwcGVkVmFsdWUubGVuZ3RoICUgMiA9PT0gMCA/IHN0cmlwcGVkVmFsdWUgOiBgMCR7c3RyaXBwZWRWYWx1ZX1gO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobm9ybWFsaXplZFZhbHVlLmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gV2hpbGUgdGhpcyBpcyBub3QgdGhlIHByZXR0aWVzdCB3YXkgdG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhXG4gICAgICAgIC8vIGBVaW50OEFycmF5YCwgaXQgaXMgYSBsb3QgZmFzdGVyIHRoYW4gdXNpbmcgYHBhcnNlSW50YCB0byBjb252ZXJ0IGVhY2hcbiAgICAgICAgLy8gY2hhcmFjdGVyLlxuICAgICAgICBjb25zdCBjMSA9IG5vcm1hbGl6ZWRWYWx1ZS5jaGFyQ29kZUF0KGkgKiAyKTtcbiAgICAgICAgY29uc3QgYzIgPSBub3JtYWxpemVkVmFsdWUuY2hhckNvZGVBdChpICogMiArIDEpO1xuICAgICAgICBjb25zdCBuMSA9IGMxIC1cbiAgICAgICAgICAgIChjMSA8IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA/IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVJcbiAgICAgICAgICAgICAgICA6IEhFWF9DSEFSQUNURVJfT0ZGU0VUKTtcbiAgICAgICAgY29uc3QgbjIgPSBjMiAtXG4gICAgICAgICAgICAoYzIgPCBIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgPyBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgOiBIRVhfQ0hBUkFDVEVSX09GRlNFVCk7XG4gICAgICAgIGJ5dGVzW2ldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAuXG4gKlxuICogVGhpcyBhc3N1bWVzIHRoYXQgdGhlIGBiaWdpbnRgIGlzIGFuIHVuc2lnbmVkIGludGVnZXIuIFRvIGNvbnZlcnQgYSBzaWduZWRcbiAqIGBiaWdpbnRgIGluc3RlYWQsIHVzZSB7QGxpbmsgc2lnbmVkQmlnSW50VG9CeXRlc30uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGJpZ2ludCB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmlnSW50VG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcsICdWYWx1ZSBtdXN0IGJlIGEgYmlnaW50LicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IEJpZ0ludCgwKSwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgYmlnaW50LicpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXhUb0J5dGVzKGhleGFkZWNpbWFsKTtcbn1cbmV4cG9ydHMuYmlnSW50VG9CeXRlcyA9IGJpZ0ludFRvQnl0ZXM7XG4vKipcbiAqIENoZWNrIGlmIGEgYGJpZ2ludGAgZml0cyBpbiBhIGNlcnRhaW4gbnVtYmVyIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBgYmlnaW50YCB0byBjaGVjay5cbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBgYmlnaW50YCBmaXRzIGluIHRoZSBudW1iZXIgb2YgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGJpZ0ludEZpdHModmFsdWUsIGJ5dGVzKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYnl0ZXMgPiAwKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgY29uc3QgbWFzayA9IHZhbHVlID4+IEJpZ0ludCgzMSk7XG4gICAgcmV0dXJuICEoKCh+dmFsdWUgJiBtYXNrKSArICh2YWx1ZSAmIH5tYXNrKSkgPj4gQmlnSW50KGJ5dGVzICogOCArIH4wKSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG59XG4vKipcbiAqIENvbnZlcnQgYSBzaWduZWQgYGJpZ2ludGAgdG8gYSBgVWludDhBcnJheWAuIFRoaXMgdXNlcyB0d28ncyBjb21wbGVtZW50XG4gKiBlbmNvZGluZyB0byByZXByZXNlbnQgbmVnYXRpdmUgbnVtYmVycy5cbiAqXG4gKiBUbyBjb252ZXJ0IGFuIHVuc2lnbmVkIGBiaWdpbnRgIHRvIGEgYFVpbnQ4QXJyYXlgIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGJpZ0ludFRvQnl0ZXN9LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdvJTI3c19jb21wbGVtZW50XG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcGFyYW0gYnl0ZUxlbmd0aCAtIFRoZSBsZW5ndGggb2YgdGhlIHJlc3VsdGluZyBgVWludDhBcnJheWAuIElmIHRoZSBudW1iZXJcbiAqIGlzIGxhcmdlciB0aGFuIHRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBsZW5ndGgsXG4gKiBhbiBlcnJvciBpcyB0aHJvd24uXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBzaWduZWRCaWdJbnRUb0J5dGVzKHZhbHVlLCBieXRlTGVuZ3RoKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JywgJ1ZhbHVlIG11c3QgYmUgYSBiaWdpbnQuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIGJ5dGVMZW5ndGggPT09ICdudW1iZXInLCAnQnl0ZSBsZW5ndGggbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShieXRlTGVuZ3RoID4gMCwgJ0J5dGUgbGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYmlnSW50Rml0cyh2YWx1ZSwgYnl0ZUxlbmd0aCksICdCeXRlIGxlbmd0aCBpcyB0b28gc21hbGwgdG8gcmVwcmVzZW50IHRoZSBnaXZlbiB2YWx1ZS4nKTtcbiAgICAvLyBFU0xpbnQgZG9lc24ndCBsaWtlIG11dGF0aW5nIGZ1bmN0aW9uIHBhcmFtZXRlcnMsIHNvIHRvIGF2b2lkIGhhdmluZyB0b1xuICAgIC8vIGRpc2FibGUgdGhlIHJ1bGUsIHdlIGNyZWF0ZSBhIG5ldyB2YXJpYWJsZS5cbiAgICBsZXQgbnVtYmVyVmFsdWUgPSB2YWx1ZTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBOdW1iZXIoQmlnSW50LmFzVWludE4oOCwgbnVtYmVyVmFsdWUpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgbnVtYmVyVmFsdWUgPj49IEJpZ0ludCg4KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzLnJldmVyc2UoKTtcbn1cbmV4cG9ydHMuc2lnbmVkQmlnSW50VG9CeXRlcyA9IHNpZ25lZEJpZ0ludFRvQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgbnVtYmVyYCB0byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICogQHRocm93cyBJZiB0aGUgbnVtYmVyIGlzIG5vdCBhIHNhZmUgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdWYWx1ZSBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IDAsICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSksICdWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYmlnSW50VG9CeXRlc2AgaW5zdGVhZC4nKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLm51bWJlclRvQnl0ZXMgPSBudW1iZXJUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYHN0cmluZ2AgdG8gYSBVVEYtOCBlbmNvZGVkIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJywgJ1ZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG59XG5leHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLCAnVmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICByZXR1cm4gYmFzZV8xLmJhc2U2NC5kZWNvZGUodmFsdWUpO1xufVxuZXhwb3J0cy5iYXNlNjRUb0J5dGVzID0gYmFzZTY0VG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGJ5dGUtbGlrZSB2YWx1ZSB0byBhIGBVaW50OEFycmF5YC4gVGhlIHZhbHVlIGNhbiBiZSBhIGBVaW50OEFycmF5YCxcbiAqIGEgYGJpZ2ludGAsIGEgYG51bWJlcmAsIG9yIGEgYHN0cmluZ2AuXG4gKlxuICogVGhpcyB3aWxsIGF0dGVtcHQgdG8gZ3Vlc3MgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIGJhc2VkIG9uIGl0cyB0eXBlIGFuZFxuICogY29udGVudHMuIEZvciBtb3JlIGNvbnRyb2wgb3ZlciB0aGUgY29udmVyc2lvbiwgdXNlIHRoZSBtb3JlIHNwZWNpZmljXG4gKiBjb252ZXJzaW9uIGZ1bmN0aW9ucywgc3VjaCBhcyB7QGxpbmsgaGV4VG9CeXRlc30gb3Ige0BsaW5rIHN0cmluZ1RvQnl0ZXN9LlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGBzdHJpbmdgLCBhbmQgaXQgaXMgcHJlZml4ZWQgd2l0aCBgMHhgLCBpdCB3aWxsIGJlXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIHN0cmluZy4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGludGVycHJldGVkIGFzIGFcbiAqIFVURi04IHN0cmluZy4gVG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBieXRlcyB3aXRob3V0IGludGVycHJldGluZ1xuICogaXQgYXMgYSBVVEYtOCBzdHJpbmcsIHVzZSB7QGxpbmsgaGV4VG9CeXRlc30gaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgYXNzdW1lZCB0byBiZSB1bnNpZ25lZC4gVG8gY29udmVydCBhIHNpZ25lZFxuICogYGJpZ2ludGAgdG8gYnl0ZXMsIHVzZSB7QGxpbmsgc2lnbmVkQmlnSW50VG9CeXRlc30gaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgVWludDhBcnJheWAsIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiB2YWx1ZVRvQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICByZXR1cm4gYmlnSW50VG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBudW1iZXJUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHZhbHVlIHR5cGU6IFwiJHt0eXBlb2YgdmFsdWV9XCIuYCk7XG59XG5leHBvcnRzLnZhbHVlVG9CeXRlcyA9IHZhbHVlVG9CeXRlcztcbi8qKlxuICogQ29uY2F0ZW5hdGUgbXVsdGlwbGUgYnl0ZS1saWtlIHZhbHVlcyBpbnRvIGEgc2luZ2xlIGBVaW50OEFycmF5YC4gVGhlIHZhbHVlc1xuICogY2FuIGJlIGBVaW50OEFycmF5YCwgYGJpZ2ludGAsIGBudW1iZXJgLCBvciBgc3RyaW5nYC4gVGhpcyB1c2VzXG4gKiB7QGxpbmsgdmFsdWVUb0J5dGVzfSB1bmRlciB0aGUgaG9vZCB0byBjb252ZXJ0IGVhY2ggdmFsdWUgdG8gYnl0ZXMuIFJlZmVyIHRvXG4gKiB0aGUgZG9jdW1lbnRhdGlvbiBvZiB0aGF0IGZ1bmN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKHZhbHVlcykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZXMgPSBuZXcgQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgbGV0IGJ5dGVMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVUb0J5dGVzKHZhbHVlc1tpXSk7XG4gICAgICAgIG5vcm1hbGl6ZWRWYWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgYnl0ZUxlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCBub3JtYWxpemVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFdoaWxlIHdlIGNvdWxkIHNpbXBseSBzcHJlYWQgdGhlIHZhbHVlcyBpbnRvIGFuIGFycmF5IGFuZCB1c2VcbiAgICAgICAgLy8gYFVpbnQ4QXJyYXkuZnJvbWAsIHRoYXQgaXMgYSBsb3Qgc2xvd2VyIHRoYW4gdXNpbmcgYFVpbnQ4QXJyYXkuc2V0YC5cbiAgICAgICAgYnl0ZXMuc2V0KG5vcm1hbGl6ZWRWYWx1ZXNbaV0sIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBub3JtYWxpemVkVmFsdWVzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuLyoqXG4gKiBDcmVhdGUgYSB7QGxpbmsgRGF0YVZpZXd9IGZyb20gYSB7QGxpbmsgVWludDhBcnJheX0uIFRoaXMgaXMgYSBjb252ZW5pZW5jZVxuICogZnVuY3Rpb24gdGhhdCBhdm9pZHMgaGF2aW5nIHRvIGNyZWF0ZSBhIHtAbGluayBEYXRhVmlld30gbWFudWFsbHksIHdoaWNoXG4gKiByZXF1aXJlcyBwYXNzaW5nIHRoZSBgYnl0ZU9mZnNldGAgYW5kIGBieXRlTGVuZ3RoYCBwYXJhbWV0ZXJzIGV2ZXJ5IHRpbWUuXG4gKlxuICogTm90IHBhc3NpbmcgdGhlIGBieXRlT2Zmc2V0YCBhbmQgYGJ5dGVMZW5ndGhgIHBhcmFtZXRlcnMgY2FuIHJlc3VsdCBpblxuICogdW5leHBlY3RlZCBiZWhhdmlvciB3aGVuIHRoZSB7QGxpbmsgVWludDhBcnJheX0gaXMgYSB2aWV3IG9mIGEgbGFyZ2VyXG4gKiB7QGxpbmsgQXJyYXlCdWZmZXJ9LCBlLmcuLCB3aGVuIHVzaW5nIHtAbGluayBVaW50OEFycmF5LnN1YmFycmF5fS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsc28gc3VwcG9ydHMgTm9kZS5qcyB7QGxpbmsgQnVmZmVyfXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKTtcbiAqXG4gKiAvLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG86XG4gKiAvLyBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICogY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVEYXRhVmlldyhieXRlcyk7XG4gKiBgYGBcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjcmVhdGUgdGhlIHtAbGluayBEYXRhVmlld30gZnJvbS5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgRGF0YVZpZXd9LlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYXRhVmlldyhieXRlcykge1xuICAgIC8vIFRvIG1haW50YWluIGNvbXBhdGliaWxpdHkgd2l0aCBOb2RlLmpzLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBieXRlcyBhcmVcbiAgICAvLyBhIEJ1ZmZlci4gSWYgc28sIHdlIG5lZWQgdG8gc2xpY2UgdGhlIGJ1ZmZlciB0byBnZXQgdGhlIHVuZGVybHlpbmdcbiAgICAvLyBBcnJheUJ1ZmZlci5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGJ5dGVzIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ5dGVzLmJ1ZmZlci5zbGljZShieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlT2Zmc2V0ICsgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xufVxuZXhwb3J0cy5jcmVhdGVEYXRhVmlldyA9IGNyZWF0ZURhdGFWaWV3O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/bytes.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/caip-types.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/caip-types.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toCaipChainId = exports.parseCaipAccountId = exports.parseCaipChainId = exports.isCaipAccountAddress = exports.isCaipAccountId = exports.isCaipReference = exports.isCaipNamespace = exports.isCaipChainId = exports.KnownCaipNamespace = exports.CaipAccountAddressStruct = exports.CaipAccountIdStruct = exports.CaipReferenceStruct = exports.CaipNamespaceStruct = exports.CaipChainIdStruct = exports.CAIP_ACCOUNT_ADDRESS_REGEX = exports.CAIP_ACCOUNT_ID_REGEX = exports.CAIP_REFERENCE_REGEX = exports.CAIP_NAMESPACE_REGEX = exports.CAIP_CHAIN_ID_REGEX = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nexports.CAIP_CHAIN_ID_REGEX = /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})$/u;\nexports.CAIP_NAMESPACE_REGEX = /^[-a-z0-9]{3,8}$/u;\nexports.CAIP_REFERENCE_REGEX = /^[-_a-zA-Z0-9]{1,32}$/u;\nexports.CAIP_ACCOUNT_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})):(?<accountAddress>[-.%a-zA-Z0-9]{1,128})$/u;\nexports.CAIP_ACCOUNT_ADDRESS_REGEX = /^[-.%a-zA-Z0-9]{1,128}$/u;\n/**\n * A CAIP-2 chain ID, i.e., a human-readable namespace and reference.\n */\nexports.CaipChainIdStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), exports.CAIP_CHAIN_ID_REGEX);\n/**\n * A CAIP-2 namespace, i.e., the first part of a CAIP chain ID.\n */\nexports.CaipNamespaceStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), exports.CAIP_NAMESPACE_REGEX);\n/**\n * A CAIP-2 reference, i.e., the second part of a CAIP chain ID.\n */\nexports.CaipReferenceStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), exports.CAIP_REFERENCE_REGEX);\n/**\n * A CAIP-10 account ID, i.e., a human-readable namespace, reference, and account address.\n */\nexports.CaipAccountIdStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), exports.CAIP_ACCOUNT_ID_REGEX);\n/**\n * A CAIP-10 account address, i.e., the third part of the CAIP account ID.\n */\nexports.CaipAccountAddressStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), exports.CAIP_ACCOUNT_ADDRESS_REGEX);\n/** Known CAIP namespaces. */\nvar KnownCaipNamespace;\n(function (KnownCaipNamespace) {\n    /** EIP-155 compatible chains. */\n    KnownCaipNamespace[\"Eip155\"] = \"eip155\";\n})(KnownCaipNamespace = exports.KnownCaipNamespace || (exports.KnownCaipNamespace = {}));\n/**\n * Check if the given value is a {@link CaipChainId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipChainId}.\n */\nfunction isCaipChainId(value) {\n    return (0, superstruct_1.is)(value, exports.CaipChainIdStruct);\n}\nexports.isCaipChainId = isCaipChainId;\n/**\n * Check if the given value is a {@link CaipNamespace}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipNamespace}.\n */\nfunction isCaipNamespace(value) {\n    return (0, superstruct_1.is)(value, exports.CaipNamespaceStruct);\n}\nexports.isCaipNamespace = isCaipNamespace;\n/**\n * Check if the given value is a {@link CaipReference}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipReference}.\n */\nfunction isCaipReference(value) {\n    return (0, superstruct_1.is)(value, exports.CaipReferenceStruct);\n}\nexports.isCaipReference = isCaipReference;\n/**\n * Check if the given value is a {@link CaipAccountId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAccountId}.\n */\nfunction isCaipAccountId(value) {\n    return (0, superstruct_1.is)(value, exports.CaipAccountIdStruct);\n}\nexports.isCaipAccountId = isCaipAccountId;\n/**\n * Check if a value is a {@link CaipAccountAddress}.\n *\n * @param value - The value to validate.\n * @returns True if the value is a valid {@link CaipAccountAddress}.\n */\nfunction isCaipAccountAddress(value) {\n    return (0, superstruct_1.is)(value, exports.CaipAccountAddressStruct);\n}\nexports.isCaipAccountAddress = isCaipAccountAddress;\n/**\n * Parse a CAIP-2 chain ID to an object containing the namespace and reference.\n * This validates the CAIP-2 chain ID before parsing it.\n *\n * @param caipChainId - The CAIP-2 chain ID to validate and parse.\n * @returns The parsed CAIP-2 chain ID.\n */\nfunction parseCaipChainId(caipChainId) {\n    const match = exports.CAIP_CHAIN_ID_REGEX.exec(caipChainId);\n    if (!match?.groups) {\n        throw new Error('Invalid CAIP chain ID.');\n    }\n    return {\n        namespace: match.groups.namespace,\n        reference: match.groups.reference,\n    };\n}\nexports.parseCaipChainId = parseCaipChainId;\n/**\n * Parse an CAIP-10 account ID to an object containing the chain ID, parsed chain ID, and account address.\n * This validates the CAIP-10 account ID before parsing it.\n *\n * @param caipAccountId - The CAIP-10 account ID to validate and parse.\n * @returns The parsed CAIP-10 account ID.\n */\nfunction parseCaipAccountId(caipAccountId) {\n    const match = exports.CAIP_ACCOUNT_ID_REGEX.exec(caipAccountId);\n    if (!match?.groups) {\n        throw new Error('Invalid CAIP account ID.');\n    }\n    return {\n        address: match.groups.accountAddress,\n        chainId: match.groups.chainId,\n        chain: {\n            namespace: match.groups.namespace,\n            reference: match.groups.reference,\n        },\n    };\n}\nexports.parseCaipAccountId = parseCaipAccountId;\n/**\n * Chain ID as defined per the CAIP-2\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md}.\n *\n * It defines a way to uniquely identify any blockchain in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identify of a blockchain within a given namespace.\n * @throws {@link Error}\n * This exception is thrown if the inputs does not comply with the CAIP-2\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md#syntax}.\n * @returns A CAIP chain ID.\n */\nfunction toCaipChainId(namespace, reference) {\n    if (!isCaipNamespace(namespace)) {\n        throw new Error(`Invalid \"namespace\", must match: ${exports.CAIP_NAMESPACE_REGEX.toString()}`);\n    }\n    if (!isCaipReference(reference)) {\n        throw new Error(`Invalid \"reference\", must match: ${exports.CAIP_REFERENCE_REGEX.toString()}`);\n    }\n    return `${namespace}:${reference}`;\n}\nexports.toCaipChainId = toCaipChainId;\n//# sourceMappingURL=caip-types.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2FpcC10eXBlcy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsMEJBQTBCLEdBQUcsd0JBQXdCLEdBQUcsNEJBQTRCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcscUJBQXFCLEdBQUcsMEJBQTBCLEdBQUcsZ0NBQWdDLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcseUJBQXlCLEdBQUcsa0NBQWtDLEdBQUcsNkJBQTZCLEdBQUcsNEJBQTRCLEdBQUcsNEJBQTRCLEdBQUcsMkJBQTJCO0FBQ3ppQixzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBdUI7QUFDckQsMkJBQTJCLDRCQUE0QixJQUFJLDZCQUE2QixLQUFLO0FBQzdGLDRCQUE0QixlQUFlLElBQUk7QUFDL0MsNEJBQTRCLG1CQUFtQixLQUFLO0FBQ3BELDZCQUE2Qix1Q0FBdUMsSUFBSSw2QkFBNkIsS0FBSyxvQ0FBb0MsTUFBTTtBQUNwSixrQ0FBa0Msb0JBQW9CLE1BQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0QsMEJBQTBCLEtBQUs7QUFDdEY7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0EsMENBQTBDLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxJQUFJLHVFQUF1RTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLElBQUksOEVBQThFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHdDQUF3QztBQUNwRztBQUNBO0FBQ0EsNERBQTRELHdDQUF3QztBQUNwRztBQUNBLGNBQWMsVUFBVSxHQUFHLFVBQVU7QUFDckM7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2FpcC10eXBlcy5janM/YmIyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9DYWlwQ2hhaW5JZCA9IGV4cG9ydHMucGFyc2VDYWlwQWNjb3VudElkID0gZXhwb3J0cy5wYXJzZUNhaXBDaGFpbklkID0gZXhwb3J0cy5pc0NhaXBBY2NvdW50QWRkcmVzcyA9IGV4cG9ydHMuaXNDYWlwQWNjb3VudElkID0gZXhwb3J0cy5pc0NhaXBSZWZlcmVuY2UgPSBleHBvcnRzLmlzQ2FpcE5hbWVzcGFjZSA9IGV4cG9ydHMuaXNDYWlwQ2hhaW5JZCA9IGV4cG9ydHMuS25vd25DYWlwTmFtZXNwYWNlID0gZXhwb3J0cy5DYWlwQWNjb3VudEFkZHJlc3NTdHJ1Y3QgPSBleHBvcnRzLkNhaXBBY2NvdW50SWRTdHJ1Y3QgPSBleHBvcnRzLkNhaXBSZWZlcmVuY2VTdHJ1Y3QgPSBleHBvcnRzLkNhaXBOYW1lc3BhY2VTdHJ1Y3QgPSBleHBvcnRzLkNhaXBDaGFpbklkU3RydWN0ID0gZXhwb3J0cy5DQUlQX0FDQ09VTlRfQUREUkVTU19SRUdFWCA9IGV4cG9ydHMuQ0FJUF9BQ0NPVU5UX0lEX1JFR0VYID0gZXhwb3J0cy5DQUlQX1JFRkVSRU5DRV9SRUdFWCA9IGV4cG9ydHMuQ0FJUF9OQU1FU1BBQ0VfUkVHRVggPSBleHBvcnRzLkNBSVBfQ0hBSU5fSURfUkVHRVggPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zdXBlcnN0cnVjdFwiKTtcbmV4cG9ydHMuQ0FJUF9DSEFJTl9JRF9SRUdFWCA9IC9eKD88bmFtZXNwYWNlPlstYS16MC05XXszLDh9KTooPzxyZWZlcmVuY2U+Wy1fYS16QS1aMC05XXsxLDMyfSkkL3U7XG5leHBvcnRzLkNBSVBfTkFNRVNQQUNFX1JFR0VYID0gL15bLWEtejAtOV17Myw4fSQvdTtcbmV4cG9ydHMuQ0FJUF9SRUZFUkVOQ0VfUkVHRVggPSAvXlstX2EtekEtWjAtOV17MSwzMn0kL3U7XG5leHBvcnRzLkNBSVBfQUNDT1VOVF9JRF9SRUdFWCA9IC9eKD88Y2hhaW5JZD4oPzxuYW1lc3BhY2U+Wy1hLXowLTldezMsOH0pOig/PHJlZmVyZW5jZT5bLV9hLXpBLVowLTldezEsMzJ9KSk6KD88YWNjb3VudEFkZHJlc3M+Wy0uJWEtekEtWjAtOV17MSwxMjh9KSQvdTtcbmV4cG9ydHMuQ0FJUF9BQ0NPVU5UX0FERFJFU1NfUkVHRVggPSAvXlstLiVhLXpBLVowLTldezEsMTI4fSQvdTtcbi8qKlxuICogQSBDQUlQLTIgY2hhaW4gSUQsIGkuZS4sIGEgaHVtYW4tcmVhZGFibGUgbmFtZXNwYWNlIGFuZCByZWZlcmVuY2UuXG4gKi9cbmV4cG9ydHMuQ2FpcENoYWluSWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGV4cG9ydHMuQ0FJUF9DSEFJTl9JRF9SRUdFWCk7XG4vKipcbiAqIEEgQ0FJUC0yIG5hbWVzcGFjZSwgaS5lLiwgdGhlIGZpcnN0IHBhcnQgb2YgYSBDQUlQIGNoYWluIElELlxuICovXG5leHBvcnRzLkNhaXBOYW1lc3BhY2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGV4cG9ydHMuQ0FJUF9OQU1FU1BBQ0VfUkVHRVgpO1xuLyoqXG4gKiBBIENBSVAtMiByZWZlcmVuY2UsIGkuZS4sIHRoZSBzZWNvbmQgcGFydCBvZiBhIENBSVAgY2hhaW4gSUQuXG4gKi9cbmV4cG9ydHMuQ2FpcFJlZmVyZW5jZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgZXhwb3J0cy5DQUlQX1JFRkVSRU5DRV9SRUdFWCk7XG4vKipcbiAqIEEgQ0FJUC0xMCBhY2NvdW50IElELCBpLmUuLCBhIGh1bWFuLXJlYWRhYmxlIG5hbWVzcGFjZSwgcmVmZXJlbmNlLCBhbmQgYWNjb3VudCBhZGRyZXNzLlxuICovXG5leHBvcnRzLkNhaXBBY2NvdW50SWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGV4cG9ydHMuQ0FJUF9BQ0NPVU5UX0lEX1JFR0VYKTtcbi8qKlxuICogQSBDQUlQLTEwIGFjY291bnQgYWRkcmVzcywgaS5lLiwgdGhlIHRoaXJkIHBhcnQgb2YgdGhlIENBSVAgYWNjb3VudCBJRC5cbiAqL1xuZXhwb3J0cy5DYWlwQWNjb3VudEFkZHJlc3NTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGV4cG9ydHMuQ0FJUF9BQ0NPVU5UX0FERFJFU1NfUkVHRVgpO1xuLyoqIEtub3duIENBSVAgbmFtZXNwYWNlcy4gKi9cbnZhciBLbm93bkNhaXBOYW1lc3BhY2U7XG4oZnVuY3Rpb24gKEtub3duQ2FpcE5hbWVzcGFjZSkge1xuICAgIC8qKiBFSVAtMTU1IGNvbXBhdGlibGUgY2hhaW5zLiAqL1xuICAgIEtub3duQ2FpcE5hbWVzcGFjZVtcIkVpcDE1NVwiXSA9IFwiZWlwMTU1XCI7XG59KShLbm93bkNhaXBOYW1lc3BhY2UgPSBleHBvcnRzLktub3duQ2FpcE5hbWVzcGFjZSB8fCAoZXhwb3J0cy5Lbm93bkNhaXBOYW1lc3BhY2UgPSB7fSkpO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcENoYWluSWR9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEge0BsaW5rIENhaXBDaGFpbklkfS5cbiAqL1xuZnVuY3Rpb24gaXNDYWlwQ2hhaW5JZCh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuQ2FpcENoYWluSWRTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0NhaXBDaGFpbklkID0gaXNDYWlwQ2hhaW5JZDtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEge0BsaW5rIENhaXBOYW1lc3BhY2V9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEge0BsaW5rIENhaXBOYW1lc3BhY2V9LlxuICovXG5mdW5jdGlvbiBpc0NhaXBOYW1lc3BhY2UodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkNhaXBOYW1lc3BhY2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0NhaXBOYW1lc3BhY2UgPSBpc0NhaXBOYW1lc3BhY2U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHtAbGluayBDYWlwUmVmZXJlbmNlfS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHtAbGluayBDYWlwUmVmZXJlbmNlfS5cbiAqL1xuZnVuY3Rpb24gaXNDYWlwUmVmZXJlbmNlKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5DYWlwUmVmZXJlbmNlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNDYWlwUmVmZXJlbmNlID0gaXNDYWlwUmVmZXJlbmNlO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcEFjY291bnRJZH0uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB7QGxpbmsgQ2FpcEFjY291bnRJZH0uXG4gKi9cbmZ1bmN0aW9uIGlzQ2FpcEFjY291bnRJZCh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuQ2FpcEFjY291bnRJZFN0cnVjdCk7XG59XG5leHBvcnRzLmlzQ2FpcEFjY291bnRJZCA9IGlzQ2FpcEFjY291bnRJZDtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHtAbGluayBDYWlwQWNjb3VudEFkZHJlc3N9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIENhaXBBY2NvdW50QWRkcmVzc30uXG4gKi9cbmZ1bmN0aW9uIGlzQ2FpcEFjY291bnRBZGRyZXNzKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5DYWlwQWNjb3VudEFkZHJlc3NTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0NhaXBBY2NvdW50QWRkcmVzcyA9IGlzQ2FpcEFjY291bnRBZGRyZXNzO1xuLyoqXG4gKiBQYXJzZSBhIENBSVAtMiBjaGFpbiBJRCB0byBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXNwYWNlIGFuZCByZWZlcmVuY2UuXG4gKiBUaGlzIHZhbGlkYXRlcyB0aGUgQ0FJUC0yIGNoYWluIElEIGJlZm9yZSBwYXJzaW5nIGl0LlxuICpcbiAqIEBwYXJhbSBjYWlwQ2hhaW5JZCAtIFRoZSBDQUlQLTIgY2hhaW4gSUQgdG8gdmFsaWRhdGUgYW5kIHBhcnNlLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBDQUlQLTIgY2hhaW4gSUQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ2FpcENoYWluSWQoY2FpcENoYWluSWQpIHtcbiAgICBjb25zdCBtYXRjaCA9IGV4cG9ydHMuQ0FJUF9DSEFJTl9JRF9SRUdFWC5leGVjKGNhaXBDaGFpbklkKTtcbiAgICBpZiAoIW1hdGNoPy5ncm91cHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENBSVAgY2hhaW4gSUQuJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWVzcGFjZTogbWF0Y2guZ3JvdXBzLm5hbWVzcGFjZSxcbiAgICAgICAgcmVmZXJlbmNlOiBtYXRjaC5ncm91cHMucmVmZXJlbmNlLFxuICAgIH07XG59XG5leHBvcnRzLnBhcnNlQ2FpcENoYWluSWQgPSBwYXJzZUNhaXBDaGFpbklkO1xuLyoqXG4gKiBQYXJzZSBhbiBDQUlQLTEwIGFjY291bnQgSUQgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNoYWluIElELCBwYXJzZWQgY2hhaW4gSUQsIGFuZCBhY2NvdW50IGFkZHJlc3MuXG4gKiBUaGlzIHZhbGlkYXRlcyB0aGUgQ0FJUC0xMCBhY2NvdW50IElEIGJlZm9yZSBwYXJzaW5nIGl0LlxuICpcbiAqIEBwYXJhbSBjYWlwQWNjb3VudElkIC0gVGhlIENBSVAtMTAgYWNjb3VudCBJRCB0byB2YWxpZGF0ZSBhbmQgcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIENBSVAtMTAgYWNjb3VudCBJRC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VDYWlwQWNjb3VudElkKGNhaXBBY2NvdW50SWQpIHtcbiAgICBjb25zdCBtYXRjaCA9IGV4cG9ydHMuQ0FJUF9BQ0NPVU5UX0lEX1JFR0VYLmV4ZWMoY2FpcEFjY291bnRJZCk7XG4gICAgaWYgKCFtYXRjaD8uZ3JvdXBzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBDQUlQIGFjY291bnQgSUQuJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IG1hdGNoLmdyb3Vwcy5hY2NvdW50QWRkcmVzcyxcbiAgICAgICAgY2hhaW5JZDogbWF0Y2guZ3JvdXBzLmNoYWluSWQsXG4gICAgICAgIGNoYWluOiB7XG4gICAgICAgICAgICBuYW1lc3BhY2U6IG1hdGNoLmdyb3Vwcy5uYW1lc3BhY2UsXG4gICAgICAgICAgICByZWZlcmVuY2U6IG1hdGNoLmdyb3Vwcy5yZWZlcmVuY2UsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyc2VDYWlwQWNjb3VudElkID0gcGFyc2VDYWlwQWNjb3VudElkO1xuLyoqXG4gKiBDaGFpbiBJRCBhcyBkZWZpbmVkIHBlciB0aGUgQ0FJUC0yXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0NoYWluQWdub3N0aWMvQ0FJUHMvYmxvYi9tYWluL0NBSVBzL2NhaXAtMi5tZH0uXG4gKlxuICogSXQgZGVmaW5lcyBhIHdheSB0byB1bmlxdWVseSBpZGVudGlmeSBhbnkgYmxvY2tjaGFpbiBpbiBhIGh1bWFuLXJlYWRhYmxlXG4gKiB3YXkuXG4gKlxuICogQHBhcmFtIG5hbWVzcGFjZSAtIFRoZSBzdGFuZGFyZCAoZWNvc3lzdGVtKSBvZiBzaW1pbGFyIGJsb2NrY2hhaW5zLlxuICogQHBhcmFtIHJlZmVyZW5jZSAtIElkZW50aWZ5IG9mIGEgYmxvY2tjaGFpbiB3aXRoaW4gYSBnaXZlbiBuYW1lc3BhY2UuXG4gKiBAdGhyb3dzIHtAbGluayBFcnJvcn1cbiAqIFRoaXMgZXhjZXB0aW9uIGlzIHRocm93biBpZiB0aGUgaW5wdXRzIGRvZXMgbm90IGNvbXBseSB3aXRoIHRoZSBDQUlQLTJcbiAqIHN5bnRheCBzcGVjaWZpY2F0aW9uXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0NoYWluQWdub3N0aWMvQ0FJUHMvYmxvYi9tYWluL0NBSVBzL2NhaXAtMi5tZCNzeW50YXh9LlxuICogQHJldHVybnMgQSBDQUlQIGNoYWluIElELlxuICovXG5mdW5jdGlvbiB0b0NhaXBDaGFpbklkKG5hbWVzcGFjZSwgcmVmZXJlbmNlKSB7XG4gICAgaWYgKCFpc0NhaXBOYW1lc3BhY2UobmFtZXNwYWNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJuYW1lc3BhY2VcIiwgbXVzdCBtYXRjaDogJHtleHBvcnRzLkNBSVBfTkFNRVNQQUNFX1JFR0VYLnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuICAgIGlmICghaXNDYWlwUmVmZXJlbmNlKHJlZmVyZW5jZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwicmVmZXJlbmNlXCIsIG11c3QgbWF0Y2g6ICR7ZXhwb3J0cy5DQUlQX1JFRkVSRU5DRV9SRUdFWC50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bmFtZXNwYWNlfToke3JlZmVyZW5jZX1gO1xufVxuZXhwb3J0cy50b0NhaXBDaGFpbklkID0gdG9DYWlwQ2hhaW5JZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhaXAtdHlwZXMuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/caip-types.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/checksum.cjs":
/*!********************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/checksum.cjs ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChecksumStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nconst base64_1 = __webpack_require__(/*! ./base64.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/base64.cjs\");\nexports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), { paddingRequired: true }), 44, 44);\n//# sourceMappingURL=checksum.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2hlY2tzdW0uY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0QixzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBdUI7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsMEVBQWM7QUFDdkMsc0JBQXNCLCtFQUErRSx1QkFBdUI7QUFDNUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2hlY2tzdW0uY2pzPzk2OWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoZWNrc3VtU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBiYXNlNjRfMSA9IHJlcXVpcmUoXCIuL2Jhc2U2NC5janNcIik7XG5leHBvcnRzLkNoZWNrc3VtU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEuc2l6ZSkoKDAsIGJhc2U2NF8xLmJhc2U2NCkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCB7IHBhZGRpbmdSZXF1aXJlZDogdHJ1ZSB9KSwgNDQsIDQ0KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrc3VtLmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/checksum.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/coercers.cjs":
/*!********************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/coercers.cjs ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/assert.cjs\");\nconst bytes_1 = __webpack_require__(/*! ./bytes.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/bytes.cjs\");\nconst hex_1 = __webpack_require__(/*! ./hex.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/hex.cjs\");\nconst NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1.StrictHexStruct]);\nconst NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);\nconst BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);\nconst BytesLikeStruct = (0, superstruct_1.union)([hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);\nconst BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1.StrictHexStruct]), bytes_1.hexToBytes);\nconst HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);\n/**\n * Create a number from a number-like value.\n *\n * - If the value is a number, it is returned as-is.\n * - If the value is a `bigint`, it is converted to a number.\n * - If the value is a string, it is interpreted as a decimal number.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number.\n *\n * This validates that the value is a number-like value, and that the resulting\n * number is not `NaN` or `Infinity`.\n *\n * @example\n * ```typescript\n * const value = createNumber('0x010203');\n * console.log(value); // 66051\n *\n * const otherValue = createNumber(123n);\n * console.log(otherValue); // 123\n * ```\n * @param value - The value to create the number from.\n * @returns The created number.\n * @throws If the value is not a number-like value, or if the resulting number\n * is `NaN` or `Infinity`.\n */\nfunction createNumber(value) {\n    try {\n        const result = (0, superstruct_1.create)(value, NumberCoercer);\n        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got \"${value}\".`);\n        return result;\n    }\n    catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a number-like value, got \"${value}\".`);\n        }\n        /* istanbul ignore next */\n        throw error;\n    }\n}\nexports.createNumber = createNumber;\n/**\n * Create a `bigint` from a number-like value.\n *\n * - If the value is a number, it is converted to a `bigint`.\n * - If the value is a `bigint`, it is returned as-is.\n * - If the value is a string, it is interpreted as a decimal number and\n * converted to a `bigint`.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number and converted to a `bigint`.\n *\n * @example\n * ```typescript\n * const value = createBigInt('0x010203');\n * console.log(value); // 16909060n\n *\n * const otherValue = createBigInt(123);\n * console.log(otherValue); // 123n\n * ```\n * @param value - The value to create the bigint from.\n * @returns The created bigint.\n * @throws If the value is not a number-like value.\n */\nfunction createBigInt(value) {\n    try {\n        // The `BigInt` constructor throws if the value is not a number-like value.\n        // There is no need to validate the value manually.\n        return (0, superstruct_1.create)(value, BigIntCoercer);\n    }\n    catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a number-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */\n        throw error;\n    }\n}\nexports.createBigInt = createBigInt;\n/**\n * Create a byte array from a bytes-like value.\n *\n * - If the value is a byte array, it is returned as-is.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is interpreted\n * as a hexadecimal number and converted to a byte array.\n *\n * @example\n * ```typescript\n * const value = createBytes('0x010203');\n * console.log(value); // Uint8Array [ 1, 2, 3 ]\n *\n * const otherValue = createBytes('0x010203');\n * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]\n * ```\n * @param value - The value to create the byte array from.\n * @returns The created byte array.\n * @throws If the value is not a bytes-like value.\n */\nfunction createBytes(value) {\n    if (typeof value === 'string' && value.toLowerCase() === '0x') {\n        return new Uint8Array();\n    }\n    try {\n        return (0, superstruct_1.create)(value, BytesCoercer);\n    }\n    catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */\n        throw error;\n    }\n}\nexports.createBytes = createBytes;\n/**\n * Create a hexadecimal string from a bytes-like value.\n *\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is returned\n * as-is.\n * - If the value is a `Uint8Array`, it is converted to a hex string.\n *\n * @example\n * ```typescript\n * const value = createHex(new Uint8Array([1, 2, 3]));\n * console.log(value); // '0x010203'\n *\n * const otherValue = createHex('0x010203');\n * console.log(otherValue); // '0x010203'\n * ```\n * @param value - The value to create the hex string from.\n * @returns The created hex string.\n * @throws If the value is not a bytes-like value.\n */\nfunction createHex(value) {\n    if ((value instanceof Uint8Array && value.length === 0) ||\n        (typeof value === 'string' && value.toLowerCase() === '0x')) {\n        return '0x';\n    }\n    try {\n        return (0, superstruct_1.create)(value, HexCoercer);\n    }\n    catch (error) {\n        if (error instanceof superstruct_1.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        /* istanbul ignore next */\n        throw error;\n    }\n}\nexports.createHex = createHex;\n//# sourceMappingURL=coercers.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY29lcmNlcnMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLG9CQUFvQjtBQUNyRixzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBdUI7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsMEVBQWM7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQWE7QUFDckMsY0FBYyxtQkFBTyxDQUFDLG9FQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixNQUFNO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLE1BQU07QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG9CQUFvQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxvQkFBb0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxvQkFBb0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jb2VyY2Vycy5janM/N2MyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSGV4ID0gZXhwb3J0cy5jcmVhdGVCeXRlcyA9IGV4cG9ydHMuY3JlYXRlQmlnSW50ID0gZXhwb3J0cy5jcmVhdGVOdW1iZXIgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0LmNqc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlcy5janNcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleC5janNcIik7XG5jb25zdCBOdW1iZXJMaWtlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksICgwLCBzdXBlcnN0cnVjdF8xLmJpZ2ludCkoKSwgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCBoZXhfMS5TdHJpY3RIZXhTdHJ1Y3RdKTtcbmNvbnN0IE51bWJlckNvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSwgTnVtYmVyTGlrZVN0cnVjdCwgTnVtYmVyKTtcbmNvbnN0IEJpZ0ludENvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLmJpZ2ludCkoKSwgTnVtYmVyTGlrZVN0cnVjdCwgQmlnSW50KTtcbmNvbnN0IEJ5dGVzTGlrZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbaGV4XzEuU3RyaWN0SGV4U3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSldKTtcbmNvbnN0IEJ5dGVzQ29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpLCAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW2hleF8xLlN0cmljdEhleFN0cnVjdF0pLCBieXRlc18xLmhleFRvQnl0ZXMpO1xuY29uc3QgSGV4Q29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoaGV4XzEuU3RyaWN0SGV4U3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSksIGJ5dGVzXzEuYnl0ZXNUb0hleCk7XG4vKipcbiAqIENyZWF0ZSBhIG51bWJlciBmcm9tIGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgY29udmVydGVkIHRvIGEgbnVtYmVyLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IGlzIGludGVycHJldGVkIGFzIGEgZGVjaW1hbCBudW1iZXIuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIG51bWJlci5cbiAqXG4gKiBUaGlzIHZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBhIG51bWJlci1saWtlIHZhbHVlLCBhbmQgdGhhdCB0aGUgcmVzdWx0aW5nXG4gKiBudW1iZXIgaXMgbm90IGBOYU5gIG9yIGBJbmZpbml0eWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlTnVtYmVyKCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyA2NjA1MVxuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVOdW1iZXIoMTIzbik7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gMTIzXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIG51bWJlciBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUsIG9yIGlmIHRoZSByZXN1bHRpbmcgbnVtYmVyXG4gKiBpcyBgTmFOYCBvciBgSW5maW5pdHlgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOdW1iZXIodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBOdW1iZXJDb2VyY2VyKTtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzRmluaXRlKHJlc3VsdCksIGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlTnVtYmVyID0gY3JlYXRlTnVtYmVyO1xuLyoqXG4gKiBDcmVhdGUgYSBgYmlnaW50YCBmcm9tIGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIsIGl0IGlzIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBkZWNpbWFsIG51bWJlciBhbmRcbiAqIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpc1xuICogaW50ZXJwcmV0ZWQgYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIgYW5kIGNvbnZlcnRlZCB0byBhIGBiaWdpbnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZUJpZ0ludCgnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gMTY5MDkwNjBuXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZUJpZ0ludCgxMjMpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vIDEyM25cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgYmlnaW50IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBiaWdpbnQuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmlnSW50KHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVGhlIGBCaWdJbnRgIGNvbnN0cnVjdG9yIHRocm93cyBpZiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLWxpa2UgdmFsdWUuXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gdmFsaWRhdGUgdGhlIHZhbHVlIG1hbnVhbGx5LlxuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgQmlnSW50Q29lcmNlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUJpZ0ludCA9IGNyZWF0ZUJpZ0ludDtcbi8qKlxuICogQ3JlYXRlIGEgYnl0ZSBhcnJheSBmcm9tIGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGJ5dGUgYXJyYXksIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpcyBpbnRlcnByZXRlZFxuICogYXMgYSBoZXhhZGVjaW1hbCBudW1iZXIgYW5kIGNvbnZlcnRlZCB0byBhIGJ5dGUgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlQnl0ZXMoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIFVpbnQ4QXJyYXkgWyAxLCAyLCAzIF1cbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlQnl0ZXMoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gVWludDhBcnJheSBbIDEsIDIsIDMgXVxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBieXRlIGFycmF5IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBieXRlIGFycmF5LlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnMHgnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKSh2YWx1ZSwgQnl0ZXNDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBieXRlcy1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVCeXRlcyA9IGNyZWF0ZUJ5dGVzO1xuLyoqXG4gKiBDcmVhdGUgYSBoZXhhZGVjaW1hbCBzdHJpbmcgZnJvbSBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBoZXggc3RyaW5nIChpLmUuLCBpdCBzdGFydHMgd2l0aCBcIjB4XCIpLCBpdCBpcyByZXR1cm5lZFxuICogYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGBVaW50OEFycmF5YCwgaXQgaXMgY29udmVydGVkIHRvIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVIZXgobmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKSk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vICcweDAxMDIwMydcbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlSGV4KCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2cob3RoZXJWYWx1ZSk7IC8vICcweDAxMDIwMydcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgaGV4IHN0cmluZyBmcm9tLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgaGV4IHN0cmluZy5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIGJ5dGVzLWxpa2UgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhleCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJzB4JykpIHtcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBIZXhDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBieXRlcy1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVIZXggPSBjcmVhdGVIZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2VyY2Vycy5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/coercers.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/collections.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/collections.cjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _FrozenMap_map, _FrozenSet_set;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FrozenSet = exports.FrozenMap = void 0;\n/**\n * A {@link ReadonlyMap} that cannot be modified after instantiation.\n * The implementation uses an inner map hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this map.\n */\nclass FrozenMap {\n    get size() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").size;\n    }\n    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\")[Symbol.iterator]();\n    }\n    constructor(entries) {\n        _FrozenMap_map.set(this, void 0);\n        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), \"f\");\n        Object.freeze(this);\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").entries();\n    }\n    forEach(callbackfn, thisArg) {\n        // We have to wrap the specified callback in order to prevent it from\n        // receiving a reference to the inner map.\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));\n    }\n    get(key) {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").get(key);\n    }\n    has(key) {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").has(key);\n    }\n    keys() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").keys();\n    }\n    values() {\n        return __classPrivateFieldGet(this, _FrozenMap_map, \"f\").values();\n    }\n    toString() {\n        return `FrozenMap(${this.size}) {${this.size > 0\n            ? ` ${[...this.entries()]\n                .map(([key, value]) => `${String(key)} => ${String(value)}`)\n                .join(', ')} `\n            : ''}}`;\n    }\n}\nexports.FrozenMap = FrozenMap;\n/**\n * A {@link ReadonlySet} that cannot be modified after instantiation.\n * The implementation uses an inner set hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this set.\n */\nclass FrozenSet {\n    get size() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").size;\n    }\n    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\")[Symbol.iterator]();\n    }\n    constructor(values) {\n        _FrozenSet_set.set(this, void 0);\n        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), \"f\");\n        Object.freeze(this);\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").entries();\n    }\n    forEach(callbackfn, thisArg) {\n        // We have to wrap the specified callback in order to prevent it from\n        // receiving a reference to the inner set.\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));\n    }\n    has(value) {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").has(value);\n    }\n    keys() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").keys();\n    }\n    values() {\n        return __classPrivateFieldGet(this, _FrozenSet_set, \"f\").values();\n    }\n    toString() {\n        return `FrozenSet(${this.size}) {${this.size > 0\n            ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `\n            : ''}}`;\n    }\n}\nexports.FrozenSet = FrozenSet;\nObject.freeze(FrozenMap);\nObject.freeze(FrozenMap.prototype);\nObject.freeze(FrozenSet);\nObject.freeze(FrozenSet.prototype);\n//# sourceMappingURL=collections.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY29sbGVjdGlvbnMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLGlCQUFpQjtBQUNyQztBQUNBLE1BQU0sbUJBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUsR0FBRyxFQUFFO0FBQzNDLGtCQUFrQjtBQUNsQiwwQ0FBMEMsYUFBYSxLQUFLLGNBQWM7QUFDMUUsNkJBQTZCO0FBQzdCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsTUFBTSxtQkFBbUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSxHQUFHLEVBQUU7QUFDM0Msa0JBQWtCLCtEQUErRDtBQUNqRixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvbGxlY3Rpb25zLmNqcz83NzU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9Gcm96ZW5NYXBfbWFwLCBfRnJvemVuU2V0X3NldDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRnJvemVuU2V0ID0gZXhwb3J0cy5Gcm96ZW5NYXAgPSB2b2lkIDA7XG4vKipcbiAqIEEge0BsaW5rIFJlYWRvbmx5TWFwfSB0aGF0IGNhbm5vdCBiZSBtb2RpZmllZCBhZnRlciBpbnN0YW50aWF0aW9uLlxuICogVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgYW4gaW5uZXIgbWFwIGhpZGRlbiB2aWEgYSBwcml2YXRlIGZpZWxkLCBhbmQgdGhlXG4gKiBpbW11dGFiaWxpdHkgZ3VhcmFudGVlIHJlbGllcyBvbiBpdCBiZWluZyBpbXBvc3NpYmxlIHRvIGdldCBhIHJlZmVyZW5jZVxuICogdG8gdGhpcyBtYXAuXG4gKi9cbmNsYXNzIEZyb3plbk1hcCB7XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuc2l6ZTtcbiAgICB9XG4gICAgWyhfRnJvemVuTWFwX21hcCA9IG5ldyBXZWFrTWFwKCksIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZW50cmllcykge1xuICAgICAgICBfRnJvemVuTWFwX21hcC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgbmV3IE1hcChlbnRyaWVzKSwgXCJmXCIpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmVudHJpZXMoKTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGluIG9yZGVyIHRvIHByZXZlbnQgaXQgZnJvbVxuICAgICAgICAvLyByZWNlaXZpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGlubmVyIG1hcC5cbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5mb3JFYWNoKCh2YWx1ZSwga2V5LCBfbWFwKSA9PiBjYWxsYmFja2ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIGtleSwgdGhpcykpO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuZ2V0KGtleSk7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5oYXMoa2V5KTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5rZXlzKCk7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS52YWx1ZXMoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgRnJvemVuTWFwKCR7dGhpcy5zaXplfSkgeyR7dGhpcy5zaXplID4gMFxuICAgICAgICAgICAgPyBgICR7Wy4uLnRoaXMuZW50cmllcygpXVxuICAgICAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7U3RyaW5nKGtleSl9ID0+ICR7U3RyaW5nKHZhbHVlKX1gKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfSBgXG4gICAgICAgICAgICA6ICcnfX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuRnJvemVuTWFwID0gRnJvemVuTWFwO1xuLyoqXG4gKiBBIHtAbGluayBSZWFkb25seVNldH0gdGhhdCBjYW5ub3QgYmUgbW9kaWZpZWQgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIGFuIGlubmVyIHNldCBoaWRkZW4gdmlhIGEgcHJpdmF0ZSBmaWVsZCwgYW5kIHRoZVxuICogaW1tdXRhYmlsaXR5IGd1YXJhbnRlZSByZWxpZXMgb24gaXQgYmVpbmcgaW1wb3NzaWJsZSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIHRvIHRoaXMgc2V0LlxuICovXG5jbGFzcyBGcm96ZW5TZXQge1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLnNpemU7XG4gICAgfVxuICAgIFsoX0Zyb3plblNldF9zZXQgPSBuZXcgV2Vha01hcCgpLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgICAgICBfRnJvemVuU2V0X3NldC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgbmV3IFNldCh2YWx1ZXMpLCBcImZcIik7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikuZW50cmllcygpO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2sgaW4gb3JkZXIgdG8gcHJldmVudCBpdCBmcm9tXG4gICAgICAgIC8vIHJlY2VpdmluZyBhIHJlZmVyZW5jZSB0byB0aGUgaW5uZXIgc2V0LlxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmZvckVhY2goKHZhbHVlLCB2YWx1ZTIsIF9zZXQpID0+IGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwgdmFsdWUyLCB0aGlzKSk7XG4gICAgfVxuICAgIGhhcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmhhcyh2YWx1ZSk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikua2V5cygpO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikudmFsdWVzKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYEZyb3plblNldCgke3RoaXMuc2l6ZX0pIHske3RoaXMuc2l6ZSA+IDBcbiAgICAgICAgICAgID8gYCAke1suLi50aGlzLnZhbHVlcygpXS5tYXAoKG1lbWJlcikgPT4gU3RyaW5nKG1lbWJlcikpLmpvaW4oJywgJyl9IGBcbiAgICAgICAgICAgIDogJyd9fWA7XG4gICAgfVxufVxuZXhwb3J0cy5Gcm96ZW5TZXQgPSBGcm96ZW5TZXQ7XG5PYmplY3QuZnJlZXplKEZyb3plbk1hcCk7XG5PYmplY3QuZnJlZXplKEZyb3plbk1hcC5wcm90b3R5cGUpO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5TZXQpO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5TZXQucHJvdG90eXBlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbGxlY3Rpb25zLmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/collections.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/encryption-types.cjs":
/*!****************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/encryption-types.cjs ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=encryption-types.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvZW5jcnlwdGlvbi10eXBlcy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvZW5jcnlwdGlvbi10eXBlcy5janM/N2FiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuY3J5cHRpb24tdHlwZXMuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/encryption-types.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/errors.cjs":
/*!******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/errors.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wrapError = exports.getErrorMessage = exports.isErrorWithStack = exports.isErrorWithMessage = exports.isErrorWithCode = void 0;\nconst pony_cause_1 = __webpack_require__(/*! pony-cause */ \"(ssr)/./node_modules/pony-cause/index.js\");\nconst misc_1 = __webpack_require__(/*! ./misc.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/misc.cjs\");\n/**\n * Type guard for determining whether the given value is an instance of Error.\n * For errors generated via `fs.promises`, `error instanceof Error` won't work,\n * so we have to come up with another way of testing.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isError(error) {\n    return (error instanceof Error ||\n        ((0, misc_1.isObject)(error) && error.constructor.name === 'Error'));\n}\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property such as the type of error that Node throws for filesystem\n * operations, etc.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithCode(error) {\n    return typeof error === 'object' && error !== null && 'code' in error;\n}\nexports.isErrorWithCode = isErrorWithCode;\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithMessage(error) {\n    return typeof error === 'object' && error !== null && 'message' in error;\n}\nexports.isErrorWithMessage = isErrorWithMessage;\n/**\n * Type guard for determining whether the given value is an error object with a\n * `stack` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isErrorWithStack(error) {\n    return typeof error === 'object' && error !== null && 'stack' in error;\n}\nexports.isErrorWithStack = isErrorWithStack;\n/**\n * Attempts to obtain the message from a possible error object, defaulting to an\n * empty string if it is impossible to do so.\n *\n * @param error - The possible error to get the message from.\n * @returns The message if `error` is an object with a `message` property;\n * the string version of `error` if it is not `undefined` or `null`; otherwise\n * an empty string.\n */\nfunction getErrorMessage(error) {\n    if (isErrorWithMessage(error) && typeof error.message === 'string') {\n        return error.message;\n    }\n    if ((0, misc_1.isNullOrUndefined)(error)) {\n        return '';\n    }\n    return String(error);\n}\nexports.getErrorMessage = getErrorMessage;\n/**\n * Builds a new error object, linking it to the original error via the `cause`\n * property if it is an Error.\n *\n * This function is useful to reframe error messages in general, but is\n * _critical_ when interacting with any of Node's filesystem functions as\n * provided via `fs.promises`, because these do not produce stack traces in the\n * case of an I/O error (see <https://github.com/nodejs/node/issues/30944>).\n *\n * @param originalError - The error to be wrapped (something throwable).\n * @param message - The desired message of the new error.\n * @returns A new error object.\n */\nfunction wrapError(originalError, message) {\n    if (isError(originalError)) {\n        let error;\n        if (Error.length === 2) {\n            // for some reason `tsserver` is not complaining that the\n            // Error constructor doesn't support a second argument in the editor,\n            // but `tsc` does. Error causes are not supported by our current tsc target (ES2020, we need ES2022 to make this work)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            error = new Error(message, { cause: originalError });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            error = new pony_cause_1.ErrorWithCause(message, { cause: originalError });\n        }\n        if (isErrorWithCode(originalError)) {\n            error.code = originalError.code;\n        }\n        return error;\n    }\n    if (message.length > 0) {\n        return new Error(`${String(originalError)}: ${message}`);\n    }\n    return new Error(String(originalError));\n}\nexports.wrapError = wrapError;\n//# sourceMappingURL=errors.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvZXJyb3JzLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyx1QkFBdUIsR0FBRyx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRyx1QkFBdUI7QUFDN0gscUJBQXFCLG1CQUFPLENBQUMsNERBQVk7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHNFQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHNCQUFzQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0IsSUFBSSxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9lcnJvcnMuY2pzPzhhZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndyYXBFcnJvciA9IGV4cG9ydHMuZ2V0RXJyb3JNZXNzYWdlID0gZXhwb3J0cy5pc0Vycm9yV2l0aFN0YWNrID0gZXhwb3J0cy5pc0Vycm9yV2l0aE1lc3NhZ2UgPSBleHBvcnRzLmlzRXJyb3JXaXRoQ29kZSA9IHZvaWQgMDtcbmNvbnN0IHBvbnlfY2F1c2VfMSA9IHJlcXVpcmUoXCJwb255LWNhdXNlXCIpO1xuY29uc3QgbWlzY18xID0gcmVxdWlyZShcIi4vbWlzYy5janNcIik7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIEVycm9yLlxuICogRm9yIGVycm9ycyBnZW5lcmF0ZWQgdmlhIGBmcy5wcm9taXNlc2AsIGBlcnJvciBpbnN0YW5jZW9mIEVycm9yYCB3b24ndCB3b3JrLFxuICogc28gd2UgaGF2ZSB0byBjb21lIHVwIHdpdGggYW5vdGhlciB3YXkgb2YgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIChlcnJvciBpbnN0YW5jZW9mIEVycm9yIHx8XG4gICAgICAgICgoMCwgbWlzY18xLmlzT2JqZWN0KShlcnJvcikgJiYgZXJyb3IuY29uc3RydWN0b3IubmFtZSA9PT0gJ0Vycm9yJykpO1xufVxuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBlcnJvciBvYmplY3Qgd2l0aCBhXG4gKiBgY29kZWAgcHJvcGVydHkgc3VjaCBhcyB0aGUgdHlwZSBvZiBlcnJvciB0aGF0IE5vZGUgdGhyb3dzIGZvciBmaWxlc3lzdGVtXG4gKiBvcGVyYXRpb25zLCBldGMuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbi5cbiAqL1xuZnVuY3Rpb24gaXNFcnJvcldpdGhDb2RlKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ2NvZGUnIGluIGVycm9yO1xufVxuZXhwb3J0cy5pc0Vycm9yV2l0aENvZGUgPSBpc0Vycm9yV2l0aENvZGU7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGVycm9yIG9iamVjdCB3aXRoIGFcbiAqIGBtZXNzYWdlYCBwcm9wZXJ0eSwgc3VjaCBhcyBhbiBpbnN0YW5jZSBvZiBFcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnbWVzc2FnZScgaW4gZXJyb3I7XG59XG5leHBvcnRzLmlzRXJyb3JXaXRoTWVzc2FnZSA9IGlzRXJyb3JXaXRoTWVzc2FnZTtcbi8qKlxuICogVHlwZSBndWFyZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gZXJyb3Igb2JqZWN0IHdpdGggYVxuICogYHN0YWNrYCBwcm9wZXJ0eSwgc3VjaCBhcyBhbiBpbnN0YW5jZSBvZiBFcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgQSBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Vycm9yV2l0aFN0YWNrKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ3N0YWNrJyBpbiBlcnJvcjtcbn1cbmV4cG9ydHMuaXNFcnJvcldpdGhTdGFjayA9IGlzRXJyb3JXaXRoU3RhY2s7XG4vKipcbiAqIEF0dGVtcHRzIHRvIG9idGFpbiB0aGUgbWVzc2FnZSBmcm9tIGEgcG9zc2libGUgZXJyb3Igb2JqZWN0LCBkZWZhdWx0aW5nIHRvIGFuXG4gKiBlbXB0eSBzdHJpbmcgaWYgaXQgaXMgaW1wb3NzaWJsZSB0byBkbyBzby5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgcG9zc2libGUgZXJyb3IgdG8gZ2V0IHRoZSBtZXNzYWdlIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgbWVzc2FnZSBpZiBgZXJyb3JgIGlzIGFuIG9iamVjdCB3aXRoIGEgYG1lc3NhZ2VgIHByb3BlcnR5O1xuICogdGhlIHN0cmluZyB2ZXJzaW9uIG9mIGBlcnJvcmAgaWYgaXQgaXMgbm90IGB1bmRlZmluZWRgIG9yIGBudWxsYDsgb3RoZXJ3aXNlXG4gKiBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICAgIGlmIChpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgaWYgKCgwLCBtaXNjXzEuaXNOdWxsT3JVbmRlZmluZWQpKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoZXJyb3IpO1xufVxuZXhwb3J0cy5nZXRFcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2U7XG4vKipcbiAqIEJ1aWxkcyBhIG5ldyBlcnJvciBvYmplY3QsIGxpbmtpbmcgaXQgdG8gdGhlIG9yaWdpbmFsIGVycm9yIHZpYSB0aGUgYGNhdXNlYFxuICogcHJvcGVydHkgaWYgaXQgaXMgYW4gRXJyb3IuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgdG8gcmVmcmFtZSBlcnJvciBtZXNzYWdlcyBpbiBnZW5lcmFsLCBidXQgaXNcbiAqIF9jcml0aWNhbF8gd2hlbiBpbnRlcmFjdGluZyB3aXRoIGFueSBvZiBOb2RlJ3MgZmlsZXN5c3RlbSBmdW5jdGlvbnMgYXNcbiAqIHByb3ZpZGVkIHZpYSBgZnMucHJvbWlzZXNgLCBiZWNhdXNlIHRoZXNlIGRvIG5vdCBwcm9kdWNlIHN0YWNrIHRyYWNlcyBpbiB0aGVcbiAqIGNhc2Ugb2YgYW4gSS9PIGVycm9yIChzZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzA5NDQ+KS5cbiAqXG4gKiBAcGFyYW0gb3JpZ2luYWxFcnJvciAtIFRoZSBlcnJvciB0byBiZSB3cmFwcGVkIChzb21ldGhpbmcgdGhyb3dhYmxlKS5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGRlc2lyZWQgbWVzc2FnZSBvZiB0aGUgbmV3IGVycm9yLlxuICogQHJldHVybnMgQSBuZXcgZXJyb3Igb2JqZWN0LlxuICovXG5mdW5jdGlvbiB3cmFwRXJyb3Iob3JpZ2luYWxFcnJvciwgbWVzc2FnZSkge1xuICAgIGlmIChpc0Vycm9yKG9yaWdpbmFsRXJyb3IpKSB7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgaWYgKEVycm9yLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIGB0c3NlcnZlcmAgaXMgbm90IGNvbXBsYWluaW5nIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBFcnJvciBjb25zdHJ1Y3RvciBkb2Vzbid0IHN1cHBvcnQgYSBzZWNvbmQgYXJndW1lbnQgaW4gdGhlIGVkaXRvcixcbiAgICAgICAgICAgIC8vIGJ1dCBgdHNjYCBkb2VzLiBFcnJvciBjYXVzZXMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgb3VyIGN1cnJlbnQgdHNjIHRhcmdldCAoRVMyMDIwLCB3ZSBuZWVkIEVTMjAyMiB0byBtYWtlIHRoaXMgd29yaylcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UsIHsgY2F1c2U6IG9yaWdpbmFsRXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBwb255X2NhdXNlXzEuRXJyb3JXaXRoQ2F1c2UobWVzc2FnZSwgeyBjYXVzZTogb3JpZ2luYWxFcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFcnJvcldpdGhDb2RlKG9yaWdpbmFsRXJyb3IpKSB7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gb3JpZ2luYWxFcnJvci5jb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGAke1N0cmluZyhvcmlnaW5hbEVycm9yKX06ICR7bWVzc2FnZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcihTdHJpbmcob3JpZ2luYWxFcnJvcikpO1xufVxuZXhwb3J0cy53cmFwRXJyb3IgPSB3cmFwRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/errors.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/hex.cjs":
/*!***************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/hex.cjs ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.remove0x = exports.add0x = exports.isValidChecksumAddress = exports.getChecksumAddress = exports.isValidHexAddress = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.HexChecksumAddressStruct = exports.HexAddressStruct = exports.StrictHexStruct = exports.HexStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/sha3.js\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/assert.cjs\");\nconst bytes_1 = __webpack_require__(/*! ./bytes.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/bytes.cjs\");\nexports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);\nexports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);\nexports.HexAddressStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]{40}$/u);\nexports.HexChecksumAddressStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-fA-F]{40}$/u);\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nfunction isHexString(value) {\n    return (0, superstruct_1.is)(value, exports.HexStruct);\n}\nexports.isHexString = isHexString;\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nfunction isStrictHexString(value) {\n    return (0, superstruct_1.is)(value, exports.StrictHexStruct);\n}\nexports.isStrictHexString = isStrictHexString;\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nfunction assertIsHexString(value) {\n    (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');\n}\nexports.assertIsHexString = assertIsHexString;\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nfunction assertIsStrictHexString(value) {\n    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with \"0x\".');\n}\nexports.assertIsStrictHexString = assertIsStrictHexString;\n/**\n * Validate that the passed prefixed hex string is an all-lowercase\n * hex address, or a valid mixed-case checksum address.\n *\n * @param possibleAddress - Input parameter to check against.\n * @returns Whether or not the input is a valid hex address.\n */\nfunction isValidHexAddress(possibleAddress) {\n    return ((0, superstruct_1.is)(possibleAddress, exports.HexAddressStruct) ||\n        isValidChecksumAddress(possibleAddress));\n}\nexports.isValidHexAddress = isValidHexAddress;\n/**\n * Encode a passed hex string as an ERC-55 mixed-case checksum address.\n *\n * @param address - The hex address to encode.\n * @returns The address encoded according to ERC-55.\n * @see https://eips.ethereum.org/EIPS/eip-55\n */\nfunction getChecksumAddress(address) {\n    (0, assert_1.assert)((0, superstruct_1.is)(address, exports.HexChecksumAddressStruct), 'Invalid hex address.');\n    const unPrefixed = remove0x(address.toLowerCase());\n    const unPrefixedHash = remove0x((0, bytes_1.bytesToHex)((0, sha3_1.keccak_256)(unPrefixed)));\n    return `0x${unPrefixed\n        .split('')\n        .map((character, nibbleIndex) => {\n        const hashCharacter = unPrefixedHash[nibbleIndex];\n        (0, assert_1.assert)((0, superstruct_1.is)(hashCharacter, (0, superstruct_1.string)()), 'Hash shorter than address.');\n        return parseInt(hashCharacter, 16) > 7\n            ? character.toUpperCase()\n            : character;\n    })\n        .join('')}`;\n}\nexports.getChecksumAddress = getChecksumAddress;\n/**\n * Validate that the passed hex string is a valid ERC-55 mixed-case\n * checksum address.\n *\n * @param possibleChecksum - The hex address to check.\n * @returns True if the address is a checksum address.\n */\nfunction isValidChecksumAddress(possibleChecksum) {\n    if (!(0, superstruct_1.is)(possibleChecksum, exports.HexChecksumAddressStruct)) {\n        return false;\n    }\n    return getChecksumAddress(possibleChecksum) === possibleChecksum;\n}\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */\nfunction add0x(hexadecimal) {\n    if (hexadecimal.startsWith('0x')) {\n        return hexadecimal;\n    }\n    if (hexadecimal.startsWith('0X')) {\n        return `0x${hexadecimal.substring(2)}`;\n    }\n    return `0x${hexadecimal}`;\n}\nexports.add0x = add0x;\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */\nfunction remove0x(hexadecimal) {\n    if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {\n        return hexadecimal.substring(2);\n    }\n    return hexadecimal;\n}\nexports.remove0x = remove0x;\n//# sourceMappingURL=hex.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvaGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxhQUFhLEdBQUcsOEJBQThCLEdBQUcsMEJBQTBCLEdBQUcseUJBQXlCLEdBQUcsK0JBQStCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcsbUJBQW1CLEdBQUcsZ0NBQWdDLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsaUJBQWlCO0FBQ3RWLHNCQUFzQixtQkFBTyxDQUFDLHdGQUF1QjtBQUNyRCxlQUFlLG1CQUFPLENBQUMsc0VBQW9CO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFjO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFhO0FBQ3JDLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIsd0JBQXdCLHdFQUF3RSxHQUFHO0FBQ25HLGdDQUFnQywyRUFBMkUsR0FBRztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0I7QUFDbEI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2hleC5janM/MjlkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVtb3ZlMHggPSBleHBvcnRzLmFkZDB4ID0gZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gZXhwb3J0cy5nZXRDaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRIZXhBZGRyZXNzID0gZXhwb3J0cy5hc3NlcnRJc1N0cmljdEhleFN0cmluZyA9IGV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSBleHBvcnRzLmlzU3RyaWN0SGV4U3RyaW5nID0gZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuSGV4Q2hlY2tzdW1BZGRyZXNzU3RydWN0ID0gZXhwb3J0cy5IZXhBZGRyZXNzU3RydWN0ID0gZXhwb3J0cy5TdHJpY3RIZXhTdHJ1Y3QgPSBleHBvcnRzLkhleFN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3N1cGVyc3RydWN0XCIpO1xuY29uc3Qgc2hhM18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhM1wiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0LmNqc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlcy5janNcIik7XG5leHBvcnRzLkhleFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgL14oPzoweCk/WzAtOWEtZl0rJC9pdSk7XG5leHBvcnRzLlN0cmljdEhleFN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnBhdHRlcm4pKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgL14weFswLTlhLWZdKyQvaXUpO1xuZXhwb3J0cy5IZXhBZGRyZXNzU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAvXjB4WzAtOWEtZl17NDB9JC91KTtcbmV4cG9ydHMuSGV4Q2hlY2tzdW1BZGRyZXNzU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAvXjB4WzAtOWEtZkEtRl17NDB9JC91KTtcbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkhleFN0cnVjdCk7XG59XG5leHBvcnRzLmlzSGV4U3RyaW5nID0gaXNIZXhTdHJpbmc7XG4vKipcbiAqIFN0cmljdGx5IGNoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgaGV4IHN0cmluZy4gQSB2YWxpZCBoZXggc3RyaW5nIG11c3RcbiAqIHN0YXJ0IHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdEhleFN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuU3RyaWN0SGV4U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNTdHJpY3RIZXhTdHJpbmcgPSBpc1N0cmljdEhleFN0cmluZztcbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNIZXhTdHJpbmcodmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShpc0hleFN0cmluZyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgaGV4YWRlY2ltYWwgc3RyaW5nLicpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IGFzc2VydElzSGV4U3RyaW5nO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy4gQSB2YWxpZCBoZXggc3RyaW5nIG11c3Qgc3RhcnQgd2l0aFxuICogdGhlIFwiMHhcIi1wcmVmaXguXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmcodmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShpc1N0cmljdEhleFN0cmluZyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgaGV4YWRlY2ltYWwgc3RyaW5nLCBzdGFydGluZyB3aXRoIFwiMHhcIi4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmcgPSBhc3NlcnRJc1N0cmljdEhleFN0cmluZztcbi8qKlxuICogVmFsaWRhdGUgdGhhdCB0aGUgcGFzc2VkIHByZWZpeGVkIGhleCBzdHJpbmcgaXMgYW4gYWxsLWxvd2VyY2FzZVxuICogaGV4IGFkZHJlc3MsIG9yIGEgdmFsaWQgbWl4ZWQtY2FzZSBjaGVja3N1bSBhZGRyZXNzLlxuICpcbiAqIEBwYXJhbSBwb3NzaWJsZUFkZHJlc3MgLSBJbnB1dCBwYXJhbWV0ZXIgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHZhbGlkIGhleCBhZGRyZXNzLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSGV4QWRkcmVzcyhwb3NzaWJsZUFkZHJlc3MpIHtcbiAgICByZXR1cm4gKCgwLCBzdXBlcnN0cnVjdF8xLmlzKShwb3NzaWJsZUFkZHJlc3MsIGV4cG9ydHMuSGV4QWRkcmVzc1N0cnVjdCkgfHxcbiAgICAgICAgaXNWYWxpZENoZWNrc3VtQWRkcmVzcyhwb3NzaWJsZUFkZHJlc3MpKTtcbn1cbmV4cG9ydHMuaXNWYWxpZEhleEFkZHJlc3MgPSBpc1ZhbGlkSGV4QWRkcmVzcztcbi8qKlxuICogRW5jb2RlIGEgcGFzc2VkIGhleCBzdHJpbmcgYXMgYW4gRVJDLTU1IG1peGVkLWNhc2UgY2hlY2tzdW0gYWRkcmVzcy5cbiAqXG4gKiBAcGFyYW0gYWRkcmVzcyAtIFRoZSBoZXggYWRkcmVzcyB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBUaGUgYWRkcmVzcyBlbmNvZGVkIGFjY29yZGluZyB0byBFUkMtNTUuXG4gKiBAc2VlIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNTVcbiAqL1xuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSgoMCwgc3VwZXJzdHJ1Y3RfMS5pcykoYWRkcmVzcywgZXhwb3J0cy5IZXhDaGVja3N1bUFkZHJlc3NTdHJ1Y3QpLCAnSW52YWxpZCBoZXggYWRkcmVzcy4nKTtcbiAgICBjb25zdCB1blByZWZpeGVkID0gcmVtb3ZlMHgoYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgICBjb25zdCB1blByZWZpeGVkSGFzaCA9IHJlbW92ZTB4KCgwLCBieXRlc18xLmJ5dGVzVG9IZXgpKCgwLCBzaGEzXzEua2VjY2FrXzI1NikodW5QcmVmaXhlZCkpKTtcbiAgICByZXR1cm4gYDB4JHt1blByZWZpeGVkXG4gICAgICAgIC5zcGxpdCgnJylcbiAgICAgICAgLm1hcCgoY2hhcmFjdGVyLCBuaWJibGVJbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBoYXNoQ2hhcmFjdGVyID0gdW5QcmVmaXhlZEhhc2hbbmliYmxlSW5kZXhdO1xuICAgICAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSgoMCwgc3VwZXJzdHJ1Y3RfMS5pcykoaGFzaENoYXJhY3RlciwgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpKSwgJ0hhc2ggc2hvcnRlciB0aGFuIGFkZHJlc3MuJyk7XG4gICAgICAgIHJldHVybiBwYXJzZUludChoYXNoQ2hhcmFjdGVyLCAxNikgPiA3XG4gICAgICAgICAgICA/IGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICA6IGNoYXJhY3RlcjtcbiAgICB9KVxuICAgICAgICAuam9pbignJyl9YDtcbn1cbmV4cG9ydHMuZ2V0Q2hlY2tzdW1BZGRyZXNzID0gZ2V0Q2hlY2tzdW1BZGRyZXNzO1xuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IHRoZSBwYXNzZWQgaGV4IHN0cmluZyBpcyBhIHZhbGlkIEVSQy01NSBtaXhlZC1jYXNlXG4gKiBjaGVja3N1bSBhZGRyZXNzLlxuICpcbiAqIEBwYXJhbSBwb3NzaWJsZUNoZWNrc3VtIC0gVGhlIGhleCBhZGRyZXNzIHRvIGNoZWNrLlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgYWRkcmVzcyBpcyBhIGNoZWNrc3VtIGFkZHJlc3MuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDaGVja3N1bUFkZHJlc3MocG9zc2libGVDaGVja3N1bSkge1xuICAgIGlmICghKDAsIHN1cGVyc3RydWN0XzEuaXMpKHBvc3NpYmxlQ2hlY2tzdW0sIGV4cG9ydHMuSGV4Q2hlY2tzdW1BZGRyZXNzU3RydWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBnZXRDaGVja3N1bUFkZHJlc3MocG9zc2libGVDaGVja3N1bSkgPT09IHBvc3NpYmxlQ2hlY2tzdW07XG59XG5leHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBpc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzO1xuLyoqXG4gKiBBZGQgdGhlIGAweGAtcHJlZml4IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBJZiB0aGUgc3RyaW5nIGFscmVhZHkgaGFzIHRoZVxuICogcHJlZml4LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gaGV4YWRlY2ltYWwgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGFkZCB0aGUgcHJlZml4IHRvLlxuICogQHJldHVybnMgVGhlIHByZWZpeGVkIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYWRkMHgoaGV4YWRlY2ltYWwpIHtcbiAgICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICByZXR1cm4gaGV4YWRlY2ltYWw7XG4gICAgfVxuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcwWCcpKSB7XG4gICAgICAgIHJldHVybiBgMHgke2hleGFkZWNpbWFsLnN1YnN0cmluZygyKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYDB4JHtoZXhhZGVjaW1hbH1gO1xufVxuZXhwb3J0cy5hZGQweCA9IGFkZDB4O1xuLyoqXG4gKiBSZW1vdmUgdGhlIGAweGAtcHJlZml4IGZyb20gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIElmIHRoZSBzdHJpbmcgZG9lc24ndCBoYXZlXG4gKiB0aGUgcHJlZml4LCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gaGV4YWRlY2ltYWwgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIHJlbW92ZSB0aGUgcHJlZml4IGZyb20uXG4gKiBAcmV0dXJucyBUaGUgdW4tcHJlZml4ZWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiByZW1vdmUweChoZXhhZGVjaW1hbCkge1xuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcweCcpIHx8IGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzBYJykpIHtcbiAgICAgICAgcmV0dXJuIGhleGFkZWNpbWFsLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGFkZWNpbWFsO1xufVxuZXhwb3J0cy5yZW1vdmUweCA9IHJlbW92ZTB4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/hex.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/index.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/index.cjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./assert.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/assert.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./base64.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/base64.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./bytes.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/bytes.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./caip-types.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/caip-types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./checksum.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/checksum.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./coercers.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/coercers.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./collections.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/collections.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./encryption-types.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/encryption-types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./errors.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/errors.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./hex.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/hex.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./json.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/json.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./keyring.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/keyring.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./logging.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/logging.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./misc.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/misc.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./number.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/number.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./opaque.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/opaque.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./promise.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/promise.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./time.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/time.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./transaction-types.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/transaction-types.cjs\"), exports);\n__exportStar(__webpack_require__(/*! ./versions.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/versions.cjs\"), exports);\n//# sourceMappingURL=index.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQywwRUFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsMEVBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLHdFQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLDhFQUFnQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsOEVBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxvRkFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLDhGQUF3QjtBQUM3QyxhQUFhLG1CQUFPLENBQUMsMEVBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLG9FQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxzRUFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsNEVBQWU7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLDRFQUFlO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQyxzRUFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsMEVBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLDBFQUFjO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyw0RUFBZTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsc0VBQVk7QUFDakMsYUFBYSxtQkFBTyxDQUFDLGdHQUF5QjtBQUM5QyxhQUFhLG1CQUFPLENBQUMsOEVBQWdCO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2luZGV4LmNqcz9hOGViIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXJ0LmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZTY0LmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYnl0ZXMuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jYWlwLXR5cGVzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2hlY2tzdW0uY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2VyY2Vycy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbGxlY3Rpb25zLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZW5jcnlwdGlvbi10eXBlcy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Vycm9ycy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hleC5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2pzb24uY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9rZXlyaW5nLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbG9nZ2luZy5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21pc2MuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9udW1iZXIuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vcGFxdWUuY2pzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcm9taXNlLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdGltZS5janNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uLXR5cGVzLmNqc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmVyc2lvbnMuY2pzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/json.cjs":
/*!****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/json.cjs ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.getJsonSize = exports.getSafeJson = exports.isValidJson = exports.JsonStruct = exports.UnsafeJsonStruct = exports.exactOptional = exports.object = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/assert.cjs\");\nconst misc_1 = __webpack_require__(/*! ./misc.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/misc.cjs\");\n/**\n * A struct to check if the given value is a valid object, with support for\n * {@link exactOptional} types.\n *\n * @param schema - The schema of the object.\n * @returns A struct to check if the given value is an object.\n */\nconst object = (schema) => \n// The type is slightly different from a regular object struct, because we\n// want to make properties with `undefined` in their type optional, but not\n// `undefined` itself. This means that we need a type cast.\n(0, superstruct_1.object)(schema);\nexports.object = object;\n/**\n * Check the last field of a path is present.\n *\n * @param context - The context to check.\n * @param context.path - The path to check.\n * @param context.branch - The branch to check.\n * @returns Whether the last field of a path is present.\n */\nfunction hasOptional({ path, branch }) {\n    const field = path[path.length - 1];\n    return (0, misc_1.hasProperty)(branch[branch.length - 2], field);\n}\n/**\n * A struct which allows the property of an object to be absent, or to be present\n * as long as it's valid and not set to `undefined`.\n *\n * This struct should be used in conjunction with the {@link object} from this\n * library, to get proper type inference.\n *\n * @param struct - The struct to check the value against, if present.\n * @returns A struct to check if the given value is valid, or not present.\n * @example\n * ```ts\n * const struct = object({\n *   foo: exactOptional(string()),\n *   bar: exactOptional(number()),\n *   baz: optional(boolean()),\n *   qux: unknown(),\n * });\n *\n * type Type = Infer<typeof struct>;\n * // Type is equivalent to:\n * // {\n * //   foo?: string;\n * //   bar?: number;\n * //   baz?: boolean | undefined;\n * //   qux: unknown;\n * // }\n * ```\n */\nfunction exactOptional(struct) {\n    return new superstruct_1.Struct({\n        ...struct,\n        type: `optional ${struct.type}`,\n        validator: (value, context) => !hasOptional(context) || struct.validator(value, context),\n        refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context),\n    });\n}\nexports.exactOptional = exactOptional;\n/**\n * A struct to check if the given value is finite number. Superstruct's\n * `number()` struct does not check if the value is finite.\n *\n * @returns A struct to check if the given value is finite number.\n */\nconst finiteNumber = () => (0, superstruct_1.define)('finite number', (value) => {\n    return (0, superstruct_1.is)(value, (0, superstruct_1.number)()) && Number.isFinite(value);\n});\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */\n// We cannot infer the type of the struct, because it is recursive.\nexports.UnsafeJsonStruct = (0, superstruct_1.union)([\n    (0, superstruct_1.literal)(null),\n    (0, superstruct_1.boolean)(),\n    finiteNumber(),\n    (0, superstruct_1.string)(),\n    (0, superstruct_1.array)((0, superstruct_1.lazy)(() => exports.UnsafeJsonStruct)),\n    (0, superstruct_1.record)((0, superstruct_1.string)(), (0, superstruct_1.lazy)(() => exports.UnsafeJsonStruct)),\n]);\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */\nexports.JsonStruct = (0, superstruct_1.coerce)(exports.UnsafeJsonStruct, (0, superstruct_1.any)(), (value) => {\n    (0, assert_1.assertStruct)(value, exports.UnsafeJsonStruct);\n    return JSON.parse(JSON.stringify(value, (propKey, propValue) => {\n        // Strip __proto__ and constructor properties to prevent prototype pollution.\n        if (propKey === '__proto__' || propKey === 'constructor') {\n            return undefined;\n        }\n        return propValue;\n    }));\n});\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */\nfunction isValidJson(value) {\n    try {\n        getSafeJson(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nexports.isValidJson = isValidJson;\n/**\n * Validate and return sanitized JSON.\n *\n * Note:\n * This function uses sanitized JsonStruct for validation\n * that applies stringify and then parse of a value provided\n * to ensure that there are no getters which can have side effects\n * that can cause security issues.\n *\n * @param value - JSON structure to be processed.\n * @returns Sanitized JSON structure.\n */\nfunction getSafeJson(value) {\n    return (0, superstruct_1.create)(value, exports.JsonStruct);\n}\nexports.getSafeJson = getSafeJson;\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */\nfunction getJsonSize(value) {\n    (0, assert_1.assertStruct)(value, exports.JsonStruct, 'Invalid JSON value');\n    const json = JSON.stringify(value);\n    return new TextEncoder().encode(json).byteLength;\n}\nexports.getJsonSize = getJsonSize;\n/**\n * The string '2.0'.\n */\nexports.jsonrpc2 = '2.0';\nexports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);\nexports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));\nexports.JsonRpcErrorStruct = (0, exports.object)({\n    code: (0, superstruct_1.integer)(),\n    message: (0, superstruct_1.string)(),\n    data: exactOptional(exports.JsonStruct),\n    stack: exactOptional((0, superstruct_1.string)()),\n});\nexports.JsonRpcParamsStruct = (0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]);\nexports.JsonRpcRequestStruct = (0, exports.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    method: (0, superstruct_1.string)(),\n    params: exactOptional(exports.JsonRpcParamsStruct),\n});\nexports.JsonRpcNotificationStruct = (0, exports.object)({\n    jsonrpc: exports.JsonRpcVersionStruct,\n    method: (0, superstruct_1.string)(),\n    params: exactOptional(exports.JsonRpcParamsStruct),\n});\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */\nfunction isJsonRpcNotification(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);\n}\nexports.isJsonRpcNotification = isJsonRpcNotification;\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */\nfunction assertIsJsonRpcNotification(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);\n}\nexports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */\nfunction isJsonRpcRequest(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);\n}\nexports.isJsonRpcRequest = isJsonRpcRequest;\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */\nfunction assertIsJsonRpcRequest(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);\n}\nexports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;\nexports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),\n    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct),\n});\nexports.JsonRpcSuccessStruct = (0, exports.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    result: exports.JsonStruct,\n});\nexports.JsonRpcFailureStruct = (0, exports.object)({\n    id: exports.JsonRpcIdStruct,\n    jsonrpc: exports.JsonRpcVersionStruct,\n    error: exports.JsonRpcErrorStruct,\n});\nexports.JsonRpcResponseStruct = (0, superstruct_1.union)([\n    exports.JsonRpcSuccessStruct,\n    exports.JsonRpcFailureStruct,\n]);\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */\nfunction isPendingJsonRpcResponse(response) {\n    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);\n}\nexports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */\nfunction assertIsPendingJsonRpcResponse(response, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);\n}\nexports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */\nfunction isJsonRpcResponse(response) {\n    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);\n}\nexports.isJsonRpcResponse = isJsonRpcResponse;\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */\nfunction assertIsJsonRpcResponse(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);\n}\nexports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */\nfunction isJsonRpcSuccess(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);\n}\nexports.isJsonRpcSuccess = isJsonRpcSuccess;\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */\nfunction assertIsJsonRpcSuccess(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);\n}\nexports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */\nfunction isJsonRpcFailure(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);\n}\nexports.isJsonRpcFailure = isJsonRpcFailure;\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */\nfunction assertIsJsonRpcFailure(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);\n}\nexports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */\nfunction isJsonRpcError(value) {\n    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);\n}\nexports.isJsonRpcError = isJsonRpcError;\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */\nfunction assertIsJsonRpcError(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);\n}\nexports.assertIsJsonRpcError = assertIsJsonRpcError;\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */\nfunction getJsonRpcIdValidator(options) {\n    const { permitEmptyString, permitFractions, permitNull } = {\n        permitEmptyString: true,\n        permitFractions: false,\n        permitNull: true,\n        ...options,\n    };\n    /**\n     * Type guard for {@link JsonRpcId}.\n     *\n     * @param id - The JSON-RPC ID value to check.\n     * @returns Whether the given ID is valid per the options given to the\n     * factory.\n     */\n    const isValidJsonRpcId = (id) => {\n        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||\n            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||\n            (permitNull && id === null));\n    };\n    return isValidJsonRpcId;\n}\nexports.getJsonRpcIdValidator = getJsonRpcIdValidator;\n//# sourceMappingURL=json.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvanNvbi5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsNEJBQTRCLEdBQUcsc0JBQXNCLEdBQUcsOEJBQThCLEdBQUcsd0JBQXdCLEdBQUcsOEJBQThCLEdBQUcsd0JBQXdCLEdBQUcsK0JBQStCLEdBQUcseUJBQXlCLEdBQUcsc0NBQXNDLEdBQUcsZ0NBQWdDLEdBQUcsNkJBQTZCLEdBQUcsNEJBQTRCLEdBQUcsNEJBQTRCLEdBQUcsb0NBQW9DLEdBQUcsOEJBQThCLEdBQUcsd0JBQXdCLEdBQUcsbUNBQW1DLEdBQUcsNkJBQTZCLEdBQUcsaUNBQWlDLEdBQUcsNEJBQTRCLEdBQUcsMkJBQTJCLEdBQUcsMEJBQTBCLEdBQUcsdUJBQXVCLEdBQUcsNEJBQTRCLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsd0JBQXdCLEdBQUcscUJBQXFCLEdBQUcsY0FBYztBQUNuOEIsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQXVCO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLDBFQUFjO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxzRUFBWTtBQUNuQztBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsaUJBQWlCO0FBQy9FO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLDRCQUE0QjtBQUM1Qix1QkFBdUI7QUFDdkIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHdDQUF3QywyQkFBMkI7QUFDbkU7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsMkNBQTJDLDJCQUEyQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLDhDQUE4QywyQkFBMkI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0EsZ0RBQWdELHNCQUFzQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLDJDQUEyQyxzQkFBc0I7QUFDakU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2QkFBNkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSwyQ0FBMkMsOEJBQThCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLDJDQUEyQyx1QkFBdUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyw4Q0FBOEMsdUJBQXVCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBLGdEQUFnRCxzQkFBc0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSwyQ0FBMkMsc0JBQXNCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsOENBQThDLHNCQUFzQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQSxnREFBZ0Qsc0JBQXNCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLDhDQUE4QyxzQkFBc0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0Esd0NBQXdDLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0EsZ0RBQWdELG9CQUFvQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLDJDQUEyQyxvQkFBb0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyw4Q0FBOEMsb0JBQW9CO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlEQUFpRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9qc29uLmNqcz8zODk5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRKc29uUnBjSWRWYWxpZGF0b3IgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY0Vycm9yID0gZXhwb3J0cy5pc0pzb25ScGNFcnJvciA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSA9IGV4cG9ydHMuaXNKc29uUnBjRmFpbHVyZSA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjU3VjY2VzcyA9IGV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmlzSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5hc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmlzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QgPSBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBleHBvcnRzLmlzSnNvblJwY1JlcXVlc3QgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuaXNKc29uUnBjTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCA9IGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0ID0gZXhwb3J0cy5qc29ucnBjMiA9IGV4cG9ydHMuZ2V0SnNvblNpemUgPSBleHBvcnRzLmdldFNhZmVKc29uID0gZXhwb3J0cy5pc1ZhbGlkSnNvbiA9IGV4cG9ydHMuSnNvblN0cnVjdCA9IGV4cG9ydHMuVW5zYWZlSnNvblN0cnVjdCA9IGV4cG9ydHMuZXhhY3RPcHRpb25hbCA9IGV4cG9ydHMub2JqZWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydC5janNcIik7XG5jb25zdCBtaXNjXzEgPSByZXF1aXJlKFwiLi9taXNjLmNqc1wiKTtcbi8qKlxuICogQSBzdHJ1Y3QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgb2JqZWN0LCB3aXRoIHN1cHBvcnQgZm9yXG4gKiB7QGxpbmsgZXhhY3RPcHRpb25hbH0gdHlwZXMuXG4gKlxuICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgb2YgdGhlIG9iamVjdC5cbiAqIEByZXR1cm5zIEEgc3RydWN0IHRvIGNoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3QuXG4gKi9cbmNvbnN0IG9iamVjdCA9IChzY2hlbWEpID0+IFxuLy8gVGhlIHR5cGUgaXMgc2xpZ2h0bHkgZGlmZmVyZW50IGZyb20gYSByZWd1bGFyIG9iamVjdCBzdHJ1Y3QsIGJlY2F1c2Ugd2Vcbi8vIHdhbnQgdG8gbWFrZSBwcm9wZXJ0aWVzIHdpdGggYHVuZGVmaW5lZGAgaW4gdGhlaXIgdHlwZSBvcHRpb25hbCwgYnV0IG5vdFxuLy8gYHVuZGVmaW5lZGAgaXRzZWxmLiBUaGlzIG1lYW5zIHRoYXQgd2UgbmVlZCBhIHR5cGUgY2FzdC5cbigwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoc2NoZW1hKTtcbmV4cG9ydHMub2JqZWN0ID0gb2JqZWN0O1xuLyoqXG4gKiBDaGVjayB0aGUgbGFzdCBmaWVsZCBvZiBhIHBhdGggaXMgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHRvIGNoZWNrLlxuICogQHBhcmFtIGNvbnRleHQucGF0aCAtIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIGNvbnRleHQuYnJhbmNoIC0gVGhlIGJyYW5jaCB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGxhc3QgZmllbGQgb2YgYSBwYXRoIGlzIHByZXNlbnQuXG4gKi9cbmZ1bmN0aW9uIGhhc09wdGlvbmFsKHsgcGF0aCwgYnJhbmNoIH0pIHtcbiAgICBjb25zdCBmaWVsZCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gKDAsIG1pc2NfMS5oYXNQcm9wZXJ0eSkoYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAyXSwgZmllbGQpO1xufVxuLyoqXG4gKiBBIHN0cnVjdCB3aGljaCBhbGxvd3MgdGhlIHByb3BlcnR5IG9mIGFuIG9iamVjdCB0byBiZSBhYnNlbnQsIG9yIHRvIGJlIHByZXNlbnRcbiAqIGFzIGxvbmcgYXMgaXQncyB2YWxpZCBhbmQgbm90IHNldCB0byBgdW5kZWZpbmVkYC5cbiAqXG4gKiBUaGlzIHN0cnVjdCBzaG91bGQgYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSB7QGxpbmsgb2JqZWN0fSBmcm9tIHRoaXNcbiAqIGxpYnJhcnksIHRvIGdldCBwcm9wZXIgdHlwZSBpbmZlcmVuY2UuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gY2hlY2sgdGhlIHZhbHVlIGFnYWluc3QsIGlmIHByZXNlbnQuXG4gKiBAcmV0dXJucyBBIHN0cnVjdCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdmFsaWQsIG9yIG5vdCBwcmVzZW50LlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBzdHJ1Y3QgPSBvYmplY3Qoe1xuICogICBmb286IGV4YWN0T3B0aW9uYWwoc3RyaW5nKCkpLFxuICogICBiYXI6IGV4YWN0T3B0aW9uYWwobnVtYmVyKCkpLFxuICogICBiYXo6IG9wdGlvbmFsKGJvb2xlYW4oKSksXG4gKiAgIHF1eDogdW5rbm93bigpLFxuICogfSk7XG4gKlxuICogdHlwZSBUeXBlID0gSW5mZXI8dHlwZW9mIHN0cnVjdD47XG4gKiAvLyBUeXBlIGlzIGVxdWl2YWxlbnQgdG86XG4gKiAvLyB7XG4gKiAvLyAgIGZvbz86IHN0cmluZztcbiAqIC8vICAgYmFyPzogbnVtYmVyO1xuICogLy8gICBiYXo/OiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICogLy8gICBxdXg6IHVua25vd247XG4gKiAvLyB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZXhhY3RPcHRpb25hbChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gbmV3IHN1cGVyc3RydWN0XzEuU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICB0eXBlOiBgb3B0aW9uYWwgJHtzdHJ1Y3QudHlwZX1gLFxuICAgICAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY29udGV4dCkgPT4gIWhhc09wdGlvbmFsKGNvbnRleHQpIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpLFxuICAgICAgICByZWZpbmVyOiAodmFsdWUsIGNvbnRleHQpID0+ICFoYXNPcHRpb25hbChjb250ZXh0KSB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY29udGV4dCksXG4gICAgfSk7XG59XG5leHBvcnRzLmV4YWN0T3B0aW9uYWwgPSBleGFjdE9wdGlvbmFsO1xuLyoqXG4gKiBBIHN0cnVjdCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgZmluaXRlIG51bWJlci4gU3VwZXJzdHJ1Y3Qnc1xuICogYG51bWJlcigpYCBzdHJ1Y3QgZG9lcyBub3QgY2hlY2sgaWYgdGhlIHZhbHVlIGlzIGZpbml0ZS5cbiAqXG4gKiBAcmV0dXJucyBBIHN0cnVjdCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgZmluaXRlIG51bWJlci5cbiAqL1xuY29uc3QgZmluaXRlTnVtYmVyID0gKCkgPT4gKDAsIHN1cGVyc3RydWN0XzEuZGVmaW5lKSgnZmluaXRlIG51bWJlcicsICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsICgwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSkgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlKTtcbn0pO1xuLyoqXG4gKiBBIHN0cnVjdCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCBKU09OLXNlcmlhbGl6YWJsZSB2YWx1ZS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBzdHJ1Y3QgaXMgdW5zYWZlLiBGb3Igc2FmZSB2YWxpZGF0aW9uLCB1c2Uge0BsaW5rIEpzb25TdHJ1Y3R9LlxuICovXG4vLyBXZSBjYW5ub3QgaW5mZXIgdGhlIHR5cGUgb2YgdGhlIHN0cnVjdCwgYmVjYXVzZSBpdCBpcyByZWN1cnNpdmUuXG5leHBvcnRzLlVuc2FmZUpzb25TdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW1xuICAgICgwLCBzdXBlcnN0cnVjdF8xLmxpdGVyYWwpKG51bGwpLFxuICAgICgwLCBzdXBlcnN0cnVjdF8xLmJvb2xlYW4pKCksXG4gICAgZmluaXRlTnVtYmVyKCksXG4gICAgKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLFxuICAgICgwLCBzdXBlcnN0cnVjdF8xLmFycmF5KSgoMCwgc3VwZXJzdHJ1Y3RfMS5sYXp5KSgoKSA9PiBleHBvcnRzLlVuc2FmZUpzb25TdHJ1Y3QpKSxcbiAgICAoMCwgc3VwZXJzdHJ1Y3RfMS5yZWNvcmQpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgKDAsIHN1cGVyc3RydWN0XzEubGF6eSkoKCkgPT4gZXhwb3J0cy5VbnNhZmVKc29uU3RydWN0KSksXG5dKTtcbi8qKlxuICogQSBzdHJ1Y3QgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgSlNPTi1zZXJpYWxpemFibGUgdmFsdWUuXG4gKlxuICogVGhpcyBzdHJ1Y3Qgc2FuaXRpemVzIHRoZSB2YWx1ZSBiZWZvcmUgdmFsaWRhdGluZyBpdCwgc28gdGhhdCBpdCBpcyBzYWZlIHRvXG4gKiB1c2Ugd2l0aCB1bnRydXN0ZWQgaW5wdXQuXG4gKi9cbmV4cG9ydHMuSnNvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoZXhwb3J0cy5VbnNhZmVKc29uU3RydWN0LCAoMCwgc3VwZXJzdHJ1Y3RfMS5hbnkpKCksICh2YWx1ZSkgPT4ge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLlVuc2FmZUpzb25TdHJ1Y3QpO1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlLCAocHJvcEtleSwgcHJvcFZhbHVlKSA9PiB7XG4gICAgICAgIC8vIFN0cmlwIF9fcHJvdG9fXyBhbmQgY29uc3RydWN0b3IgcHJvcGVydGllcyB0byBwcmV2ZW50IHByb3RvdHlwZSBwb2xsdXRpb24uXG4gICAgICAgIGlmIChwcm9wS2V5ID09PSAnX19wcm90b19fJyB8fCBwcm9wS2V5ID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wVmFsdWU7XG4gICAgfSkpO1xufSk7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29ufSB2YWx1ZSwgaS5lLiwgYSB2YWx1ZSB0aGF0IGlzXG4gKiBzZXJpYWxpemFibGUgdG8gSlNPTi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29ufSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEpzb24odmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBnZXRTYWZlSnNvbih2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmlzVmFsaWRKc29uID0gaXNWYWxpZEpzb247XG4vKipcbiAqIFZhbGlkYXRlIGFuZCByZXR1cm4gc2FuaXRpemVkIEpTT04uXG4gKlxuICogTm90ZTpcbiAqIFRoaXMgZnVuY3Rpb24gdXNlcyBzYW5pdGl6ZWQgSnNvblN0cnVjdCBmb3IgdmFsaWRhdGlvblxuICogdGhhdCBhcHBsaWVzIHN0cmluZ2lmeSBhbmQgdGhlbiBwYXJzZSBvZiBhIHZhbHVlIHByb3ZpZGVkXG4gKiB0byBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgbm8gZ2V0dGVycyB3aGljaCBjYW4gaGF2ZSBzaWRlIGVmZmVjdHNcbiAqIHRoYXQgY2FuIGNhdXNlIHNlY3VyaXR5IGlzc3Vlcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBKU09OIHN0cnVjdHVyZSB0byBiZSBwcm9jZXNzZWQuXG4gKiBAcmV0dXJucyBTYW5pdGl6ZWQgSlNPTiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIGdldFNhZmVKc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIGV4cG9ydHMuSnNvblN0cnVjdCk7XG59XG5leHBvcnRzLmdldFNhZmVKc29uID0gZ2V0U2FmZUpzb247XG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiBhIEpTT04gdmFsdWUgaW4gYnl0ZXMuIFRoaXMgYWxzbyB2YWxpZGF0ZXMgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBKU09OIHZhbHVlIHRvIGdldCB0aGUgc2l6ZSBvZi5cbiAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSBKU09OIHZhbHVlIGluIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBnZXRKc29uU2l6ZSh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25TdHJ1Y3QsICdJbnZhbGlkIEpTT04gdmFsdWUnKTtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoanNvbikuYnl0ZUxlbmd0aDtcbn1cbmV4cG9ydHMuZ2V0SnNvblNpemUgPSBnZXRKc29uU2l6ZTtcbi8qKlxuICogVGhlIHN0cmluZyAnMi4wJy5cbiAqL1xuZXhwb3J0cy5qc29ucnBjMiA9ICcyLjAnO1xuZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmxpdGVyYWwpKGV4cG9ydHMuanNvbnJwYzIpO1xuZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5udWxsYWJsZSkoKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKV0pKTtcbmV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0ID0gKDAsIGV4cG9ydHMub2JqZWN0KSh7XG4gICAgY29kZTogKDAsIHN1cGVyc3RydWN0XzEuaW50ZWdlcikoKSxcbiAgICBtZXNzYWdlOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgZGF0YTogZXhhY3RPcHRpb25hbChleHBvcnRzLkpzb25TdHJ1Y3QpLFxuICAgIHN0YWNrOiBleGFjdE9wdGlvbmFsKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSksXG59KTtcbmV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEucmVjb3JkKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGV4cG9ydHMuSnNvblN0cnVjdCksICgwLCBzdXBlcnN0cnVjdF8xLmFycmF5KShleHBvcnRzLkpzb25TdHJ1Y3QpXSk7XG5leHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0ID0gKDAsIGV4cG9ydHMub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgbWV0aG9kOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgcGFyYW1zOiBleGFjdE9wdGlvbmFsKGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCksXG59KTtcbmV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCA9ICgwLCBleHBvcnRzLm9iamVjdCkoe1xuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgbWV0aG9kOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgcGFyYW1zOiBleGFjdE9wdGlvbmFsKGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCksXG59KTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNOb3RpZmljYXRpb259IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufVxuICogb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNOb3RpZmljYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNOb3RpZmljYXRpb24gPSBpc0pzb25ScGNOb3RpZmljYXRpb247XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbih2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBub3RpZmljYXRpb24nLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24gPSBhc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb247XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1JlcXVlc3QodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjUmVxdWVzdCA9IGlzSnNvblJwY1JlcXVlc3Q7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBKU09OLVJQQyByZXF1ZXN0IG9yIG5vdGlmaWNhdGlvbiB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgcmVxdWVzdCcsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBhc3NlcnRJc0pzb25ScGNSZXF1ZXN0O1xuZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgcmVzdWx0OiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoKDAsIHN1cGVyc3RydWN0XzEudW5rbm93bikoKSksXG4gICAgZXJyb3I6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKShleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCksXG59KTtcbmV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QgPSAoMCwgZXhwb3J0cy5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICByZXN1bHQ6IGV4cG9ydHMuSnNvblN0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCA9ICgwLCBleHBvcnRzLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIGVycm9yOiBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCxcbn0pO1xuZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoW1xuICAgIGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QsXG4gICAgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCxcbl0pO1xuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIHdoZXRoZXIgc3BlY2lmaWVkIEpTT04tUlBDIHJlc3BvbnNlIGlzIGFcbiAqIHtAbGluayBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlfS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgSlNPTi1SUEMgcmVzcG9uc2UgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgSlNPTi1SUEMgcmVzcG9uc2UgaXMgcGVuZGluZy5cbiAqL1xuZnVuY3Rpb24gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKShyZXNwb25zZSwgZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBKU09OLVJQQyByZXNwb25zZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX1cbiAqIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHJlc3BvbnNlLCBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QsICdJbnZhbGlkIHBlbmRpbmcgSlNPTi1SUEMgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHtAbGluayBKc29uUnBjUmVzcG9uc2V9LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBvYmplY3QgaXMgYSBKc29uUnBjUmVzcG9uc2UuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKShyZXNwb25zZSwgZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNSZXNwb25zZSA9IGlzSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1Jlc3BvbnNlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVzcG9uc2V9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1Jlc3BvbnNlID0gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1N1Y2Nlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IGlzSnNvblJwY1N1Y2Nlc3M7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjU3VjY2Vzcyh2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgc3VjY2VzcyByZXNwb25zZScsIEVycm9yV3JhcHBlcik7XG59XG5leHBvcnRzLmFzc2VydElzSnNvblJwY1N1Y2Nlc3MgPSBhc3NlcnRJc0pzb25ScGNTdWNjZXNzO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNGYWlsdXJlKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY0ZhaWx1cmUgPSBpc0pzb25ScGNGYWlsdXJlO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY0ZhaWx1cmUodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIGZhaWx1cmUgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNGYWlsdXJlID0gYXNzZXJ0SXNKc29uUnBjRmFpbHVyZTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNFcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjRXJyb3IgPSBpc0pzb25ScGNFcnJvcjtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0Vycm9yfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY0Vycm9yKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgZXJyb3InLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNFcnJvciA9IGFzc2VydElzSnNvblJwY0Vycm9yO1xuLyoqXG4gKiBHZXRzIGEgZnVuY3Rpb24gZm9yIHZhbGlkYXRpbmcgSlNPTi1SUEMgcmVxdWVzdCAvIHJlc3BvbnNlIGBpZGAgdmFsdWVzLlxuICpcbiAqIEJ5IG1hbmlwdWxhdGluZyB0aGUgb3B0aW9ucyBvZiB0aGlzIGZhY3RvcnksIHlvdSBjYW4gY29udHJvbCB0aGUgYmVoYXZpb3JcbiAqIG9mIHRoZSByZXN1bHRpbmcgdmFsaWRhdG9yIGZvciBzb21lIGVkZ2UgY2FzZXMuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgZS5nLlxuICogYG51bGxgIHNob3VsZCBzb21ldGltZXMgYnV0IG5vdCBhbHdheXMgYmUgcGVybWl0dGVkLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgZW1wdHkgc3RyaW5nIChgJydgKSBpcyBhbHdheXMgcGVybWl0dGVkIGJ5IHRoZSBKU09OLVJQQ1xuICogc3BlY2lmaWNhdGlvbiwgYnV0IHRoYXQga2luZCBvZiBzdWNrcyBhbmQgeW91IG1heSB3YW50IHRvIGZvcmJpZCBpdCBpbiBzb21lXG4gKiBpbnN0YW5jZXMgYW55d2F5LlxuICpcbiAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGVcbiAqIFtKU09OLVJQQyBTcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy5qc29ucnBjLm9yZy9zcGVjaWZpY2F0aW9uKS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0RW1wdHlTdHJpbmcgLSBXaGV0aGVyIHRoZSBlbXB0eSBzdHJpbmcgKGkuZS4gYCcnYClcbiAqIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgdmFsaWQgSUQuIERlZmF1bHQ6IGB0cnVlYFxuICogQHBhcmFtIG9wdGlvbnMucGVybWl0RnJhY3Rpb25zIC0gV2hldGhlciBmcmFjdGlvbmFsIG51bWJlcnMgKGUuZy4gYDEuMmApXG4gKiBzaG91bGQgYmUgdHJlYXRlZCBhcyB2YWxpZCBJRHMuIERlZmF1bHQ6IGBmYWxzZWBcbiAqIEBwYXJhbSBvcHRpb25zLnBlcm1pdE51bGwgLSBXaGV0aGVyIGBudWxsYCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHZhbGlkIElELlxuICogRGVmYXVsdDogYHRydWVgXG4gKiBAcmV0dXJucyBUaGUgSlNPTi1SUEMgSUQgdmFsaWRhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRKc29uUnBjSWRWYWxpZGF0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGVybWl0RW1wdHlTdHJpbmcsIHBlcm1pdEZyYWN0aW9ucywgcGVybWl0TnVsbCB9ID0ge1xuICAgICAgICBwZXJtaXRFbXB0eVN0cmluZzogdHJ1ZSxcbiAgICAgICAgcGVybWl0RnJhY3Rpb25zOiBmYWxzZSxcbiAgICAgICAgcGVybWl0TnVsbDogdHJ1ZSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmQgZm9yIHtAbGluayBKc29uUnBjSWR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIEpTT04tUlBDIElEIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIElEIGlzIHZhbGlkIHBlciB0aGUgb3B0aW9ucyBnaXZlbiB0byB0aGVcbiAgICAgKiBmYWN0b3J5LlxuICAgICAqL1xuICAgIGNvbnN0IGlzVmFsaWRKc29uUnBjSWQgPSAoaWQpID0+IHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKHR5cGVvZiBpZCA9PT0gJ251bWJlcicgJiYgKHBlcm1pdEZyYWN0aW9ucyB8fCBOdW1iZXIuaXNJbnRlZ2VyKGlkKSkpIHx8XG4gICAgICAgICAgICAodHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiAocGVybWl0RW1wdHlTdHJpbmcgfHwgaWQubGVuZ3RoID4gMCkpIHx8XG4gICAgICAgICAgICAocGVybWl0TnVsbCAmJiBpZCA9PT0gbnVsbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIGlzVmFsaWRKc29uUnBjSWQ7XG59XG5leHBvcnRzLmdldEpzb25ScGNJZFZhbGlkYXRvciA9IGdldEpzb25ScGNJZFZhbGlkYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24uY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/json.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/keyring.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/keyring.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=keyring.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3Qva2V5cmluZy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3Qva2V5cmluZy5janM/OTA4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXJpbmcuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/keyring.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/logging.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/logging.cjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createModuleLogger = exports.createProjectLogger = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\"));\nconst globalLogger = (0, debug_1.default)('metamask');\n/**\n * Creates a logger via the `debug` library whose log messages will be tagged\n * using the name of your project. By default, such messages will be\n * suppressed, but you can reveal them by setting the `DEBUG` environment\n * variable to `metamask:<projectName>`. You can also set this variable to\n * `metamask:*` if you want to see log messages from all MetaMask projects that\n * are also using this function to create their loggers.\n *\n * @param projectName - The name of your project. This should be the name of\n * your NPM package if you're developing one.\n * @returns An instance of `debug`.\n */\nfunction createProjectLogger(projectName) {\n    return globalLogger.extend(projectName);\n}\nexports.createProjectLogger = createProjectLogger;\n/**\n * Creates a logger via the `debug` library which is derived from the logger for\n * the whole project whose log messages will be tagged using the name of your\n * module. By default, such messages will be suppressed, but you can reveal them\n * by setting the `DEBUG` environment variable to\n * `metamask:<projectName>:<moduleName>`. You can also set this variable to\n * `metamask:<projectName>:*` if you want to see log messages from the project,\n * or `metamask:*` if you want to see log messages from all MetaMask projects.\n *\n * @param projectLogger - The logger created via {@link createProjectLogger}.\n * @param moduleName - The name of your module. You could use the name of the\n * file where you're using this logger or some other name.\n * @returns An instance of `debug`.\n */\nfunction createModuleLogger(projectLogger, moduleName) {\n    return projectLogger.extend(moduleName);\n}\nexports.createModuleLogger = createModuleLogger;\n//# sourceMappingURL=logging.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbG9nZ2luZy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRywyQkFBMkI7QUFDeEQsZ0NBQWdDLG1CQUFPLENBQUMsc0RBQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDBCQUEwQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9sb2dnaW5nLmNqcz85N2E3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBleHBvcnRzLmNyZWF0ZVByb2plY3RMb2dnZXIgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBnbG9iYWxMb2dnZXIgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbWV0YW1hc2snKTtcbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2dlciB2aWEgdGhlIGBkZWJ1Z2AgbGlicmFyeSB3aG9zZSBsb2cgbWVzc2FnZXMgd2lsbCBiZSB0YWdnZWRcbiAqIHVzaW5nIHRoZSBuYW1lIG9mIHlvdXIgcHJvamVjdC4gQnkgZGVmYXVsdCwgc3VjaCBtZXNzYWdlcyB3aWxsIGJlXG4gKiBzdXBwcmVzc2VkLCBidXQgeW91IGNhbiByZXZlYWwgdGhlbSBieSBzZXR0aW5nIHRoZSBgREVCVUdgIGVudmlyb25tZW50XG4gKiB2YXJpYWJsZSB0byBgbWV0YW1hc2s6PHByb2plY3ROYW1lPmAuIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB2YXJpYWJsZSB0b1xuICogYG1ldGFtYXNrOipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSBhbGwgTWV0YU1hc2sgcHJvamVjdHMgdGhhdFxuICogYXJlIGFsc28gdXNpbmcgdGhpcyBmdW5jdGlvbiB0byBjcmVhdGUgdGhlaXIgbG9nZ2Vycy5cbiAqXG4gKiBAcGFyYW0gcHJvamVjdE5hbWUgLSBUaGUgbmFtZSBvZiB5b3VyIHByb2plY3QuIFRoaXMgc2hvdWxkIGJlIHRoZSBuYW1lIG9mXG4gKiB5b3VyIE5QTSBwYWNrYWdlIGlmIHlvdSdyZSBkZXZlbG9waW5nIG9uZS5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIGBkZWJ1Z2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb2plY3RMb2dnZXIocHJvamVjdE5hbWUpIHtcbiAgICByZXR1cm4gZ2xvYmFsTG9nZ2VyLmV4dGVuZChwcm9qZWN0TmFtZSk7XG59XG5leHBvcnRzLmNyZWF0ZVByb2plY3RMb2dnZXIgPSBjcmVhdGVQcm9qZWN0TG9nZ2VyO1xuLyoqXG4gKiBDcmVhdGVzIGEgbG9nZ2VyIHZpYSB0aGUgYGRlYnVnYCBsaWJyYXJ5IHdoaWNoIGlzIGRlcml2ZWQgZnJvbSB0aGUgbG9nZ2VyIGZvclxuICogdGhlIHdob2xlIHByb2plY3Qgd2hvc2UgbG9nIG1lc3NhZ2VzIHdpbGwgYmUgdGFnZ2VkIHVzaW5nIHRoZSBuYW1lIG9mIHlvdXJcbiAqIG1vZHVsZS4gQnkgZGVmYXVsdCwgc3VjaCBtZXNzYWdlcyB3aWxsIGJlIHN1cHByZXNzZWQsIGJ1dCB5b3UgY2FuIHJldmVhbCB0aGVtXG4gKiBieSBzZXR0aW5nIHRoZSBgREVCVUdgIGVudmlyb25tZW50IHZhcmlhYmxlIHRvXG4gKiBgbWV0YW1hc2s6PHByb2plY3ROYW1lPjo8bW9kdWxlTmFtZT5gLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdmFyaWFibGUgdG9cbiAqIGBtZXRhbWFzazo8cHJvamVjdE5hbWU+OipgIGlmIHlvdSB3YW50IHRvIHNlZSBsb2cgbWVzc2FnZXMgZnJvbSB0aGUgcHJvamVjdCxcbiAqIG9yIGBtZXRhbWFzazoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gYWxsIE1ldGFNYXNrIHByb2plY3RzLlxuICpcbiAqIEBwYXJhbSBwcm9qZWN0TG9nZ2VyIC0gVGhlIGxvZ2dlciBjcmVhdGVkIHZpYSB7QGxpbmsgY3JlYXRlUHJvamVjdExvZ2dlcn0uXG4gKiBAcGFyYW0gbW9kdWxlTmFtZSAtIFRoZSBuYW1lIG9mIHlvdXIgbW9kdWxlLiBZb3UgY291bGQgdXNlIHRoZSBuYW1lIG9mIHRoZVxuICogZmlsZSB3aGVyZSB5b3UncmUgdXNpbmcgdGhpcyBsb2dnZXIgb3Igc29tZSBvdGhlciBuYW1lLlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYGRlYnVnYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9kdWxlTG9nZ2VyKHByb2plY3RMb2dnZXIsIG1vZHVsZU5hbWUpIHtcbiAgICByZXR1cm4gcHJvamVjdExvZ2dlci5leHRlbmQobW9kdWxlTmFtZSk7XG59XG5leHBvcnRzLmNyZWF0ZU1vZHVsZUxvZ2dlciA9IGNyZWF0ZU1vZHVsZUxvZ2dlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmcuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/logging.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/misc.cjs":
/*!****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/misc.cjs ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n//\n// Types\n//\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.getKnownPropertyNames = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;\n//\n// Type Guards\n//\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */\nfunction isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\nexports.isNonEmptyArray = isNonEmptyArray;\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */\nfunction isObject(value) {\n    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);\n}\nexports.isObject = isObject;\n//\n// Other utility functions\n//\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */\nconst hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);\nexports.hasProperty = hasProperty;\n/**\n * `Object.getOwnPropertyNames()` is intentionally generic: it returns the\n * immediate property names of an object, but it cannot make guarantees about\n * the contents of that object, so the type of the property names is merely\n * `string[]`. While this is technically accurate, it is also unnecessary if we\n * have an object with a type that we own (such as an enum).\n *\n * @param object - The plain object.\n * @returns The own property names of the object which are assigned a type\n * derived from the object itself.\n */\nfunction getKnownPropertyNames(object) {\n    return Object.getOwnPropertyNames(object);\n}\nexports.getKnownPropertyNames = getKnownPropertyNames;\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */\nvar JsonSize;\n(function (JsonSize) {\n    JsonSize[JsonSize[\"Null\"] = 4] = \"Null\";\n    JsonSize[JsonSize[\"Comma\"] = 1] = \"Comma\";\n    JsonSize[JsonSize[\"Wrapper\"] = 1] = \"Wrapper\";\n    JsonSize[JsonSize[\"True\"] = 4] = \"True\";\n    JsonSize[JsonSize[\"False\"] = 5] = \"False\";\n    JsonSize[JsonSize[\"Quote\"] = 1] = \"Quote\";\n    JsonSize[JsonSize[\"Colon\"] = 1] = \"Colon\";\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    JsonSize[JsonSize[\"Date\"] = 24] = \"Date\";\n})(JsonSize = exports.JsonSize || (exports.JsonSize = {}));\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */\nexports.ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */\nfunction isPlainObject(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while (Object.getPrototypeOf(proto) !== null) {\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    }\n    catch (_) {\n        return false;\n    }\n}\nexports.isPlainObject = isPlainObject;\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */\nfunction isASCII(character) {\n    return character.charCodeAt(0) <= 127;\n}\nexports.isASCII = isASCII;\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */\nfunction calculateStringSize(value) {\n    const size = value.split('').reduce((total, character) => {\n        if (isASCII(character)) {\n            return total + 1;\n        }\n        return total + 2;\n    }, 0);\n    // Also detect characters that need backslash escape\n    return size + (value.match(exports.ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\nexports.calculateStringSize = calculateStringSize;\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */\nfunction calculateNumberSize(value) {\n    return value.toString().length;\n}\nexports.calculateNumberSize = calculateNumberSize;\n//# sourceMappingURL=misc.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbWlzYy5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsZUFBZSxHQUFHLHFCQUFxQixHQUFHLGdDQUFnQyxHQUFHLGdCQUFnQixHQUFHLDZCQUE2QixHQUFHLG1CQUFtQixHQUFHLGdCQUFnQixHQUFHLHlCQUF5QixHQUFHLHVCQUF1QjtBQUN4UjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0scUJBQXFCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQyxnQkFBZ0IsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L21pc2MuY2pzPzEyZDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vL1xuLy8gVHlwZXNcbi8vXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhbGN1bGF0ZU51bWJlclNpemUgPSBleHBvcnRzLmNhbGN1bGF0ZVN0cmluZ1NpemUgPSBleHBvcnRzLmlzQVNDSUkgPSBleHBvcnRzLmlzUGxhaW5PYmplY3QgPSBleHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCA9IGV4cG9ydHMuSnNvblNpemUgPSBleHBvcnRzLmdldEtub3duUHJvcGVydHlOYW1lcyA9IGV4cG9ydHMuaGFzUHJvcGVydHkgPSBleHBvcnRzLmlzT2JqZWN0ID0gZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gdm9pZCAwO1xuLy9cbi8vIFR5cGUgR3VhcmRzXG4vL1xuLyoqXG4gKiBBIHtAbGluayBOb25FbXB0eUFycmF5fSB0eXBlIGd1YXJkLlxuICpcbiAqIEB0ZW1wbGF0ZSBFbGVtZW50IC0gVGhlIG5vbi1lbXB0eSBhcnJheSBtZW1iZXIgdHlwZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgbm9uLWVtcHR5IGFycmF5LlxuICovXG5mdW5jdGlvbiBpc05vbkVtcHR5QXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMDtcbn1cbmV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gaXNOb25FbXB0eUFycmF5O1xuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBcIm51bGxpc2huZXNzXCIuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gQW55IHZhbHVlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3Ige0BsaW5rIFJ1bnRpbWVPYmplY3R9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBoYXMgYSBydW50aW1lIHR5cGUgb2YgYG9iamVjdGAgYW5kIGlzXG4gKiBuZWl0aGVyIGBudWxsYCBub3IgYW4gYEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vL1xuLy8gT3RoZXIgdXRpbGl0eSBmdW5jdGlvbnNcbi8vXG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3IgZW5zdXJpbmcgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBvYmplY3RUb0NoZWNrIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIHByb3BlcnR5IG5hbWUgdG8gY2hlY2sgZm9yLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIG9iamVjdCBoYXMgYW4gb3duIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZFxuICogbmFtZSwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0IGlzIGVudW1lcmFibGUgb3Igbm90LlxuICovXG5jb25zdCBoYXNQcm9wZXJ0eSA9IChvYmplY3RUb0NoZWNrLCBuYW1lKSA9PiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3RUb0NoZWNrLCBuYW1lKTtcbmV4cG9ydHMuaGFzUHJvcGVydHkgPSBoYXNQcm9wZXJ0eTtcbi8qKlxuICogYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKClgIGlzIGludGVudGlvbmFsbHkgZ2VuZXJpYzogaXQgcmV0dXJucyB0aGVcbiAqIGltbWVkaWF0ZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QsIGJ1dCBpdCBjYW5ub3QgbWFrZSBndWFyYW50ZWVzIGFib3V0XG4gKiB0aGUgY29udGVudHMgb2YgdGhhdCBvYmplY3QsIHNvIHRoZSB0eXBlIG9mIHRoZSBwcm9wZXJ0eSBuYW1lcyBpcyBtZXJlbHlcbiAqIGBzdHJpbmdbXWAuIFdoaWxlIHRoaXMgaXMgdGVjaG5pY2FsbHkgYWNjdXJhdGUsIGl0IGlzIGFsc28gdW5uZWNlc3NhcnkgaWYgd2VcbiAqIGhhdmUgYW4gb2JqZWN0IHdpdGggYSB0eXBlIHRoYXQgd2Ugb3duIChzdWNoIGFzIGFuIGVudW0pLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgcGxhaW4gb2JqZWN0LlxuICogQHJldHVybnMgVGhlIG93biBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgb2JqZWN0IHdoaWNoIGFyZSBhc3NpZ25lZCBhIHR5cGVcbiAqIGRlcml2ZWQgZnJvbSB0aGUgb2JqZWN0IGl0c2VsZi5cbiAqL1xuZnVuY3Rpb24gZ2V0S25vd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpO1xufVxuZXhwb3J0cy5nZXRLbm93blByb3BlcnR5TmFtZXMgPSBnZXRLbm93blByb3BlcnR5TmFtZXM7XG4vKipcbiAqIFByZWRlZmluZWQgc2l6ZXMgKGluIEJ5dGVzKSBvZiBzcGVjaWZpYyBwYXJ0cyBvZiBKU09OIHN0cnVjdHVyZS5cbiAqL1xudmFyIEpzb25TaXplO1xuKGZ1bmN0aW9uIChKc29uU2l6ZSkge1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiTnVsbFwiXSA9IDRdID0gXCJOdWxsXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJDb21tYVwiXSA9IDFdID0gXCJDb21tYVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiV3JhcHBlclwiXSA9IDFdID0gXCJXcmFwcGVyXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJUcnVlXCJdID0gNF0gPSBcIlRydWVcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkZhbHNlXCJdID0gNV0gPSBcIkZhbHNlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJRdW90ZVwiXSA9IDFdID0gXCJRdW90ZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiQ29sb25cIl0gPSAxXSA9IFwiQ29sb25cIjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiRGF0ZVwiXSA9IDI0XSA9IFwiRGF0ZVwiO1xufSkoSnNvblNpemUgPSBleHBvcnRzLkpzb25TaXplIHx8IChleHBvcnRzLkpzb25TaXplID0ge30pKTtcbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHdpdGggcGF0dGVybiBtYXRjaGluZyBmb3IgKHNwZWNpYWwpIGVzY2FwZWQgY2hhcmFjdGVycy5cbiAqL1xuZXhwb3J0cy5FU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFAgPSAvXCJ8XFxcXHxcXG58XFxyfFxcdC9ndTtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVHJ1ZSBpZiBhbiBvYmplY3QgaXMgdGhlIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LFxuICogZmFsc2UgaWYgdGhlIG9iamVjdCBpcyBub3QgcGxhaW4gKGUuZy4gZnVuY3Rpb24pLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBsZXQgcHJvdG8gPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gcHJvdG87XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuLyoqXG4gKiBDaGVjayBpZiBjaGFyYWN0ZXIgaXMgQVNDSUkuXG4gKlxuICogQHBhcmFtIGNoYXJhY3RlciAtIENoYXJhY3Rlci5cbiAqIEByZXR1cm5zIFRydWUgaWYgYSBjaGFyYWN0ZXIgY29kZSBpcyBBU0NJSSwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBpc0FTQ0lJKGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSA8PSAxMjc7XG59XG5leHBvcnRzLmlzQVNDSUkgPSBpc0FTQ0lJO1xuLyoqXG4gKiBDYWxjdWxhdGUgc3RyaW5nIHNpemUuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gU3RyaW5nIHZhbHVlIHRvIGNhbGN1bGF0ZSBzaXplLlxuICogQHJldHVybnMgTnVtYmVyIG9mIGJ5dGVzIHVzZWQgdG8gc3RvcmUgd2hvbGUgc3RyaW5nIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTdHJpbmdTaXplKHZhbHVlKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHZhbHVlLnNwbGl0KCcnKS5yZWR1Y2UoKHRvdGFsLCBjaGFyYWN0ZXIpID0+IHtcbiAgICAgICAgaWYgKGlzQVNDSUkoY2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWwgKyAyO1xuICAgIH0sIDApO1xuICAgIC8vIEFsc28gZGV0ZWN0IGNoYXJhY3RlcnMgdGhhdCBuZWVkIGJhY2tzbGFzaCBlc2NhcGVcbiAgICByZXR1cm4gc2l6ZSArICh2YWx1ZS5tYXRjaChleHBvcnRzLkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCkgPz8gW10pLmxlbmd0aDtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlU3RyaW5nU2l6ZSA9IGNhbGN1bGF0ZVN0cmluZ1NpemU7XG4vKipcbiAqIENhbGN1bGF0ZSBzaXplIG9mIGEgbnVtYmVyIG9mdGVyIEpTT04gc2VyaWFsaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBOdW1iZXIgdmFsdWUgdG8gY2FsY3VsYXRlIHNpemUuXG4gKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgdXNlZCB0byBzdG9yZSB3aG9sZSBudW1iZXIgaW4gSlNPTi5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlTnVtYmVyU2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aDtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlTnVtYmVyU2l6ZSA9IGNhbGN1bGF0ZU51bWJlclNpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taXNjLmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/misc.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/number.cjs":
/*!******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/number.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/assert.cjs\");\nconst hex_1 = __webpack_require__(/*! ./hex.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/hex.cjs\");\n/**\n * Convert a number to a hexadecimal string. This verifies that the number is a\n * non-negative safe integer.\n *\n * To convert a `bigint` to a hexadecimal string instead, use\n * {@link bigIntToHex}.\n *\n * @example\n * ```typescript\n * numberToHex(0); // '0x0'\n * numberToHex(1); // '0x1'\n * numberToHex(16); // '0x10'\n * ```\n * @param value - The number to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the number is not a non-negative safe integer.\n */\nconst numberToHex = (value) => {\n    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');\n    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');\n    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToHex` instead.');\n    return (0, hex_1.add0x)(value.toString(16));\n};\nexports.numberToHex = numberToHex;\n/**\n * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`\n * is a non-negative integer.\n *\n * To convert a number to a hexadecimal string instead, use {@link numberToHex}.\n *\n * @example\n * ```typescript\n * bigIntToHex(0n); // '0x0'\n * bigIntToHex(1n); // '0x1'\n * bigIntToHex(16n); // '0x10'\n * ```\n * @param value - The `bigint` to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the `bigint` is not a non-negative integer.\n */\nconst bigIntToHex = (value) => {\n    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');\n    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative bigint.');\n    return (0, hex_1.add0x)(value.toString(16));\n};\nexports.bigIntToHex = bigIntToHex;\n/**\n * Convert a hexadecimal string to a number. This verifies that the string is a\n * valid hex string, and that the resulting number is a safe integer. Both\n * \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a `bigint` instead, use\n * {@link hexToBigInt}.\n *\n * @example\n * ```typescript\n * hexToNumber('0x0'); // 0\n * hexToNumber('0x1'); // 1\n * hexToNumber('0x10'); // 16\n * ```\n * @param value - The hexadecimal string to convert to a number.\n * @returns The number.\n * @throws If the value is not a valid hexadecimal string, or if the resulting\n * number is not a safe integer.\n */\nconst hexToNumber = (value) => {\n    (0, hex_1.assertIsHexString)(value);\n    // `parseInt` accepts values without the \"0x\"-prefix, whereas `Number` does\n    // not. Using this is slightly faster than `Number(add0x(value))`.\n    const numberValue = parseInt(value, 16);\n    (0, assert_1.assert)(Number.isSafeInteger(numberValue), 'Value is not a safe integer. Use `hexToBigInt` instead.');\n    return numberValue;\n};\nexports.hexToNumber = hexToNumber;\n/**\n * Convert a hexadecimal string to a `bigint`. This verifies that the string is\n * a valid hex string. Both \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.\n *\n * @example\n * ```typescript\n * hexToBigInt('0x0'); // 0n\n * hexToBigInt('0x1'); // 1n\n * hexToBigInt('0x10'); // 16n\n * ```\n * @param value - The hexadecimal string to convert to a `bigint`.\n * @returns The `bigint`.\n * @throws If the value is not a valid hexadecimal string.\n */\nconst hexToBigInt = (value) => {\n    (0, hex_1.assertIsHexString)(value);\n    // The `BigInt` constructor requires the \"0x\"-prefix to parse a hex string.\n    return BigInt((0, hex_1.add0x)(value));\n};\nexports.hexToBigInt = hexToBigInt;\n//# sourceMappingURL=number.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbnVtYmVyLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUI7QUFDckYsaUJBQWlCLG1CQUFPLENBQUMsMEVBQWM7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLG9FQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtCQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGtCQUFrQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtCQUFrQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGtCQUFrQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9udW1iZXIuY2pzPzZkZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhleFRvQmlnSW50ID0gZXhwb3J0cy5oZXhUb051bWJlciA9IGV4cG9ydHMuYmlnSW50VG9IZXggPSBleHBvcnRzLm51bWJlclRvSGV4ID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnQuY2pzXCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXguY2pzXCIpO1xuLyoqXG4gKiBDb252ZXJ0IGEgbnVtYmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIG51bWJlciBpcyBhXG4gKiBub24tbmVnYXRpdmUgc2FmZSBpbnRlZ2VyLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgYmlnaW50YCB0byBhIGhleGFkZWNpbWFsIHN0cmluZyBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBiaWdJbnRUb0hleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIG51bWJlclRvSGV4KDApOyAvLyAnMHgwJ1xuICogbnVtYmVyVG9IZXgoMSk7IC8vICcweDEnXG4gKiBudW1iZXJUb0hleCgxNik7IC8vICcweDEwJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLCB3aXRoIHRoZSBcIjB4XCItcHJlZml4LlxuICogQHRocm93cyBJZiB0aGUgbnVtYmVyIGlzIG5vdCBhIG5vbi1uZWdhdGl2ZSBzYWZlIGludGVnZXIuXG4gKi9cbmNvbnN0IG51bWJlclRvSGV4ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ1ZhbHVlIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkodmFsdWUgPj0gMCwgJ1ZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBiaWdJbnRUb0hleGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gKDAsIGhleF8xLmFkZDB4KSh2YWx1ZS50b1N0cmluZygxNikpO1xufTtcbmV4cG9ydHMubnVtYmVyVG9IZXggPSBudW1iZXJUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGBiaWdpbnRgIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiBUaGlzIHZlcmlmaWVzIHRoYXQgdGhlIGBiaWdpbnRgXG4gKiBpcyBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBudW1iZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcgaW5zdGVhZCwgdXNlIHtAbGluayBudW1iZXJUb0hleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGJpZ0ludFRvSGV4KDBuKTsgLy8gJzB4MCdcbiAqIGJpZ0ludFRvSGV4KDFuKTsgLy8gJzB4MSdcbiAqIGJpZ0ludFRvSGV4KDE2bik7IC8vICcweDEwJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYGJpZ2ludGAgdG8gY29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcsIHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKiBAdGhyb3dzIElmIHRoZSBgYmlnaW50YCBpcyBub3QgYSBub24tbmVnYXRpdmUgaW50ZWdlci5cbiAqL1xuY29uc3QgYmlnSW50VG9IZXggPSAodmFsdWUpID0+IHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnLCAnVmFsdWUgbXVzdCBiZSBhIGJpZ2ludC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSAwLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBiaWdpbnQuJyk7XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkodmFsdWUudG9TdHJpbmcoMTYpKTtcbn07XG5leHBvcnRzLmJpZ0ludFRvSGV4ID0gYmlnSW50VG9IZXg7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBudW1iZXIuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgc3RyaW5nIGlzIGFcbiAqIHZhbGlkIGhleCBzdHJpbmcsIGFuZCB0aGF0IHRoZSByZXN1bHRpbmcgbnVtYmVyIGlzIGEgc2FmZSBpbnRlZ2VyLiBCb3RoXG4gKiBcIjB4XCItcHJlZml4ZWQgYW5kIHVucHJlZml4ZWQgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgYmlnaW50YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBoZXhUb0JpZ0ludH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGhleFRvTnVtYmVyKCcweDAnKTsgLy8gMFxuICogaGV4VG9OdW1iZXIoJzB4MScpOyAvLyAxXG4gKiBoZXhUb051bWJlcignMHgxMCcpOyAvLyAxNlxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4YWRlY2ltYWwgc3RyaW5nLCBvciBpZiB0aGUgcmVzdWx0aW5nXG4gKiBudW1iZXIgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLlxuICovXG5jb25zdCBoZXhUb051bWJlciA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBoZXhfMS5hc3NlcnRJc0hleFN0cmluZykodmFsdWUpO1xuICAgIC8vIGBwYXJzZUludGAgYWNjZXB0cyB2YWx1ZXMgd2l0aG91dCB0aGUgXCIweFwiLXByZWZpeCwgd2hlcmVhcyBgTnVtYmVyYCBkb2VzXG4gICAgLy8gbm90LiBVc2luZyB0aGlzIGlzIHNsaWdodGx5IGZhc3RlciB0aGFuIGBOdW1iZXIoYWRkMHgodmFsdWUpKWAuXG4gICAgY29uc3QgbnVtYmVyVmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTYpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlclZhbHVlKSwgJ1ZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBoZXhUb0JpZ0ludGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gbnVtYmVyVmFsdWU7XG59O1xuZXhwb3J0cy5oZXhUb051bWJlciA9IGhleFRvTnVtYmVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgYGJpZ2ludGAuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgc3RyaW5nIGlzXG4gKiBhIHZhbGlkIGhleCBzdHJpbmcuIEJvdGggXCIweFwiLXByZWZpeGVkIGFuZCB1bnByZWZpeGVkIHN0cmluZ3MgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBUbyBjb252ZXJ0IGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgbnVtYmVyIGluc3RlYWQsIHVzZSB7QGxpbmsgaGV4VG9OdW1iZXJ9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBoZXhUb0JpZ0ludCgnMHgwJyk7IC8vIDBuXG4gKiBoZXhUb0JpZ0ludCgnMHgxJyk7IC8vIDFuXG4gKiBoZXhUb0JpZ0ludCgnMHgxMCcpOyAvLyAxNm5cbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0IHRvIGEgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgYGJpZ2ludGAuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmNvbnN0IGhleFRvQmlnSW50ID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGhleF8xLmFzc2VydElzSGV4U3RyaW5nKSh2YWx1ZSk7XG4gICAgLy8gVGhlIGBCaWdJbnRgIGNvbnN0cnVjdG9yIHJlcXVpcmVzIHRoZSBcIjB4XCItcHJlZml4IHRvIHBhcnNlIGEgaGV4IHN0cmluZy5cbiAgICByZXR1cm4gQmlnSW50KCgwLCBoZXhfMS5hZGQweCkodmFsdWUpKTtcbn07XG5leHBvcnRzLmhleFRvQmlnSW50ID0gaGV4VG9CaWdJbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/number.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/opaque.cjs":
/*!******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/opaque.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=opaque.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3Qvb3BhcXVlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9vcGFxdWUuY2pzPzU4NjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGFxdWUuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/opaque.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/promise.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/promise.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createDeferredPromise = void 0;\n/**\n * Create a defered Promise.\n *\n * If the Promise is rejected prior to a handler being added, this can result in an\n * `UnhandledPromiseRejection` error. Optionally this can be suppressed with the\n * `suppressUnhandledRejection` flag, as it's common to belatedly handle deferred Promises, or to\n * ignore them if they're no longer relevant (e.g. related to a cancelled request).\n *\n * However, be very careful that you have handled the Promise if you do this. Suppressing these\n * errors is dangerous, they exist for good reason. An unhandled rejection can hide errors, making\n * debugging extremely difficult. They should only be suppressed if you're confident that the\n * Promise is always handled correctly, in both the success and failure cases.\n *\n * @param args - The arguments.\n * @param args.suppressUnhandledRejection - This option adds an empty error handler\n * to the Promise to suppress the UnhandledPromiseRejection error. This can be\n * useful if the deferred Promise is sometimes intentionally not used.\n * @returns A deferred Promise.\n * @template Result - The result type of the Promise.\n */\nfunction createDeferredPromise({ suppressUnhandledRejection = false, } = {}) {\n    let resolve;\n    let reject;\n    const promise = new Promise((innerResolve, innerReject) => {\n        resolve = innerResolve;\n        reject = innerReject;\n    });\n    if (suppressUnhandledRejection) {\n        promise.catch((_error) => {\n            // This handler is used to suppress the UnhandledPromiseRejection error\n        });\n    }\n    // @ts-expect-error We know that these are assigned, but TypeScript doesn't\n    return { promise, resolve, reject };\n}\nexports.createDeferredPromise = createDeferredPromise;\n//# sourceMappingURL=promise.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvcHJvbWlzZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0NBQXNDLElBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9wcm9taXNlLmNqcz8wN2YyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVEZWZlcnJlZFByb21pc2UgPSB2b2lkIDA7XG4vKipcbiAqIENyZWF0ZSBhIGRlZmVyZWQgUHJvbWlzZS5cbiAqXG4gKiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCBwcmlvciB0byBhIGhhbmRsZXIgYmVpbmcgYWRkZWQsIHRoaXMgY2FuIHJlc3VsdCBpbiBhblxuICogYFVuaGFuZGxlZFByb21pc2VSZWplY3Rpb25gIGVycm9yLiBPcHRpb25hbGx5IHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgd2l0aCB0aGVcbiAqIGBzdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbmAgZmxhZywgYXMgaXQncyBjb21tb24gdG8gYmVsYXRlZGx5IGhhbmRsZSBkZWZlcnJlZCBQcm9taXNlcywgb3IgdG9cbiAqIGlnbm9yZSB0aGVtIGlmIHRoZXkncmUgbm8gbG9uZ2VyIHJlbGV2YW50IChlLmcuIHJlbGF0ZWQgdG8gYSBjYW5jZWxsZWQgcmVxdWVzdCkuXG4gKlxuICogSG93ZXZlciwgYmUgdmVyeSBjYXJlZnVsIHRoYXQgeW91IGhhdmUgaGFuZGxlZCB0aGUgUHJvbWlzZSBpZiB5b3UgZG8gdGhpcy4gU3VwcHJlc3NpbmcgdGhlc2VcbiAqIGVycm9ycyBpcyBkYW5nZXJvdXMsIHRoZXkgZXhpc3QgZm9yIGdvb2QgcmVhc29uLiBBbiB1bmhhbmRsZWQgcmVqZWN0aW9uIGNhbiBoaWRlIGVycm9ycywgbWFraW5nXG4gKiBkZWJ1Z2dpbmcgZXh0cmVtZWx5IGRpZmZpY3VsdC4gVGhleSBzaG91bGQgb25seSBiZSBzdXBwcmVzc2VkIGlmIHlvdSdyZSBjb25maWRlbnQgdGhhdCB0aGVcbiAqIFByb21pc2UgaXMgYWx3YXlzIGhhbmRsZWQgY29ycmVjdGx5LCBpbiBib3RoIHRoZSBzdWNjZXNzIGFuZCBmYWlsdXJlIGNhc2VzLlxuICpcbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSBhcmdzLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9uIC0gVGhpcyBvcHRpb24gYWRkcyBhbiBlbXB0eSBlcnJvciBoYW5kbGVyXG4gKiB0byB0aGUgUHJvbWlzZSB0byBzdXBwcmVzcyB0aGUgVW5oYW5kbGVkUHJvbWlzZVJlamVjdGlvbiBlcnJvci4gVGhpcyBjYW4gYmVcbiAqIHVzZWZ1bCBpZiB0aGUgZGVmZXJyZWQgUHJvbWlzZSBpcyBzb21ldGltZXMgaW50ZW50aW9uYWxseSBub3QgdXNlZC5cbiAqIEByZXR1cm5zIEEgZGVmZXJyZWQgUHJvbWlzZS5cbiAqIEB0ZW1wbGF0ZSBSZXN1bHQgLSBUaGUgcmVzdWx0IHR5cGUgb2YgdGhlIFByb21pc2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkUHJvbWlzZSh7IHN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9uID0gZmFsc2UsIH0gPSB7fSkge1xuICAgIGxldCByZXNvbHZlO1xuICAgIGxldCByZWplY3Q7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChpbm5lclJlc29sdmUsIGlubmVyUmVqZWN0KSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSBpbm5lclJlc29sdmU7XG4gICAgICAgIHJlamVjdCA9IGlubmVyUmVqZWN0O1xuICAgIH0pO1xuICAgIGlmIChzdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbikge1xuICAgICAgICBwcm9taXNlLmNhdGNoKChfZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIFRoaXMgaGFuZGxlciBpcyB1c2VkIHRvIHN1cHByZXNzIHRoZSBVbmhhbmRsZWRQcm9taXNlUmVqZWN0aW9uIGVycm9yXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGtub3cgdGhhdCB0aGVzZSBhcmUgYXNzaWduZWQsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3RcbiAgICByZXR1cm4geyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfTtcbn1cbmV4cG9ydHMuY3JlYXRlRGVmZXJyZWRQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvbWlzZS5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/promise.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/time.cjs":
/*!****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/time.cjs ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.timeSince = exports.inMilliseconds = exports.Duration = void 0;\n/**\n * Common duration constants, in milliseconds.\n */\nvar Duration;\n(function (Duration) {\n    /**\n     * A millisecond.\n     */\n    Duration[Duration[\"Millisecond\"] = 1] = \"Millisecond\";\n    /**\n     * A second, in milliseconds.\n     */\n    Duration[Duration[\"Second\"] = 1000] = \"Second\";\n    /**\n     * A minute, in milliseconds.\n     */\n    Duration[Duration[\"Minute\"] = 60000] = \"Minute\";\n    /**\n     * An hour, in milliseconds.\n     */\n    Duration[Duration[\"Hour\"] = 3600000] = \"Hour\";\n    /**\n     * A day, in milliseconds.\n     */\n    Duration[Duration[\"Day\"] = 86400000] = \"Day\";\n    /**\n     * A week, in milliseconds.\n     */\n    Duration[Duration[\"Week\"] = 604800000] = \"Week\";\n    /**\n     * A year, in milliseconds.\n     */\n    Duration[Duration[\"Year\"] = 31536000000] = \"Year\";\n})(Duration = exports.Duration || (exports.Duration = {}));\nconst isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;\nconst assertIsNonNegativeInteger = (number, name) => {\n    if (!isNonNegativeInteger(number)) {\n        throw new Error(`\"${name}\" must be a non-negative integer. Received: \"${number}\".`);\n    }\n};\n/**\n * Calculates the millisecond value of the specified number of units of time.\n *\n * @param count - The number of units of time.\n * @param duration - The unit of time to count.\n * @returns The count multiplied by the specified duration.\n */\nfunction inMilliseconds(count, duration) {\n    assertIsNonNegativeInteger(count, 'count');\n    return count * duration;\n}\nexports.inMilliseconds = inMilliseconds;\n/**\n * Gets the milliseconds since a particular Unix epoch timestamp.\n *\n * @param timestamp - A Unix millisecond timestamp.\n * @returns The number of milliseconds elapsed since the specified timestamp.\n */\nfunction timeSince(timestamp) {\n    assertIsNonNegativeInteger(timestamp, 'timestamp');\n    return Date.now() - timestamp;\n}\nexports.timeSince = timeSince;\n//# sourceMappingURL=time.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvdGltZS5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsc0JBQXNCLEdBQUcsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDLGdCQUFnQixLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLLCtDQUErQyxPQUFPO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RpbWUuY2pzPzVjZTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRpbWVTaW5jZSA9IGV4cG9ydHMuaW5NaWxsaXNlY29uZHMgPSBleHBvcnRzLkR1cmF0aW9uID0gdm9pZCAwO1xuLyoqXG4gKiBDb21tb24gZHVyYXRpb24gY29uc3RhbnRzLCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbnZhciBEdXJhdGlvbjtcbihmdW5jdGlvbiAoRHVyYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBBIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiTWlsbGlzZWNvbmRcIl0gPSAxXSA9IFwiTWlsbGlzZWNvbmRcIjtcbiAgICAvKipcbiAgICAgKiBBIHNlY29uZCwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiU2Vjb25kXCJdID0gMTAwMF0gPSBcIlNlY29uZFwiO1xuICAgIC8qKlxuICAgICAqIEEgbWludXRlLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJNaW51dGVcIl0gPSA2MDAwMF0gPSBcIk1pbnV0ZVwiO1xuICAgIC8qKlxuICAgICAqIEFuIGhvdXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIkhvdXJcIl0gPSAzNjAwMDAwXSA9IFwiSG91clwiO1xuICAgIC8qKlxuICAgICAqIEEgZGF5LCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJEYXlcIl0gPSA4NjQwMDAwMF0gPSBcIkRheVwiO1xuICAgIC8qKlxuICAgICAqIEEgd2VlaywgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiV2Vla1wiXSA9IDYwNDgwMDAwMF0gPSBcIldlZWtcIjtcbiAgICAvKipcbiAgICAgKiBBIHllYXIsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIlllYXJcIl0gPSAzMTUzNjAwMDAwMF0gPSBcIlllYXJcIjtcbn0pKER1cmF0aW9uID0gZXhwb3J0cy5EdXJhdGlvbiB8fCAoZXhwb3J0cy5EdXJhdGlvbiA9IHt9KSk7XG5jb25zdCBpc05vbk5lZ2F0aXZlSW50ZWdlciA9IChudW1iZXIpID0+IE51bWJlci5pc0ludGVnZXIobnVtYmVyKSAmJiBudW1iZXIgPj0gMDtcbmNvbnN0IGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyID0gKG51bWJlciwgbmFtZSkgPT4ge1xuICAgIGlmICghaXNOb25OZWdhdGl2ZUludGVnZXIobnVtYmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlci4gUmVjZWl2ZWQ6IFwiJHtudW1iZXJ9XCIuYCk7XG4gICAgfVxufTtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbWlsbGlzZWNvbmQgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdW5pdHMgb2YgdGltZS5cbiAqXG4gKiBAcGFyYW0gY291bnQgLSBUaGUgbnVtYmVyIG9mIHVuaXRzIG9mIHRpbWUuXG4gKiBAcGFyYW0gZHVyYXRpb24gLSBUaGUgdW5pdCBvZiB0aW1lIHRvIGNvdW50LlxuICogQHJldHVybnMgVGhlIGNvdW50IG11bHRpcGxpZWQgYnkgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5NaWxsaXNlY29uZHMoY291bnQsIGR1cmF0aW9uKSB7XG4gICAgYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIoY291bnQsICdjb3VudCcpO1xuICAgIHJldHVybiBjb3VudCAqIGR1cmF0aW9uO1xufVxuZXhwb3J0cy5pbk1pbGxpc2Vjb25kcyA9IGluTWlsbGlzZWNvbmRzO1xuLyoqXG4gKiBHZXRzIHRoZSBtaWxsaXNlY29uZHMgc2luY2UgYSBwYXJ0aWN1bGFyIFVuaXggZXBvY2ggdGltZXN0YW1wLlxuICpcbiAqIEBwYXJhbSB0aW1lc3RhbXAgLSBBIFVuaXggbWlsbGlzZWNvbmQgdGltZXN0YW1wLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcC5cbiAqL1xuZnVuY3Rpb24gdGltZVNpbmNlKHRpbWVzdGFtcCkge1xuICAgIGFzc2VydElzTm9uTmVnYXRpdmVJbnRlZ2VyKHRpbWVzdGFtcCwgJ3RpbWVzdGFtcCcpO1xuICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xufVxuZXhwb3J0cy50aW1lU2luY2UgPSB0aW1lU2luY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lLmNqcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/time.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/transaction-types.cjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/transaction-types.cjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=transaction-types.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvdHJhbnNhY3Rpb24tdHlwZXMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RyYW5zYWN0aW9uLXR5cGVzLmNqcz85YmRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb24tdHlwZXMuY2pzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/transaction-types.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/versions.cjs":
/*!********************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/versions.cjs ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;\nconst superstruct_1 = __webpack_require__(/*! @metamask/superstruct */ \"(ssr)/./node_modules/@metamask/superstruct/dist/index.cjs\");\nconst semver_1 = __webpack_require__(/*! semver */ \"(ssr)/./node_modules/semver/index.js\");\nconst assert_1 = __webpack_require__(/*! ./assert.cjs */ \"(ssr)/./node_modules/@metamask/utils/dist/assert.cjs\");\n/**\n * A struct for validating a version string.\n */\nexports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version', (value) => {\n    if ((0, semver_1.valid)(value) === null) {\n        return `Expected SemVer version, got \"${value}\"`;\n    }\n    return true;\n});\nexports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version range', (value) => {\n    if ((0, semver_1.validRange)(value) === null) {\n        return `Expected SemVer range, got \"${value}\"`;\n    }\n    return true;\n});\n/**\n * Checks whether a SemVer version is valid.\n *\n * @param version - A potential version.\n * @returns `true` if the version is valid, and `false` otherwise.\n */\nfunction isValidSemVerVersion(version) {\n    return (0, superstruct_1.is)(version, exports.VersionStruct);\n}\nexports.isValidSemVerVersion = isValidSemVerVersion;\n/**\n * Checks whether a SemVer version range is valid.\n *\n * @param versionRange - A potential version range.\n * @returns `true` if the version range is valid, and `false` otherwise.\n */\nfunction isValidSemVerRange(versionRange) {\n    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);\n}\nexports.isValidSemVerRange = isValidSemVerRange;\n/**\n * Asserts that a value is a valid concrete SemVer version.\n *\n * @param version - A potential SemVer concrete version.\n */\nfunction assertIsSemVerVersion(version) {\n    (0, assert_1.assertStruct)(version, exports.VersionStruct);\n}\nexports.assertIsSemVerVersion = assertIsSemVerVersion;\n/**\n * Asserts that a value is a valid SemVer range.\n *\n * @param range - A potential SemVer range.\n */\nfunction assertIsSemVerRange(range) {\n    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);\n}\nexports.assertIsSemVerRange = assertIsSemVerRange;\n/**\n * Checks whether a SemVer version is greater than another.\n *\n * @param version1 - The left-hand version.\n * @param version2 - The right-hand version.\n * @returns `version1 > version2`.\n */\nfunction gtVersion(version1, version2) {\n    return (0, semver_1.gt)(version1, version2);\n}\nexports.gtVersion = gtVersion;\n/**\n * Checks whether a SemVer version is greater than all possibilities in a range.\n *\n * @param version - A SemvVer version.\n * @param range - The range to check against.\n * @returns `version > range`.\n */\nfunction gtRange(version, range) {\n    return (0, semver_1.gtr)(version, range);\n}\nexports.gtRange = gtRange;\n/**\n * Returns whether a SemVer version satisfies a SemVer range.\n *\n * @param version - The SemVer version to check.\n * @param versionRange - The SemVer version range to check against.\n * @returns Whether the version satisfied the version range.\n */\nfunction satisfiesVersionRange(version, versionRange) {\n    return (0, semver_1.satisfies)(version, versionRange, {\n        includePrerelease: true,\n    });\n}\nexports.satisfiesVersionRange = satisfiesVersionRange;\n//# sourceMappingURL=versions.cjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvdmVyc2lvbnMuY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLGVBQWUsR0FBRyxpQkFBaUIsR0FBRywyQkFBMkIsR0FBRyw2QkFBNkIsR0FBRywwQkFBMEIsR0FBRyw0QkFBNEIsR0FBRywwQkFBMEIsR0FBRyxxQkFBcUI7QUFDbFAsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQXVCO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLG9EQUFRO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMEJBQTBCO0FBQzFCO0FBQ0EsOENBQThDLE1BQU07QUFDcEQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC92ZXJzaW9ucy5janM/OTdlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2F0aXNmaWVzVmVyc2lvblJhbmdlID0gZXhwb3J0cy5ndFJhbmdlID0gZXhwb3J0cy5ndFZlcnNpb24gPSBleHBvcnRzLmFzc2VydElzU2VtVmVyUmFuZ2UgPSBleHBvcnRzLmFzc2VydElzU2VtVmVyVmVyc2lvbiA9IGV4cG9ydHMuaXNWYWxpZFNlbVZlclJhbmdlID0gZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IGV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gZXhwb3J0cy5WZXJzaW9uU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svc3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBzZW12ZXJfMSA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydC5janNcIik7XG4vKipcbiAqIEEgc3RydWN0IGZvciB2YWxpZGF0aW5nIGEgdmVyc2lvbiBzdHJpbmcuXG4gKi9cbmV4cG9ydHMuVmVyc2lvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnJlZmluZSkoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAnVmVyc2lvbicsICh2YWx1ZSkgPT4ge1xuICAgIGlmICgoMCwgc2VtdmVyXzEudmFsaWQpKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIFNlbVZlciB2ZXJzaW9uLCBnb3QgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbmV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucmVmaW5lKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksICdWZXJzaW9uIHJhbmdlJywgKHZhbHVlKSA9PiB7XG4gICAgaWYgKCgwLCBzZW12ZXJfMS52YWxpZFJhbmdlKSh2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RlZCBTZW1WZXIgcmFuZ2UsIGdvdCBcIiR7dmFsdWV9XCJgO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQSBwb3RlbnRpYWwgdmVyc2lvbi5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVyc2lvbiBpcyB2YWxpZCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU2VtVmVyVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2ZXJzaW9uLCBleHBvcnRzLlZlcnNpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IGlzVmFsaWRTZW1WZXJWZXJzaW9uO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIHJhbmdlIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uUmFuZ2UgLSBBIHBvdGVudGlhbCB2ZXJzaW9uIHJhbmdlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZXJzaW9uIHJhbmdlIGlzIHZhbGlkLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTZW1WZXJSYW5nZSh2ZXJzaW9uUmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZlcnNpb25SYW5nZSwgZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc1ZhbGlkU2VtVmVyUmFuZ2UgPSBpc1ZhbGlkU2VtVmVyUmFuZ2U7XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgY29uY3JldGUgU2VtVmVyIHZlcnNpb24uXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIHBvdGVudGlhbCBTZW1WZXIgY29uY3JldGUgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTZW1WZXJWZXJzaW9uKHZlcnNpb24pIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2ZXJzaW9uLCBleHBvcnRzLlZlcnNpb25TdHJ1Y3QpO1xufVxuZXhwb3J0cy5hc3NlcnRJc1NlbVZlclZlcnNpb24gPSBhc3NlcnRJc1NlbVZlclZlcnNpb247XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgU2VtVmVyIHJhbmdlLlxuICpcbiAqIEBwYXJhbSByYW5nZSAtIEEgcG90ZW50aWFsIFNlbVZlciByYW5nZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTZW1WZXJSYW5nZShyYW5nZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHJhbmdlLCBleHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCk7XG59XG5leHBvcnRzLmFzc2VydElzU2VtVmVyUmFuZ2UgPSBhc3NlcnRJc1NlbVZlclJhbmdlO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIFNlbVZlciB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uMSAtIFRoZSBsZWZ0LWhhbmQgdmVyc2lvbi5cbiAqIEBwYXJhbSB2ZXJzaW9uMiAtIFRoZSByaWdodC1oYW5kIHZlcnNpb24uXG4gKiBAcmV0dXJucyBgdmVyc2lvbjEgPiB2ZXJzaW9uMmAuXG4gKi9cbmZ1bmN0aW9uIGd0VmVyc2lvbih2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLmd0KSh2ZXJzaW9uMSwgdmVyc2lvbjIpO1xufVxuZXhwb3J0cy5ndFZlcnNpb24gPSBndFZlcnNpb247XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCBwb3NzaWJpbGl0aWVzIGluIGEgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIFNlbXZWZXIgdmVyc2lvbi5cbiAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgYHZlcnNpb24gPiByYW5nZWAuXG4gKi9cbmZ1bmN0aW9uIGd0UmFuZ2UodmVyc2lvbiwgcmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLmd0cikodmVyc2lvbiwgcmFuZ2UpO1xufVxuZXhwb3J0cy5ndFJhbmdlID0gZ3RSYW5nZTtcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gc2F0aXNmaWVzIGEgU2VtVmVyIHJhbmdlLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIFNlbVZlciB2ZXJzaW9uIHRvIGNoZWNrLlxuICogQHBhcmFtIHZlcnNpb25SYW5nZSAtIFRoZSBTZW1WZXIgdmVyc2lvbiByYW5nZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmVyc2lvbiBzYXRpc2ZpZWQgdGhlIHZlcnNpb24gcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHNhdGlzZmllc1ZlcnNpb25SYW5nZSh2ZXJzaW9uLCB2ZXJzaW9uUmFuZ2UpIHtcbiAgICByZXR1cm4gKDAsIHNlbXZlcl8xLnNhdGlzZmllcykodmVyc2lvbiwgdmVyc2lvblJhbmdlLCB7XG4gICAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiB0cnVlLFxuICAgIH0pO1xufVxuZXhwb3J0cy5zYXRpc2ZpZXNWZXJzaW9uUmFuZ2UgPSBzYXRpc2ZpZXNWZXJzaW9uUmFuZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9ucy5janMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/versions.cjs\n");

/***/ })

};
;